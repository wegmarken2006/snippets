{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Snippets Tested on 64-bit Windows","title":"Home"},{"location":"#snippets","text":"Tested on 64-bit Windows","title":"Snippets"},{"location":"List/","text":"List C# using System ; using System.Collections.Generic ; public class Program { public static void Main ( string [] args ) { //new empty list var lst1 = new List < string >(); //new initialized list var lst2 = new List < string > { \"str20\" , \"str21\" }; //append element lst1 . Add ( \"str10\" ); //append list lst1 . AddRange ( lst2 ); //add head element lst1 . Insert ( 0 , \"str00\" ); //reverse lst1 . Reverse (); //sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] //list length var lst3 = lst1 . GetRange ( 1 , lst1 . Count - 1 ); Console . WriteLine (); foreach ( var item in lst3 ) { Console . Write ( \"{0} \" , item ); } //map and filter var lst4 = lst1 . Select (( x ) => x . ToUpper ()); var lst5 = lst4 . Where (( x ) => x != \"STR00\" ); Console . WriteLine (); foreach ( var item in lst5 ) { Console . Write ( \"{0} \" , item ); } } } Dart main ( List < String > arguments ) { // new empty list var lst1 = List < String > (); //new initialized list var lst2 = [ \"str20\" , \"str21\" ]; // append element lst1 . add ( \"str10\" ); // append list lst1 = lst1 + lst2 ; // add head element lst1 = [ \"str00\" ] + lst1 ; //reverse lst1 = lst1 . reversed . toList (); // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] // list length var lst3 = lst1 . sublist ( 1 , lst1 . length ); print ( ' $ lst3 ' ); // map and filter var lst4 = lst3 . map (( x ) => x . toUpperCase ()); var lst5 = lst4 . where (( x ) => x != \"STR00\" ); print ( ' $ lst5 ' ); } Go package main import ( \"fmt\" \"sort\" \"strings\" ) func main () { //new empty list lst1 := stringList {} //new initialized list lst2 := stringList { \"str20\" , \"str21\" } //append element lst1 = append ( lst1 , \"str10\" ) //append list lst1 = append ( lst1 , lst2 ... ) //add head element lst1 = append ([] string { \"str00\" }, lst1 ... ) //reverse sort . Sort ( sort . Reverse ( lst1 )) //sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] //list length lst3 := lst1 [ 1 : len ( lst1 )] fmt . Printf ( \"\\n%v\" , lst3 ) //map and filter lst4 := stringList {} for _ , elem := range lst1 { lst4 = append ( lst4 , strings . ToUpper ( elem )) } lst5 := stringList {} for _ , elem := range lst4 { if elem != \"STR00\" { lst5 = append ( lst5 , elem ) } } fmt . Printf ( \"\\n%v\" , lst5 ) } type stringList [] string func ( p stringList ) Len () int { return len ( p ) } func ( p stringList ) Less ( i , j int ) bool { return p [ i ] < p [ j ] } func ( p stringList ) Swap ( i , j int ) { p [ i ], p [ j ] = p [ j ], p [ i ] } Nim import sequtils as sq import algorithm as al import strutils as st # new empty list var lst1 : seq [ string ] = @[] # new initialized list var lst2 = @[ \"str20\" , \"str21\" ] # append element lst1 . add ( \"str10\" ) #append list lst1 = sq . concat ( lst1 , lst2 ) # add head element lst1 = sq . concat ( @[ \"str00\" ] , lst1 ) # reverse lst1 = al . reversed ( lst1 ) # sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] # list length var lst3 = lst1 [ 1 .. len ( lst1 ) - 1 ] echo lst3 # map and filter var lst4 = map ( lst3 , proc ( x : string ): string = st . toUpper ( x )) var lst5 = filter ( lst4 , proc ( x : string ): bool = x != \"STR00\" ) echo lst5 Python from typing import List # new empty list lst1 : List [ str ] = [] # new initialized list lst2 : List [ str ] = [ \"str20\" , \"str21\" ] # append element lst1 = lst1 + [ \"str10\" ] # append list lst1 = lst1 + lst2 # add head element lst1 = [ \"str00\" ] + lst1 # reverse lst1 . reverse () # sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] # list length lst3 : List [ str ] = lst1 [ 1 : len ( lst1 )] print ( lst3 ) # map and filter lst4 : List [ str ] = [ elem for elem in map ( lambda x : x . upper (), lst1 )] lst5 = [ elem for elem in filter ( lambda x : x != \"STR00\" , lst4 )] print ( lst5 ) Rust fn main () { // new empty list let mut lst1 : Vec <& str > = vec ! []; //new initialized list let lst2 = vec ! [ \"str20\" , \"str21\" ]; // append element lst1 . push ( \"str10\" ); // append list lst1 . extend ( lst2 ); // add head element lst1 . insert ( 0 , \"str00\" ); //reverse lst1 . reverse (); // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] // list length let lst3 : Vec <& str > = lst1 [ 1 .. lst1 . len ()]. to_vec (); println ! ( \"{:?}\" , & lst3 ); // map and filter let lst4 : Vec < _ > = lst3 . into_iter (). map ( | x | x . to_uppercase ()). collect (); let lst5 : Vec < _ > = lst4 . into_iter (). filter ( | x | * x != \"STR00\" ). collect (); println ! ( \"{:?}\" , & lst5 ); }","title":"List"},{"location":"List/#list","text":"","title":"List"},{"location":"List/#c35","text":"using System ; using System.Collections.Generic ; public class Program { public static void Main ( string [] args ) { //new empty list var lst1 = new List < string >(); //new initialized list var lst2 = new List < string > { \"str20\" , \"str21\" }; //append element lst1 . Add ( \"str10\" ); //append list lst1 . AddRange ( lst2 ); //add head element lst1 . Insert ( 0 , \"str00\" ); //reverse lst1 . Reverse (); //sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] //list length var lst3 = lst1 . GetRange ( 1 , lst1 . Count - 1 ); Console . WriteLine (); foreach ( var item in lst3 ) { Console . Write ( \"{0} \" , item ); } //map and filter var lst4 = lst1 . Select (( x ) => x . ToUpper ()); var lst5 = lst4 . Where (( x ) => x != \"STR00\" ); Console . WriteLine (); foreach ( var item in lst5 ) { Console . Write ( \"{0} \" , item ); } } }","title":"C#"},{"location":"List/#dart","text":"main ( List < String > arguments ) { // new empty list var lst1 = List < String > (); //new initialized list var lst2 = [ \"str20\" , \"str21\" ]; // append element lst1 . add ( \"str10\" ); // append list lst1 = lst1 + lst2 ; // add head element lst1 = [ \"str00\" ] + lst1 ; //reverse lst1 = lst1 . reversed . toList (); // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] // list length var lst3 = lst1 . sublist ( 1 , lst1 . length ); print ( ' $ lst3 ' ); // map and filter var lst4 = lst3 . map (( x ) => x . toUpperCase ()); var lst5 = lst4 . where (( x ) => x != \"STR00\" ); print ( ' $ lst5 ' ); }","title":"Dart"},{"location":"List/#go","text":"package main import ( \"fmt\" \"sort\" \"strings\" ) func main () { //new empty list lst1 := stringList {} //new initialized list lst2 := stringList { \"str20\" , \"str21\" } //append element lst1 = append ( lst1 , \"str10\" ) //append list lst1 = append ( lst1 , lst2 ... ) //add head element lst1 = append ([] string { \"str00\" }, lst1 ... ) //reverse sort . Sort ( sort . Reverse ( lst1 )) //sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] //list length lst3 := lst1 [ 1 : len ( lst1 )] fmt . Printf ( \"\\n%v\" , lst3 ) //map and filter lst4 := stringList {} for _ , elem := range lst1 { lst4 = append ( lst4 , strings . ToUpper ( elem )) } lst5 := stringList {} for _ , elem := range lst4 { if elem != \"STR00\" { lst5 = append ( lst5 , elem ) } } fmt . Printf ( \"\\n%v\" , lst5 ) } type stringList [] string func ( p stringList ) Len () int { return len ( p ) } func ( p stringList ) Less ( i , j int ) bool { return p [ i ] < p [ j ] } func ( p stringList ) Swap ( i , j int ) { p [ i ], p [ j ] = p [ j ], p [ i ] }","title":"Go"},{"location":"List/#nim","text":"import sequtils as sq import algorithm as al import strutils as st # new empty list var lst1 : seq [ string ] = @[] # new initialized list var lst2 = @[ \"str20\" , \"str21\" ] # append element lst1 . add ( \"str10\" ) #append list lst1 = sq . concat ( lst1 , lst2 ) # add head element lst1 = sq . concat ( @[ \"str00\" ] , lst1 ) # reverse lst1 = al . reversed ( lst1 ) # sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] # list length var lst3 = lst1 [ 1 .. len ( lst1 ) - 1 ] echo lst3 # map and filter var lst4 = map ( lst3 , proc ( x : string ): string = st . toUpper ( x )) var lst5 = filter ( lst4 , proc ( x : string ): bool = x != \"STR00\" ) echo lst5","title":"Nim"},{"location":"List/#python","text":"from typing import List # new empty list lst1 : List [ str ] = [] # new initialized list lst2 : List [ str ] = [ \"str20\" , \"str21\" ] # append element lst1 = lst1 + [ \"str10\" ] # append list lst1 = lst1 + lst2 # add head element lst1 = [ \"str00\" ] + lst1 # reverse lst1 . reverse () # sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] # list length lst3 : List [ str ] = lst1 [ 1 : len ( lst1 )] print ( lst3 ) # map and filter lst4 : List [ str ] = [ elem for elem in map ( lambda x : x . upper (), lst1 )] lst5 = [ elem for elem in filter ( lambda x : x != \"STR00\" , lst4 )] print ( lst5 )","title":"Python"},{"location":"List/#rust","text":"fn main () { // new empty list let mut lst1 : Vec <& str > = vec ! []; //new initialized list let lst2 = vec ! [ \"str20\" , \"str21\" ]; // append element lst1 . push ( \"str10\" ); // append list lst1 . extend ( lst2 ); // add head element lst1 . insert ( 0 , \"str00\" ); //reverse lst1 . reverse (); // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] // list length let lst3 : Vec <& str > = lst1 [ 1 .. lst1 . len ()]. to_vec (); println ! ( \"{:?}\" , & lst3 ); // map and filter let lst4 : Vec < _ > = lst3 . into_iter (). map ( | x | x . to_uppercase ()). collect (); let lst5 : Vec < _ > = lst4 . into_iter (). filter ( | x | * x != \"STR00\" ). collect (); println ! ( \"{:?}\" , & lst5 ); }","title":"Rust"},{"location":"dictionary/","text":"Dictionary C# using System ; using System.Collections.Generic ; using System.Linq ; public class Program { public static void Main ( string [] args ) { //count words var wordList = new List < string > { \"glass\" , \"table\" , \"chair\" , \"chair\" }; var words = new Dictionary < string , int >(); foreach ( var item in wordList ) { if ( words . ContainsKey ( item )) { words [ item ] = ( int ) words [ item ] + 1 ; } else { words . Add ( item , 1 ); } } Console . WriteLine (); foreach ( var item in words ) { Console . Write ( \"{0}:{1} \" , item . Key , item . Value ); } Console . WriteLine (); var sorted = words . OrderBy ( x => - x . Value ); foreach ( var item in sorted ) { Console . Write ( \"{0}:{1} \" , item . Key , item . Value ); } } } Dart import 'dart:collection' ; main ( List < String > arguments ) { //count words var wordList = [ \"glass\" , \"table\" , \"chair\" , \"chair\" ]; var words = Map (); for ( var item in wordList ) { if ( words . containsKey ( item )) { words [ item ] += 1 ; } else { words [ item ] = 1 ; } } print ( ' $ words ' ); //sort values descending order var sorted = sortMap ( words ); print ( ' $ sorted ' ); } LinkedHashMap sortMap ( Map map ) { var mapk = map . keys . toList (); //sort keys according to values descending order mapk . sort (( k1 , k2 ) => map [ k2 ]. compareTo ( map [ k1 ])); var outMap = LinkedHashMap . fromIterable ( mapk , key: ( k ) => k , value: ( k ) => map [ k ]); return ( outMap ); } Go package main import ( \"fmt\" \"sort\" ) func main () { //count words wordList := [] string { \"glass\" , \"table\" , \"chair\" , \"chair\" } words := make ( map [ string ] int ) for _ , item := range wordList { words [ item ] ++ } fmt . Printf ( \"\\n%v\" , words ) //sort by descending value fmt . Printf ( \"\\n%v\" , mapSort ( words )) } func mapSort ( mapIn map [ string ] int ) keyValList { //dict to slice mapS := keyValList {} for k , v := range mapIn { mapS = append ( mapS , keyVal { k , v }) } sort . Sort ( sort . Reverse ( mapS )) return mapS } type keyVal struct { key string val int } type keyValList [] keyVal func ( p keyValList ) Len () int { return len ( p ) } func ( p keyValList ) Less ( i , j int ) bool { return p [ i ]. val < p [ j ]. val } func ( p keyValList ) Swap ( i , j int ){ p [ i ], p [ j ] = p [ j ], p [ i ] } Nim import tables import algorithm as al # count words var wordList = @[ \"glass\" , \"table\" , \"chair\" , \"chair\" ] #var words = initTable[string, int]() var words = initOrderedTable [ string , int ] () for item in wordList : if words . hasKey ( item ): words [ item ] += 1 else : words . add ( item , 1 ) echo words # sort by descending value words . sort ( proc ( x , y : ( string , int )): int = x [ 1 ] - y [ 1 ] , order = al . SortOrder . Descending ) echo words Python from typing import Dict , List , Tuple from operator import itemgetter # count words word_list : List [ str ] = [ \"glass\" , \"table\" , \"chair\" , \"chair\" ] words : Dict [ str , int ] = {} for item in word_list : try : words [ item ] += 1 except : words [ item ] = 1 print ( words ) # sort by descending value words_l : List [ Tuple [ str , int ]] = list ( words . items ()) words_l = sorted ( words_l , reverse = True , key = itemgetter ( 1 )) print ( words_l ) Rust use std :: collections :: HashMap ; use std :: cmp :: Reverse ; fn main () { //count words let word_list = vec ! [ \"glass\" , \"table\" , \"chair\" , \"chair\" ]; let mut words : HashMap < String , usize > = HashMap :: new (); for item in word_list { let count = words . entry (( * item ). to_string ()). or_insert ( 0 ); * count += 1 ; } //get specific key value let value = words . get ( \"chair\" ). expect ( \"no key\" ); println ! ( \"{:?} {:?}\" , & words , value ); //sort by descending value let mut words_v : Vec < _ > = words . iter (). collect (); words_v . sort_by_key ( |& ( word , count ) | ( Reverse ( count ), word )); println ! ( \"{:?}\" , & words_v ); }","title":"Dictionary"},{"location":"dictionary/#dictionary","text":"","title":"Dictionary"},{"location":"dictionary/#c35","text":"using System ; using System.Collections.Generic ; using System.Linq ; public class Program { public static void Main ( string [] args ) { //count words var wordList = new List < string > { \"glass\" , \"table\" , \"chair\" , \"chair\" }; var words = new Dictionary < string , int >(); foreach ( var item in wordList ) { if ( words . ContainsKey ( item )) { words [ item ] = ( int ) words [ item ] + 1 ; } else { words . Add ( item , 1 ); } } Console . WriteLine (); foreach ( var item in words ) { Console . Write ( \"{0}:{1} \" , item . Key , item . Value ); } Console . WriteLine (); var sorted = words . OrderBy ( x => - x . Value ); foreach ( var item in sorted ) { Console . Write ( \"{0}:{1} \" , item . Key , item . Value ); } } }","title":"C#"},{"location":"dictionary/#dart","text":"import 'dart:collection' ; main ( List < String > arguments ) { //count words var wordList = [ \"glass\" , \"table\" , \"chair\" , \"chair\" ]; var words = Map (); for ( var item in wordList ) { if ( words . containsKey ( item )) { words [ item ] += 1 ; } else { words [ item ] = 1 ; } } print ( ' $ words ' ); //sort values descending order var sorted = sortMap ( words ); print ( ' $ sorted ' ); } LinkedHashMap sortMap ( Map map ) { var mapk = map . keys . toList (); //sort keys according to values descending order mapk . sort (( k1 , k2 ) => map [ k2 ]. compareTo ( map [ k1 ])); var outMap = LinkedHashMap . fromIterable ( mapk , key: ( k ) => k , value: ( k ) => map [ k ]); return ( outMap ); }","title":"Dart"},{"location":"dictionary/#go","text":"package main import ( \"fmt\" \"sort\" ) func main () { //count words wordList := [] string { \"glass\" , \"table\" , \"chair\" , \"chair\" } words := make ( map [ string ] int ) for _ , item := range wordList { words [ item ] ++ } fmt . Printf ( \"\\n%v\" , words ) //sort by descending value fmt . Printf ( \"\\n%v\" , mapSort ( words )) } func mapSort ( mapIn map [ string ] int ) keyValList { //dict to slice mapS := keyValList {} for k , v := range mapIn { mapS = append ( mapS , keyVal { k , v }) } sort . Sort ( sort . Reverse ( mapS )) return mapS } type keyVal struct { key string val int } type keyValList [] keyVal func ( p keyValList ) Len () int { return len ( p ) } func ( p keyValList ) Less ( i , j int ) bool { return p [ i ]. val < p [ j ]. val } func ( p keyValList ) Swap ( i , j int ){ p [ i ], p [ j ] = p [ j ], p [ i ] }","title":"Go"},{"location":"dictionary/#nim","text":"import tables import algorithm as al # count words var wordList = @[ \"glass\" , \"table\" , \"chair\" , \"chair\" ] #var words = initTable[string, int]() var words = initOrderedTable [ string , int ] () for item in wordList : if words . hasKey ( item ): words [ item ] += 1 else : words . add ( item , 1 ) echo words # sort by descending value words . sort ( proc ( x , y : ( string , int )): int = x [ 1 ] - y [ 1 ] , order = al . SortOrder . Descending ) echo words","title":"Nim"},{"location":"dictionary/#python","text":"from typing import Dict , List , Tuple from operator import itemgetter # count words word_list : List [ str ] = [ \"glass\" , \"table\" , \"chair\" , \"chair\" ] words : Dict [ str , int ] = {} for item in word_list : try : words [ item ] += 1 except : words [ item ] = 1 print ( words ) # sort by descending value words_l : List [ Tuple [ str , int ]] = list ( words . items ()) words_l = sorted ( words_l , reverse = True , key = itemgetter ( 1 )) print ( words_l )","title":"Python"},{"location":"dictionary/#rust","text":"use std :: collections :: HashMap ; use std :: cmp :: Reverse ; fn main () { //count words let word_list = vec ! [ \"glass\" , \"table\" , \"chair\" , \"chair\" ]; let mut words : HashMap < String , usize > = HashMap :: new (); for item in word_list { let count = words . entry (( * item ). to_string ()). or_insert ( 0 ); * count += 1 ; } //get specific key value let value = words . get ( \"chair\" ). expect ( \"no key\" ); println ! ( \"{:?} {:?}\" , & words , value ); //sort by descending value let mut words_v : Vec < _ > = words . iter (). collect (); words_v . sort_by_key ( |& ( word , count ) | ( Reverse ( count ), word )); println ! ( \"{:?}\" , & words_v ); }","title":"Rust"},{"location":"exetime/","text":"C# using System ; using System.Collections.Generic ; using System.Diagnostics ; using System.Linq ; public class Program { public static void Main ( string [] args ) { var timer = Stopwatch . StartNew (); //START MEASURE var perfects = classifyPerfects ( 20001 ); timer . Stop (); //END MEASURE Console . WriteLine ( \"Perfects: {0}\" , perfects . Count ); foreach ( var item in perfects ) { Console . Write ( \"{0} \" , item ); } Console . WriteLine ( \"\\nElapsed: {0}ms\" , timer . ElapsedMilliseconds ); } public static List < int > classifyPerfects ( int num ) { var perfects = new List < int >(); for ( int n = 1 ; n < num ; n ++) { var divisors = findProperDivisor ( n ); var sum = divisors . Sum (); if ( sum == n ) { perfects . Add ( n ); } } return perfects ; } public static List < int > findProperDivisor ( int n ) { var divisors = new List < int >(); for ( int i = 1 ; i < ( n / 2 ) + 1 ; i ++) { if ( n % i == 0 ) { divisors . Add ( i ); } } return divisors ; } } Dart main ( List < String > arguments ) { var stopwatch = Stopwatch (); stopwatch . start (); //START MEASURE var perfects = classifyPerfect ( 20001 ); stopwatch . stop (); //END MEASURE var elapsed = stopwatch . elapsedMilliseconds ; print ( ' $ perfects ' ); print ( 'Elapsed: $ elapsed ms' ); } List < int > classifyPerfect ( int nnum ) { var perfects = List < int > (); for ( var n = 1 ; n < nnum ; n ++ ) { var divisors = findProperDivisor ( n ); var sum = 0 ; if ( divisors . isNotEmpty ) { sum = divisors . fold ( 0 , ( a , b ) => a + b ); } if ( sum == n ) { perfects . add ( n ); } } return perfects ; } List < int > findProperDivisor ( int n ) { var divisors = List < int > (); var endloop = n ~/ 2 + 1 ; for ( var i = 1 ; i < endloop ; i ++ ) { if ( n % i == 0 ) { divisors . add ( i ); } } return divisors ; } Go package main import ( \"fmt\" \"time\" ) func main () { start := time . Now () //START MEASURE perfects := classifyPerfect ( 20001 ) duration := time . Since ( start ) //END MEASURE fmt . Printf ( \"\\n%v\" , perfects ) fmt . Printf ( \"\\nElapsed: %v\" , duration ) } func classifyPerfect ( nnum int ) [] int { perfects := [] int {} for n := 1 ; n < nnum ; n ++ { divisors := findProperDivisor ( n ) sum := 0 for i := 0 ; i < len ( divisors ); i ++ { sum += divisors [ i ] } if sum == n { perfects = append ( perfects , n ) } } return perfects } func findProperDivisor ( n int ) [] int { divisors := [] int {} endloop := int ( n / 2 ) + 1 for i := 1 ; i < endloop ; i ++ { if n % i == 0 { divisors = append ( divisors , i ) } } return divisors } Nim # compile with: nim c -d:release --passC=\"-flto -ffast-math\" <filename> import times as ts import sequtils as sq proc findProperDivisors ( n : int ): seq [ int ] = var divisors : seq [ int ] let endloop : int = int ( n / 2 ) for i in 1 .. endloop : if ( n mod i ) == 0 : divisors . add ( i ) divisors proc classifyPerfects ( num : int ): seq [ int ] = var perfects : seq [ int ] for n in 1 .. num : let divisors = findProperDivisors ( n ) var sumd = 0 if divisors . len > 0 : sumd = divisors . foldl ( a + b ) if sumd == n : perfects . add ( n ) perfects var start = ts . getTime () # START MEASURE var perfects = classifyPerfects ( 20001 ) var endt = ts . getTime () # END MEASURE echo perfects . len echo perfects echo endt - start Python import time from typing import List def find_proper_divisors ( n : int ) -> List [ int ]: divisors : List [ int ] = [] for i in range ( 1 , int (( n / 2 ) + 1 )): if n % i == 0 : divisors += [ i ] return divisors def classify_perfects ( num : int ) -> List [ int ]: perfects : List [ int ] = [] for n in range ( 1 , num ): divisors = find_proper_divisors ( n ) sumd = sum ( divisors ) if sumd == n : perfects += [ n ] return perfects start_time : float = time . time () # START MEASURE perfects = classify_perfects ( 20001 ) end_time : float = time . time () # END MEASURE print ( f \"Perfects: {len(perfects)}\" ) for item in perfects : print ( f \"{item}\" ) print ( f \"Elapsed: {((end_time - start_time)*1000)} ms\" ) Rust use std :: time :: { Instant }; fn main () { let now = Instant :: now (); //START MEASURE let perfects = classify_perfect ( 20001 ); let new_now = Instant :: now (); //END MEASURE //Output println ! ( \"Perfects: {:?}\" , perfects . len ()); println ! ( \"{:?}\" , perfects ); println ! ( \"Elapsed: {:?}\" , new_now . duration_since ( now )); } fn classify_perfect ( num : i32 ) -> Vec < i32 > { let mut perfects = vec ! []; for n in 1 .. num { let divisors = find_proper_divisors ( n ); let sum : i32 = divisors . iter (). sum (); if sum == n { perfects . push ( n ); } } perfects } fn find_proper_divisors ( n : i32 ) -> Vec < i32 > { let mut divisors = vec ! []; for i in 1 ..(( n / 2 ) + 1 ) { if n % i == 0 { divisors . push ( i ); } } return divisors ; }","title":"Execution Time"},{"location":"exetime/#c35","text":"using System ; using System.Collections.Generic ; using System.Diagnostics ; using System.Linq ; public class Program { public static void Main ( string [] args ) { var timer = Stopwatch . StartNew (); //START MEASURE var perfects = classifyPerfects ( 20001 ); timer . Stop (); //END MEASURE Console . WriteLine ( \"Perfects: {0}\" , perfects . Count ); foreach ( var item in perfects ) { Console . Write ( \"{0} \" , item ); } Console . WriteLine ( \"\\nElapsed: {0}ms\" , timer . ElapsedMilliseconds ); } public static List < int > classifyPerfects ( int num ) { var perfects = new List < int >(); for ( int n = 1 ; n < num ; n ++) { var divisors = findProperDivisor ( n ); var sum = divisors . Sum (); if ( sum == n ) { perfects . Add ( n ); } } return perfects ; } public static List < int > findProperDivisor ( int n ) { var divisors = new List < int >(); for ( int i = 1 ; i < ( n / 2 ) + 1 ; i ++) { if ( n % i == 0 ) { divisors . Add ( i ); } } return divisors ; } }","title":"C#"},{"location":"exetime/#dart","text":"main ( List < String > arguments ) { var stopwatch = Stopwatch (); stopwatch . start (); //START MEASURE var perfects = classifyPerfect ( 20001 ); stopwatch . stop (); //END MEASURE var elapsed = stopwatch . elapsedMilliseconds ; print ( ' $ perfects ' ); print ( 'Elapsed: $ elapsed ms' ); } List < int > classifyPerfect ( int nnum ) { var perfects = List < int > (); for ( var n = 1 ; n < nnum ; n ++ ) { var divisors = findProperDivisor ( n ); var sum = 0 ; if ( divisors . isNotEmpty ) { sum = divisors . fold ( 0 , ( a , b ) => a + b ); } if ( sum == n ) { perfects . add ( n ); } } return perfects ; } List < int > findProperDivisor ( int n ) { var divisors = List < int > (); var endloop = n ~/ 2 + 1 ; for ( var i = 1 ; i < endloop ; i ++ ) { if ( n % i == 0 ) { divisors . add ( i ); } } return divisors ; }","title":"Dart"},{"location":"exetime/#go","text":"package main import ( \"fmt\" \"time\" ) func main () { start := time . Now () //START MEASURE perfects := classifyPerfect ( 20001 ) duration := time . Since ( start ) //END MEASURE fmt . Printf ( \"\\n%v\" , perfects ) fmt . Printf ( \"\\nElapsed: %v\" , duration ) } func classifyPerfect ( nnum int ) [] int { perfects := [] int {} for n := 1 ; n < nnum ; n ++ { divisors := findProperDivisor ( n ) sum := 0 for i := 0 ; i < len ( divisors ); i ++ { sum += divisors [ i ] } if sum == n { perfects = append ( perfects , n ) } } return perfects } func findProperDivisor ( n int ) [] int { divisors := [] int {} endloop := int ( n / 2 ) + 1 for i := 1 ; i < endloop ; i ++ { if n % i == 0 { divisors = append ( divisors , i ) } } return divisors }","title":"Go"},{"location":"exetime/#nim","text":"# compile with: nim c -d:release --passC=\"-flto -ffast-math\" <filename> import times as ts import sequtils as sq proc findProperDivisors ( n : int ): seq [ int ] = var divisors : seq [ int ] let endloop : int = int ( n / 2 ) for i in 1 .. endloop : if ( n mod i ) == 0 : divisors . add ( i ) divisors proc classifyPerfects ( num : int ): seq [ int ] = var perfects : seq [ int ] for n in 1 .. num : let divisors = findProperDivisors ( n ) var sumd = 0 if divisors . len > 0 : sumd = divisors . foldl ( a + b ) if sumd == n : perfects . add ( n ) perfects var start = ts . getTime () # START MEASURE var perfects = classifyPerfects ( 20001 ) var endt = ts . getTime () # END MEASURE echo perfects . len echo perfects echo endt - start","title":"Nim"},{"location":"exetime/#python","text":"import time from typing import List def find_proper_divisors ( n : int ) -> List [ int ]: divisors : List [ int ] = [] for i in range ( 1 , int (( n / 2 ) + 1 )): if n % i == 0 : divisors += [ i ] return divisors def classify_perfects ( num : int ) -> List [ int ]: perfects : List [ int ] = [] for n in range ( 1 , num ): divisors = find_proper_divisors ( n ) sumd = sum ( divisors ) if sumd == n : perfects += [ n ] return perfects start_time : float = time . time () # START MEASURE perfects = classify_perfects ( 20001 ) end_time : float = time . time () # END MEASURE print ( f \"Perfects: {len(perfects)}\" ) for item in perfects : print ( f \"{item}\" ) print ( f \"Elapsed: {((end_time - start_time)*1000)} ms\" )","title":"Python"},{"location":"exetime/#rust","text":"use std :: time :: { Instant }; fn main () { let now = Instant :: now (); //START MEASURE let perfects = classify_perfect ( 20001 ); let new_now = Instant :: now (); //END MEASURE //Output println ! ( \"Perfects: {:?}\" , perfects . len ()); println ! ( \"{:?}\" , perfects ); println ! ( \"Elapsed: {:?}\" , new_now . duration_since ( now )); } fn classify_perfect ( num : i32 ) -> Vec < i32 > { let mut perfects = vec ! []; for n in 1 .. num { let divisors = find_proper_divisors ( n ); let sum : i32 = divisors . iter (). sum (); if sum == n { perfects . push ( n ); } } perfects } fn find_proper_divisors ( n : i32 ) -> Vec < i32 > { let mut divisors = vec ! []; for i in 1 ..(( n / 2 ) + 1 ) { if n % i == 0 { divisors . push ( i ); } } return divisors ; }","title":"Rust"},{"location":"hello/","text":"Rust cargo new hello -- bin cd hello cargo run C# dotnet new console -o hello cd hello dotnet run Dart pub global activate stagehand mkdir hello cd hello stagehand console-full pub get dart bin/main.dart","title":"Hello with CLI"},{"location":"hello/#rust","text":"cargo new hello -- bin cd hello cargo run","title":"Rust"},{"location":"hello/#c35","text":"dotnet new console -o hello cd hello dotnet run","title":"C#"},{"location":"hello/#dart","text":"pub global activate stagehand mkdir hello cd hello stagehand console-full pub get dart bin/main.dart","title":"Dart"},{"location":"playglinks/","text":"C# .NET Fiddle Dart DatPad Go Go Playground Nim Nim Playground Python Tio Python3 Rust Rust Playground","title":"Playground Links"},{"location":"playglinks/#c35","text":".NET Fiddle","title":"C#"},{"location":"playglinks/#dart","text":"DatPad","title":"Dart"},{"location":"playglinks/#go","text":"Go Playground","title":"Go"},{"location":"playglinks/#nim","text":"Nim Playground","title":"Nim"},{"location":"playglinks/#python","text":"Tio Python3","title":"Python"},{"location":"playglinks/#rust","text":"Rust Playground","title":"Rust"},{"location":"syscom/","text":"C# using System ; using System.Diagnostics ; public class Program { public static void Main ( string [] args ) { var psi = new ProcessStartInfo (); var process = new Process (); //(\"cargo\", \"version\"); psi . Arguments = \"version\" ; psi . FileName = \"cargo\" ; psi . RedirectStandardOutput = true ; process . StartInfo = psi ; process . Start (); while (! process . StandardOutput . EndOfStream ) { var line = process . StandardOutput . ReadLine (); Console . WriteLine ( line ); } } } Dart import \"dart:io\" ; main ( List < String > arguments ) { Process . run ( 'cargo' , [ 'version' ]). then (( ProcessResult result ) { print ( result . stdout ); }); } Go package main import ( \"fmt\" \"os/exec\" ) func main () { out , _ := exec . Command ( \"go\" , \"version\" ). Output () output := string ( out ) fmt . Printf ( \"\\n%s\" , output ) } Python import subprocess outp = subprocess . run ([ \"cargo\" , \"version\" ], capture_output = True , text = True ) print ( outp . stdout ) Rust use std :: process :: Command ; fn main () { let output = Command :: new ( \"cargo\" ) . args ( & [ \"version\" ]) . output () . expect ( \"failed to execute process\" ); println ! ( \"stdout: {}\" , String :: from_utf8_lossy ( & output . stdout )); }","title":"System command"},{"location":"syscom/#c35","text":"using System ; using System.Diagnostics ; public class Program { public static void Main ( string [] args ) { var psi = new ProcessStartInfo (); var process = new Process (); //(\"cargo\", \"version\"); psi . Arguments = \"version\" ; psi . FileName = \"cargo\" ; psi . RedirectStandardOutput = true ; process . StartInfo = psi ; process . Start (); while (! process . StandardOutput . EndOfStream ) { var line = process . StandardOutput . ReadLine (); Console . WriteLine ( line ); } } }","title":"C#"},{"location":"syscom/#dart","text":"import \"dart:io\" ; main ( List < String > arguments ) { Process . run ( 'cargo' , [ 'version' ]). then (( ProcessResult result ) { print ( result . stdout ); }); }","title":"Dart"},{"location":"syscom/#go","text":"package main import ( \"fmt\" \"os/exec\" ) func main () { out , _ := exec . Command ( \"go\" , \"version\" ). Output () output := string ( out ) fmt . Printf ( \"\\n%s\" , output ) }","title":"Go"},{"location":"syscom/#python","text":"import subprocess outp = subprocess . run ([ \"cargo\" , \"version\" ], capture_output = True , text = True ) print ( outp . stdout )","title":"Python"},{"location":"syscom/#rust","text":"use std :: process :: Command ; fn main () { let output = Command :: new ( \"cargo\" ) . args ( & [ \"version\" ]) . output () . expect ( \"failed to execute process\" ); println ! ( \"stdout: {}\" , String :: from_utf8_lossy ( & output . stdout )); }","title":"Rust"}]}