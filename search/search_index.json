{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Runnable Snippets Unpretending snippets tested on 64-bit Windows and Playgrounds (when possible). Languages: C# 8.0 Dart 2.5.0 Go 1.13 Nim 1.0 Python 3.7.1 Rust 1.38.0 Typescript 3.5.3 Still updating.","title":"Home"},{"location":"#runnable-snippets","text":"Unpretending snippets tested on 64-bit Windows and Playgrounds (when possible). Languages: C# 8.0 Dart 2.5.0 Go 1.13 Nim 1.0 Python 3.7.1 Rust 1.38.0 Typescript 3.5.3 Still updating.","title":"Runnable Snippets"},{"location":"Dict/","text":"Dictionary C# using System ; using System.Collections.Generic ; using System.Linq ; public class Program { public static void Main ( string [] args ) { //count words var wordList = new List < string > { \"glass\" , \"table\" , \"chair\" , \"chair\" }; var words = new Dictionary < string , int >(); foreach ( var item in wordList ) { if ( words . ContainsKey ( item )) { words [ item ] = ( int ) words [ item ] + 1 ; } else { words . Add ( item , 1 ); } } Console . WriteLine (); foreach ( var item in words ) { Console . Write ( \"{0}:{1} \" , item . Key , item . Value ); } Console . WriteLine (); var sorted = words . OrderBy ( x => - x . Value ); foreach ( var item in sorted ) { Console . Write ( \"{0}:{1} \" , item . Key , item . Value ); } } } Dart import 'dart:collection' ; main ( List < String > arguments ) { //count words var wordList = [ \"glass\" , \"table\" , \"chair\" , \"chair\" ]; var words = Map (); for ( var item in wordList ) { if ( words . containsKey ( item )) { words [ item ] += 1 ; } else { words [ item ] = 1 ; } } print ( ' $ words ' ); //sort values descending order var sorted = sortMap ( words ); print ( ' $ sorted ' ); } LinkedHashMap sortMap ( Map map ) { var mapk = map . keys . toList (); //sort keys according to values descending order mapk . sort (( k1 , k2 ) => map [ k2 ]. compareTo ( map [ k1 ])); var outMap = LinkedHashMap . fromIterable ( mapk , key: ( k ) => k , value: ( k ) => map [ k ]); return ( outMap ); } Go package main import ( \"fmt\" \"sort\" ) func main () { //count words wordList := [] string { \"glass\" , \"table\" , \"chair\" , \"chair\" } words := make ( map [ string ] int ) for _ , item := range wordList { words [ item ] ++ } fmt . Printf ( \"\\n%v\" , words ) //sort by descending value fmt . Printf ( \"\\n%v\" , mapSort ( words )) } func mapSort ( mapIn map [ string ] int ) keyValList { //dict to slice mapS := keyValList {} for k , v := range mapIn { mapS = append ( mapS , keyVal { k , v }) } sort . Sort ( sort . Reverse ( mapS )) return mapS } type keyVal struct { key string val int } type keyValList [] keyVal func ( p keyValList ) Len () int { return len ( p ) } func ( p keyValList ) Less ( i , j int ) bool { return p [ i ]. val < p [ j ]. val } func ( p keyValList ) Swap ( i , j int ){ p [ i ], p [ j ] = p [ j ], p [ i ] } Nim import tables import algorithm as al # count words var wordList = @[ \"glass\" , \"table\" , \"chair\" , \"chair\" ] var words = initOrderedTable [ string , int ] () for item in wordList : if words . hasKey ( item ): words [ item ] += 1 else : words . add ( item , 1 ) echo words # sort by descending value words . sort ( proc ( x , y : ( string , int )): int = x [ 1 ] - y [ 1 ] , order = al . SortOrder . Descending ) echo words Python from typing import Dict , List , Tuple from operator import itemgetter # count words word_list : List [ str ] = [ \"glass\" , \"table\" , \"chair\" , \"chair\" ] words : Dict [ str , int ] = {} for item in word_list : try : words [ item ] += 1 except : words [ item ] = 1 print ( words ) # sort by descending value words_l : List [ Tuple [ str , int ]] = list ( words . items ()) words_l = sorted ( words_l , reverse = True , key = itemgetter ( 1 )) print ( words_l ) Rust use std :: collections :: HashMap ; use std :: cmp :: Reverse ; fn main () { //count words let word_list = vec ! [ \"glass\" , \"table\" , \"chair\" , \"chair\" ]; let mut words : HashMap < String , usize > = HashMap :: new (); for item in word_list { let count = words . entry (( * item ). to_string ()). or_insert ( 0 ); * count += 1 ; } //get specific key value let value = words . get ( \"chair\" ). expect ( \"no key\" ); println ! ( \"{:?} {:?}\" , & words , value ); //sort by descending value let mut words_v : Vec < _ > = words . iter (). collect (); words_v . sort_by_key ( |& ( word , count ) | ( Reverse ( count ), word )); println ! ( \"{:?}\" , & words_v ); }","title":"Dictionary"},{"location":"Dict/#dictionary","text":"","title":"Dictionary"},{"location":"Dict/#c35","text":"using System ; using System.Collections.Generic ; using System.Linq ; public class Program { public static void Main ( string [] args ) { //count words var wordList = new List < string > { \"glass\" , \"table\" , \"chair\" , \"chair\" }; var words = new Dictionary < string , int >(); foreach ( var item in wordList ) { if ( words . ContainsKey ( item )) { words [ item ] = ( int ) words [ item ] + 1 ; } else { words . Add ( item , 1 ); } } Console . WriteLine (); foreach ( var item in words ) { Console . Write ( \"{0}:{1} \" , item . Key , item . Value ); } Console . WriteLine (); var sorted = words . OrderBy ( x => - x . Value ); foreach ( var item in sorted ) { Console . Write ( \"{0}:{1} \" , item . Key , item . Value ); } } }","title":"C#"},{"location":"Dict/#dart","text":"import 'dart:collection' ; main ( List < String > arguments ) { //count words var wordList = [ \"glass\" , \"table\" , \"chair\" , \"chair\" ]; var words = Map (); for ( var item in wordList ) { if ( words . containsKey ( item )) { words [ item ] += 1 ; } else { words [ item ] = 1 ; } } print ( ' $ words ' ); //sort values descending order var sorted = sortMap ( words ); print ( ' $ sorted ' ); } LinkedHashMap sortMap ( Map map ) { var mapk = map . keys . toList (); //sort keys according to values descending order mapk . sort (( k1 , k2 ) => map [ k2 ]. compareTo ( map [ k1 ])); var outMap = LinkedHashMap . fromIterable ( mapk , key: ( k ) => k , value: ( k ) => map [ k ]); return ( outMap ); }","title":"Dart"},{"location":"Dict/#go","text":"package main import ( \"fmt\" \"sort\" ) func main () { //count words wordList := [] string { \"glass\" , \"table\" , \"chair\" , \"chair\" } words := make ( map [ string ] int ) for _ , item := range wordList { words [ item ] ++ } fmt . Printf ( \"\\n%v\" , words ) //sort by descending value fmt . Printf ( \"\\n%v\" , mapSort ( words )) } func mapSort ( mapIn map [ string ] int ) keyValList { //dict to slice mapS := keyValList {} for k , v := range mapIn { mapS = append ( mapS , keyVal { k , v }) } sort . Sort ( sort . Reverse ( mapS )) return mapS } type keyVal struct { key string val int } type keyValList [] keyVal func ( p keyValList ) Len () int { return len ( p ) } func ( p keyValList ) Less ( i , j int ) bool { return p [ i ]. val < p [ j ]. val } func ( p keyValList ) Swap ( i , j int ){ p [ i ], p [ j ] = p [ j ], p [ i ] }","title":"Go"},{"location":"Dict/#nim","text":"import tables import algorithm as al # count words var wordList = @[ \"glass\" , \"table\" , \"chair\" , \"chair\" ] var words = initOrderedTable [ string , int ] () for item in wordList : if words . hasKey ( item ): words [ item ] += 1 else : words . add ( item , 1 ) echo words # sort by descending value words . sort ( proc ( x , y : ( string , int )): int = x [ 1 ] - y [ 1 ] , order = al . SortOrder . Descending ) echo words","title":"Nim"},{"location":"Dict/#python","text":"from typing import Dict , List , Tuple from operator import itemgetter # count words word_list : List [ str ] = [ \"glass\" , \"table\" , \"chair\" , \"chair\" ] words : Dict [ str , int ] = {} for item in word_list : try : words [ item ] += 1 except : words [ item ] = 1 print ( words ) # sort by descending value words_l : List [ Tuple [ str , int ]] = list ( words . items ()) words_l = sorted ( words_l , reverse = True , key = itemgetter ( 1 )) print ( words_l )","title":"Python"},{"location":"Dict/#rust","text":"use std :: collections :: HashMap ; use std :: cmp :: Reverse ; fn main () { //count words let word_list = vec ! [ \"glass\" , \"table\" , \"chair\" , \"chair\" ]; let mut words : HashMap < String , usize > = HashMap :: new (); for item in word_list { let count = words . entry (( * item ). to_string ()). or_insert ( 0 ); * count += 1 ; } //get specific key value let value = words . get ( \"chair\" ). expect ( \"no key\" ); println ! ( \"{:?} {:?}\" , & words , value ); //sort by descending value let mut words_v : Vec < _ > = words . iter (). collect (); words_v . sort_by_key ( |& ( word , count ) | ( Reverse ( count ), word )); println ! ( \"{:?}\" , & words_v ); }","title":"Rust"},{"location":"Execution time/","text":"Execution time C# // exe -> dotnet publish -c Release -r win10-x64 --self-contained true using System ; using System.Collections.Generic ; using System.Diagnostics ; using System.Linq ; public class Program { public static void Main ( string [] args ) { var timer = Stopwatch . StartNew (); //START MEASURE var perfects = classifyPerfects ( 20001 ); timer . Stop (); //END MEASURE foreach ( var item in perfects ) { Console . Write ( \"{0} \" , item ); } Console . WriteLine ( \"\\nElapsed: {0}ms\" , timer . ElapsedMilliseconds ); } public static List < int > classifyPerfects ( int num ) { var perfects = new List < int >(); for ( int n = 1 ; n < num ; n ++) { var divisors = findProperDivisor ( n ); // list_sum var sum = divisors . Sum (); if ( sum == n ) { perfects . Add ( n ); } } return perfects ; } public static List < int > findProperDivisor ( int n ) { var divisors = new List < int >(); for ( int i = 1 ; i < ( n / 2 ) + 1 ; i ++) { if ( n % i == 0 ) { divisors . Add ( i ); } } return divisors ; } } Dart main ( List < String > arguments ) { var stopwatch = Stopwatch (); stopwatch . start (); //START MEASURE var perfects = classifyPerfect ( 20001 ); stopwatch . stop (); //END MEASURE var elapsed = stopwatch . elapsedMilliseconds ; print ( ' $ perfects ' ); print ( 'Elapsed: $ elapsed ms' ); } List < int > classifyPerfect ( int nnum ) { var perfects = List < int > (); for ( var n = 1 ; n < nnum ; n ++ ) { var divisors = findProperDivisor ( n ); var sum = 0 ; if ( divisors . isNotEmpty ) { sum = divisors . fold ( 0 , ( a , b ) => a + b ); } if ( sum == n ) { perfects . add ( n ); } } return perfects ; } List < int > findProperDivisor ( int n ) { var divisors = List < int > (); var endloop = n ~/ 2 + 1 ; for ( var i = 1 ; i < endloop ; i ++ ) { if ( n % i == 0 ) { divisors . add ( i ); } } return divisors ; } Go package main import ( \"fmt\" \"time\" ) func main () { start := time . Now () //START MEASURE perfects := classifyPerfect ( 20001 ) duration := time . Since ( start ) //END MEASURE fmt . Printf ( \"\\n%v\" , perfects ) fmt . Printf ( \"\\nElapsed: %v\" , duration ) } func classifyPerfect ( nnum int ) [] int { perfects := [] int {} for n := 1 ; n < nnum ; n ++ { divisors := findProperDivisor ( n ) sum := 0 for i := 0 ; i < len ( divisors ); i ++ { sum += divisors [ i ] } if sum == n { perfects = append ( perfects , n ) } } return perfects } func findProperDivisor ( n int ) [] int { divisors := [] int {} endloop := int ( n / 2 ) + 1 for i := 1 ; i < endloop ; i ++ { if n % i == 0 { divisors = append ( divisors , i ) } } return divisors } Nim # exe -> nim c -d:release <filename> import times as ts import sequtils as sq proc findProperDivisors ( n : int32 ): seq [ int32 ] = var divisors : seq [ int32 ] let endloop : int32 = int32 ( n / 2 ) for i in 1 .. endloop : if ( n mod i ) == 0 : divisors . add ( i ) divisors proc classifyPerfects ( num : int32 ): seq [ int32 ] = var perfects : seq [ int32 ] for n in 1 .. num : let divisors = findProperDivisors ( n ) var sumd = 0 if divisors . len > 0 : sumd = divisors . foldl ( a + b ) if sumd == n : perfects . add ( n ) perfects var start = ts . getTime () # START MEASURE var perfects = classifyPerfects ( 20001 ) var endt = ts . getTime () # END MEASURE echo perfects echo endt - start Python import time from typing import List def find_proper_divisors ( n : int ) -> List [ int ]: divisors : List [ int ] = [] for i in range ( 1 , int (( n / 2 ) + 1 )): if n % i == 0 : divisors += [ i ] return divisors def classify_perfects ( num : int ) -> List [ int ]: perfects : List [ int ] = [] for n in range ( 1 , num ): divisors = find_proper_divisors ( n ) # list_sum sumd = sum ( divisors ) if sumd == n : perfects += [ n ] return perfects start_time : float = time . time () # START MEASURE perfects = classify_perfects ( 20001 ) end_time : float = time . time () # END MEASURE for item in perfects : print ( f \"{item}\" ) print ( f \"Elapsed: {((end_time - start_time)*1000)} ms\" ) Rust //exe -> cargo build --release use std :: time :: { Instant }; fn main () { let now = Instant :: now (); //START MEASURE let perfects = classify_perfect ( 20001 ); let new_now = Instant :: now (); //END MEASURE println ! ( \"{:?}\" , perfects ); println ! ( \"Elapsed: {:?}\" , new_now . duration_since ( now )); } fn classify_perfect ( num : i32 ) -> Vec < i32 > { let mut perfects = vec ! []; for n in 1 .. num { let divisors = find_proper_divisors ( n ); // list_sum let sum : i32 = divisors . iter (). sum (); if sum == n { perfects . push ( n ); } } perfects } fn find_proper_divisors ( n : i32 ) -> Vec < i32 > { let mut divisors = vec ! []; for i in 1 ..(( n / 2 ) + 1 ) { if n % i == 0 { divisors . push ( i ); } } return divisors ; } TypeScript console . time ( \"Elapsed\" ); //START MEASURE let perfects = classifyPerfect ( 20001 ); console . timeEnd ( \"Elapsed\" ); //END MEASURE console . log ( ` ${ perfects } ` ); function classifyPerfect ( nnum : number ) { let perfects = []; for ( var n = 1 ; n < nnum ; n ++ ) { let divisors = findProperDivisor ( n ); var sum = 0 ; if ( divisors . length > 0 ) { divisors . forEach ( x => sum += x ); } if ( sum == n ) { perfects . push ( n ); } } return perfects ; } function findProperDivisor ( n : number ) { let divisors = []; let endloop = Math . floor ( n / 2 ) + 1 ; for ( let i = 1 ; i < endloop ; i ++ ) { if ( n % i == 0 ) { divisors . push ( i ); } } return divisors ; }","title":"Execution time"},{"location":"Execution time/#execution-time","text":"","title":"Execution time"},{"location":"Execution time/#c35","text":"// exe -> dotnet publish -c Release -r win10-x64 --self-contained true using System ; using System.Collections.Generic ; using System.Diagnostics ; using System.Linq ; public class Program { public static void Main ( string [] args ) { var timer = Stopwatch . StartNew (); //START MEASURE var perfects = classifyPerfects ( 20001 ); timer . Stop (); //END MEASURE foreach ( var item in perfects ) { Console . Write ( \"{0} \" , item ); } Console . WriteLine ( \"\\nElapsed: {0}ms\" , timer . ElapsedMilliseconds ); } public static List < int > classifyPerfects ( int num ) { var perfects = new List < int >(); for ( int n = 1 ; n < num ; n ++) { var divisors = findProperDivisor ( n ); // list_sum var sum = divisors . Sum (); if ( sum == n ) { perfects . Add ( n ); } } return perfects ; } public static List < int > findProperDivisor ( int n ) { var divisors = new List < int >(); for ( int i = 1 ; i < ( n / 2 ) + 1 ; i ++) { if ( n % i == 0 ) { divisors . Add ( i ); } } return divisors ; } }","title":"C#"},{"location":"Execution time/#dart","text":"main ( List < String > arguments ) { var stopwatch = Stopwatch (); stopwatch . start (); //START MEASURE var perfects = classifyPerfect ( 20001 ); stopwatch . stop (); //END MEASURE var elapsed = stopwatch . elapsedMilliseconds ; print ( ' $ perfects ' ); print ( 'Elapsed: $ elapsed ms' ); } List < int > classifyPerfect ( int nnum ) { var perfects = List < int > (); for ( var n = 1 ; n < nnum ; n ++ ) { var divisors = findProperDivisor ( n ); var sum = 0 ; if ( divisors . isNotEmpty ) { sum = divisors . fold ( 0 , ( a , b ) => a + b ); } if ( sum == n ) { perfects . add ( n ); } } return perfects ; } List < int > findProperDivisor ( int n ) { var divisors = List < int > (); var endloop = n ~/ 2 + 1 ; for ( var i = 1 ; i < endloop ; i ++ ) { if ( n % i == 0 ) { divisors . add ( i ); } } return divisors ; }","title":"Dart"},{"location":"Execution time/#go","text":"package main import ( \"fmt\" \"time\" ) func main () { start := time . Now () //START MEASURE perfects := classifyPerfect ( 20001 ) duration := time . Since ( start ) //END MEASURE fmt . Printf ( \"\\n%v\" , perfects ) fmt . Printf ( \"\\nElapsed: %v\" , duration ) } func classifyPerfect ( nnum int ) [] int { perfects := [] int {} for n := 1 ; n < nnum ; n ++ { divisors := findProperDivisor ( n ) sum := 0 for i := 0 ; i < len ( divisors ); i ++ { sum += divisors [ i ] } if sum == n { perfects = append ( perfects , n ) } } return perfects } func findProperDivisor ( n int ) [] int { divisors := [] int {} endloop := int ( n / 2 ) + 1 for i := 1 ; i < endloop ; i ++ { if n % i == 0 { divisors = append ( divisors , i ) } } return divisors }","title":"Go"},{"location":"Execution time/#nim","text":"# exe -> nim c -d:release <filename> import times as ts import sequtils as sq proc findProperDivisors ( n : int32 ): seq [ int32 ] = var divisors : seq [ int32 ] let endloop : int32 = int32 ( n / 2 ) for i in 1 .. endloop : if ( n mod i ) == 0 : divisors . add ( i ) divisors proc classifyPerfects ( num : int32 ): seq [ int32 ] = var perfects : seq [ int32 ] for n in 1 .. num : let divisors = findProperDivisors ( n ) var sumd = 0 if divisors . len > 0 : sumd = divisors . foldl ( a + b ) if sumd == n : perfects . add ( n ) perfects var start = ts . getTime () # START MEASURE var perfects = classifyPerfects ( 20001 ) var endt = ts . getTime () # END MEASURE echo perfects echo endt - start","title":"Nim"},{"location":"Execution time/#python","text":"import time from typing import List def find_proper_divisors ( n : int ) -> List [ int ]: divisors : List [ int ] = [] for i in range ( 1 , int (( n / 2 ) + 1 )): if n % i == 0 : divisors += [ i ] return divisors def classify_perfects ( num : int ) -> List [ int ]: perfects : List [ int ] = [] for n in range ( 1 , num ): divisors = find_proper_divisors ( n ) # list_sum sumd = sum ( divisors ) if sumd == n : perfects += [ n ] return perfects start_time : float = time . time () # START MEASURE perfects = classify_perfects ( 20001 ) end_time : float = time . time () # END MEASURE for item in perfects : print ( f \"{item}\" ) print ( f \"Elapsed: {((end_time - start_time)*1000)} ms\" )","title":"Python"},{"location":"Execution time/#rust","text":"//exe -> cargo build --release use std :: time :: { Instant }; fn main () { let now = Instant :: now (); //START MEASURE let perfects = classify_perfect ( 20001 ); let new_now = Instant :: now (); //END MEASURE println ! ( \"{:?}\" , perfects ); println ! ( \"Elapsed: {:?}\" , new_now . duration_since ( now )); } fn classify_perfect ( num : i32 ) -> Vec < i32 > { let mut perfects = vec ! []; for n in 1 .. num { let divisors = find_proper_divisors ( n ); // list_sum let sum : i32 = divisors . iter (). sum (); if sum == n { perfects . push ( n ); } } perfects } fn find_proper_divisors ( n : i32 ) -> Vec < i32 > { let mut divisors = vec ! []; for i in 1 ..(( n / 2 ) + 1 ) { if n % i == 0 { divisors . push ( i ); } } return divisors ; }","title":"Rust"},{"location":"Execution time/#typescript","text":"console . time ( \"Elapsed\" ); //START MEASURE let perfects = classifyPerfect ( 20001 ); console . timeEnd ( \"Elapsed\" ); //END MEASURE console . log ( ` ${ perfects } ` ); function classifyPerfect ( nnum : number ) { let perfects = []; for ( var n = 1 ; n < nnum ; n ++ ) { let divisors = findProperDivisor ( n ); var sum = 0 ; if ( divisors . length > 0 ) { divisors . forEach ( x => sum += x ); } if ( sum == n ) { perfects . push ( n ); } } return perfects ; } function findProperDivisor ( n : number ) { let divisors = []; let endloop = Math . floor ( n / 2 ) + 1 ; for ( let i = 1 ; i < endloop ; i ++ ) { if ( n % i == 0 ) { divisors . push ( i ); } } return divisors ; }","title":"TypeScript"},{"location":"List/","text":"List C# using System ; using System.Collections.Generic ; using System.Linq ; public class Program { public static void Main ( string [] args ) { //new empty list var lst1 = new List < string >(); //new initialized list var lst2 = new List < string > { \"str20\" , \"str21\" }; //append element lst1 . Add ( \"str10\" ); //append list lst1 . AddRange ( lst2 ); //add head element lst1 . Insert ( 0 , \"str00\" ); //reverse lst1 . Reverse (); //access elem with out of bounds check var elem = lst1 . ElementAtOrDefault ( 100 ); Console . Write ( \"Elem *{0}* \" , elem ); //sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] //list length var lst3 = lst1 . GetRange ( 1 , lst1 . Count - 1 ); Console . WriteLine (); foreach ( var item in lst3 ) { Console . Write ( \"{0} \" , item ); } //map and filter var lst4 = lst1 . Select (( x ) => x . ToUpper ()); var lst5 = lst4 . Where (( x ) => x != \"STR00\" ); Console . WriteLine (); foreach ( var item in lst5 ) { Console . Write ( \"{0} \" , item ); } } } Dart main ( List < String > arguments ) { // new empty list var lst1 = List < String > (); //new initialized list var lst2 = [ \"str20\" , \"str21\" ]; // append element lst1 . add ( \"str10\" ); // append list lst1 = lst1 + lst2 ; // add head element lst1 = [ \"str00\" ] + lst1 ; //reverse lst1 = lst1 . reversed . toList (); //trap out of bounds access var elem = getElemAt ( lst1 , 100 ); print ( 'Elem * $ elem *' ); // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] // list length var lst3 = lst1 . sublist ( 1 , lst1 . length ); print ( ' $ lst3 ' ); // map and filter var lst4 = lst3 . map (( x ) => x . toUpperCase ()); var lst5 = lst4 . where (( x ) => x != \"STR00\" ); print ( ' $ lst5 ' ); } String getElemAt ( List < String > lst , int index ) { String elem ; try { elem = lst [ index ]; } catch ( e ) { elem = \"\" ; } return elem ; } Go package main import ( \"fmt\" \"sort\" \"strings\" ) func main () { //new empty list lst1 := stringList {} //new initialized list lst2 := stringList { \"str20\" , \"str21\" } //append element lst1 = append ( lst1 , \"str10\" ) //append list lst1 = append ( lst1 , lst2 ... ) //add head element lst1 = append ([] string { \"str00\" }, lst1 ... ) //reverse sort . Sort ( sort . Reverse ( lst1 )) //trap out of bounds access elem := getElemAt ( lst1 , 100 ) fmt . Printf ( \"\\nElem *%v*\" , elem ) //sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] //list length lst3 := lst1 [ 1 : len ( lst1 )] fmt . Printf ( \"\\n%v\" , lst3 ) //map and filter lst4 := stringList {} for _ , elem := range lst1 { lst4 = append ( lst4 , strings . ToUpper ( elem )) } lst5 := stringList {} for _ , elem := range lst4 { if elem != \"STR00\" { lst5 = append ( lst5 , elem ) } } fmt . Printf ( \"\\n%v\" , lst5 ) } type stringList [] string func ( p stringList ) Len () int { return len ( p ) } func ( p stringList ) Less ( i , j int ) bool { return p [ i ] < p [ j ] } func ( p stringList ) Swap ( i , j int ) { p [ i ], p [ j ] = p [ j ], p [ i ] } func getElemAt ( lst stringList , index int ) string { defer recoverList () elem := lst [ index ] return elem } func recoverList () { recover () } Nim import sequtils as sq import algorithm as al import strutils as st import strformat proc getElemAt ( lst : seq [ string ] , index : int ): string = try : return lst [ index ] except : return \"\" # new empty list var lst1 : seq [ string ] = @[] # new initialized list var lst2 = @[ \"str20\" , \"str21\" ] # append element lst1 . add ( \"str10\" ) #append list lst1 = sq . concat ( lst1 , lst2 ) # add head element lst1 = sq . concat ( @[ \"str00\" ] , lst1 ) # reverse lst1 = al . reversed ( lst1 ) # trap out of bounds access let elem = getElemAt ( lst1 , 100 ) echo & \"Elem *{elem}*\" # sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] # list length var lst3 = lst1 [ 1 .. len ( lst1 ) - 1 ] echo lst3 # map and filter var lst4 = map ( lst3 , proc ( x : string ): string = st . toUpper ( x )) var lst5 = filter ( lst4 , proc ( x : string ): bool = x != \"STR00\" ) echo lst5 Python from typing import List # new empty list lst1 : List [ str ] = [] # new initialized list lst2 : List [ str ] = [ \"str20\" , \"str21\" ] # append element lst1 = lst1 + [ \"str10\" ] def elem_at_index ( lst : List [ str ], index : int ) -> str : try : return lst [ index ] except : return \"\" # append list lst1 = lst1 + lst2 # add head element lst1 = [ \"str00\" ] + lst1 # reverse lst1 . reverse () # trap outof bounds access elem = elem_at_index ( lst1 , 100 ) print ( f \"Elem *{elem}*\" ) # sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] # list length lst3 : List [ str ] = lst1 [ 1 : len ( lst1 )] print ( lst3 ) # map and filter lst4 : List [ str ] = [ elem for elem in map ( lambda x : x . upper (), lst1 )] lst5 = [ elem for elem in filter ( lambda x : x != \"STR00\" , lst4 )] print ( lst5 ) Rust fn main () { // new empty list let mut lst1 : Vec <& str > = vec ! []; //new initialized list let lst2 = vec ! [ \"str20\" , \"str21\" ]; // append element lst1 . push ( \"str10\" ); // append list lst1 . extend ( lst2 ); // add head element lst1 . insert ( 0 , \"str00\" ); //reverse lst1 . reverse (); //access elem with out of bounds check let elem = match lst1 . get ( 100 ) { None => \"not found\" , Some ( x ) => x }; println ! ( \"Elem {}\" , elem ); // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] // list length let lst3 : Vec <& str > = lst1 [ 1 .. lst1 . len ()]. to_vec (); println ! ( \"{:?}\" , & lst3 ); // map and filter let lst4 : Vec < _ > = lst3 . into_iter (). map ( | x | x . to_uppercase ()). collect (); let lst5 : Vec < _ > = lst4 . into_iter (). filter ( | x | * x != \"STR00\" ). collect (); println ! ( \"{:?}\" , & lst5 ); } TypeScript // new empty list var lst1 = []; //new initialized list var lst2 = [ \"str20\" , \"str21\" ]; // append element lst1 . push ( \"str10\" ); // append list lst1 = lst1 . concat ( lst2 ); // add head element lst1 = [ \"str00\" ]. concat ( lst1 ); //reverse lst1 = lst1 . reverse (); // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] // list length var lst3 = lst1 . slice ( 1 , lst1 . length ); console . log ( ` ${ lst3 } ` ); // map and filter var lst4 = lst3 . map (( x ) => x . toUpperCase ()); var lst5 = lst4 . filter (( x ) => x != \"STR00\" ); console . log ( ` ${ lst5 } ` );","title":"List"},{"location":"List/#list","text":"","title":"List"},{"location":"List/#c35","text":"using System ; using System.Collections.Generic ; using System.Linq ; public class Program { public static void Main ( string [] args ) { //new empty list var lst1 = new List < string >(); //new initialized list var lst2 = new List < string > { \"str20\" , \"str21\" }; //append element lst1 . Add ( \"str10\" ); //append list lst1 . AddRange ( lst2 ); //add head element lst1 . Insert ( 0 , \"str00\" ); //reverse lst1 . Reverse (); //access elem with out of bounds check var elem = lst1 . ElementAtOrDefault ( 100 ); Console . Write ( \"Elem *{0}* \" , elem ); //sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] //list length var lst3 = lst1 . GetRange ( 1 , lst1 . Count - 1 ); Console . WriteLine (); foreach ( var item in lst3 ) { Console . Write ( \"{0} \" , item ); } //map and filter var lst4 = lst1 . Select (( x ) => x . ToUpper ()); var lst5 = lst4 . Where (( x ) => x != \"STR00\" ); Console . WriteLine (); foreach ( var item in lst5 ) { Console . Write ( \"{0} \" , item ); } } }","title":"C#"},{"location":"List/#dart","text":"main ( List < String > arguments ) { // new empty list var lst1 = List < String > (); //new initialized list var lst2 = [ \"str20\" , \"str21\" ]; // append element lst1 . add ( \"str10\" ); // append list lst1 = lst1 + lst2 ; // add head element lst1 = [ \"str00\" ] + lst1 ; //reverse lst1 = lst1 . reversed . toList (); //trap out of bounds access var elem = getElemAt ( lst1 , 100 ); print ( 'Elem * $ elem *' ); // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] // list length var lst3 = lst1 . sublist ( 1 , lst1 . length ); print ( ' $ lst3 ' ); // map and filter var lst4 = lst3 . map (( x ) => x . toUpperCase ()); var lst5 = lst4 . where (( x ) => x != \"STR00\" ); print ( ' $ lst5 ' ); } String getElemAt ( List < String > lst , int index ) { String elem ; try { elem = lst [ index ]; } catch ( e ) { elem = \"\" ; } return elem ; }","title":"Dart"},{"location":"List/#go","text":"package main import ( \"fmt\" \"sort\" \"strings\" ) func main () { //new empty list lst1 := stringList {} //new initialized list lst2 := stringList { \"str20\" , \"str21\" } //append element lst1 = append ( lst1 , \"str10\" ) //append list lst1 = append ( lst1 , lst2 ... ) //add head element lst1 = append ([] string { \"str00\" }, lst1 ... ) //reverse sort . Sort ( sort . Reverse ( lst1 )) //trap out of bounds access elem := getElemAt ( lst1 , 100 ) fmt . Printf ( \"\\nElem *%v*\" , elem ) //sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] //list length lst3 := lst1 [ 1 : len ( lst1 )] fmt . Printf ( \"\\n%v\" , lst3 ) //map and filter lst4 := stringList {} for _ , elem := range lst1 { lst4 = append ( lst4 , strings . ToUpper ( elem )) } lst5 := stringList {} for _ , elem := range lst4 { if elem != \"STR00\" { lst5 = append ( lst5 , elem ) } } fmt . Printf ( \"\\n%v\" , lst5 ) } type stringList [] string func ( p stringList ) Len () int { return len ( p ) } func ( p stringList ) Less ( i , j int ) bool { return p [ i ] < p [ j ] } func ( p stringList ) Swap ( i , j int ) { p [ i ], p [ j ] = p [ j ], p [ i ] } func getElemAt ( lst stringList , index int ) string { defer recoverList () elem := lst [ index ] return elem } func recoverList () { recover () }","title":"Go"},{"location":"List/#nim","text":"import sequtils as sq import algorithm as al import strutils as st import strformat proc getElemAt ( lst : seq [ string ] , index : int ): string = try : return lst [ index ] except : return \"\" # new empty list var lst1 : seq [ string ] = @[] # new initialized list var lst2 = @[ \"str20\" , \"str21\" ] # append element lst1 . add ( \"str10\" ) #append list lst1 = sq . concat ( lst1 , lst2 ) # add head element lst1 = sq . concat ( @[ \"str00\" ] , lst1 ) # reverse lst1 = al . reversed ( lst1 ) # trap out of bounds access let elem = getElemAt ( lst1 , 100 ) echo & \"Elem *{elem}*\" # sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] # list length var lst3 = lst1 [ 1 .. len ( lst1 ) - 1 ] echo lst3 # map and filter var lst4 = map ( lst3 , proc ( x : string ): string = st . toUpper ( x )) var lst5 = filter ( lst4 , proc ( x : string ): bool = x != \"STR00\" ) echo lst5","title":"Nim"},{"location":"List/#python","text":"from typing import List # new empty list lst1 : List [ str ] = [] # new initialized list lst2 : List [ str ] = [ \"str20\" , \"str21\" ] # append element lst1 = lst1 + [ \"str10\" ] def elem_at_index ( lst : List [ str ], index : int ) -> str : try : return lst [ index ] except : return \"\" # append list lst1 = lst1 + lst2 # add head element lst1 = [ \"str00\" ] + lst1 # reverse lst1 . reverse () # trap outof bounds access elem = elem_at_index ( lst1 , 100 ) print ( f \"Elem *{elem}*\" ) # sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] # list length lst3 : List [ str ] = lst1 [ 1 : len ( lst1 )] print ( lst3 ) # map and filter lst4 : List [ str ] = [ elem for elem in map ( lambda x : x . upper (), lst1 )] lst5 = [ elem for elem in filter ( lambda x : x != \"STR00\" , lst4 )] print ( lst5 )","title":"Python"},{"location":"List/#rust","text":"fn main () { // new empty list let mut lst1 : Vec <& str > = vec ! []; //new initialized list let lst2 = vec ! [ \"str20\" , \"str21\" ]; // append element lst1 . push ( \"str10\" ); // append list lst1 . extend ( lst2 ); // add head element lst1 . insert ( 0 , \"str00\" ); //reverse lst1 . reverse (); //access elem with out of bounds check let elem = match lst1 . get ( 100 ) { None => \"not found\" , Some ( x ) => x }; println ! ( \"Elem {}\" , elem ); // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] // list length let lst3 : Vec <& str > = lst1 [ 1 .. lst1 . len ()]. to_vec (); println ! ( \"{:?}\" , & lst3 ); // map and filter let lst4 : Vec < _ > = lst3 . into_iter (). map ( | x | x . to_uppercase ()). collect (); let lst5 : Vec < _ > = lst4 . into_iter (). filter ( | x | * x != \"STR00\" ). collect (); println ! ( \"{:?}\" , & lst5 ); }","title":"Rust"},{"location":"List/#typescript","text":"// new empty list var lst1 = []; //new initialized list var lst2 = [ \"str20\" , \"str21\" ]; // append element lst1 . push ( \"str10\" ); // append list lst1 = lst1 . concat ( lst2 ); // add head element lst1 = [ \"str00\" ]. concat ( lst1 ); //reverse lst1 = lst1 . reverse (); // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] // list length var lst3 = lst1 . slice ( 1 , lst1 . length ); console . log ( ` ${ lst3 } ` ); // map and filter var lst4 = lst3 . map (( x ) => x . toUpperCase ()); var lst5 = lst4 . filter (( x ) => x != \"STR00\" ); console . log ( ` ${ lst5 } ` );","title":"TypeScript"},{"location":"Numeric/","text":"Numeric C# //dotnet add package Microsoft.ML.Probabilistic using System ; using Microsoft.ML.Probabilistic.Math ; public class Program { public static void Main ( string [] args ) { double [,] x = {{ 1.0 , 2.0 , 3.0 },{ 3.0 , 4.0 , 5.0 },{ 0.0 , 5.0 , 6.0 }}; var a = new Matrix ( x ); var at = a . Transpose (); var b = a * at ; var dt = a . Determinant (); //var i = a.Inverse(); not implemented yet Console . WriteLine ( \"{0}\" , at ); Console . WriteLine ( \"{0}\" , b ); Console . WriteLine ( \"{0}\" , dt ); //Console.WriteLine(\"{0}\", i); } } Python import time import numpy as np start_time : float = time . time () # START MEASURE a = np . array ([[ 1. , 2. , 3. ],[ 3. , 4. , 5. ],[ 0. , 5. , 6. ]]) am0 = np . mean ( a , axis = 0 ) as0 = np . std ( a , axis = 0 ) amax0 = np . max ( a , 0 ) at = np . transpose ( a ) b = np . dot ( a , at ) dt = np . linalg . det ( a ); i = np . linalg . inv ( a ) end_time : float = time . time () # END MEASURE print ( am0 ) print ( as0 ) print ( amax0 ) print ( at ) print ( b ) print ( dt ) print ( i ) print ( f \"Elapsed: {((end_time - start_time)*1000)} ms\" ) Rust //[dependencies] //peroxide = \"0.18.1\" extern crate peroxide ; use peroxide :: * ; use std :: time :: { Instant }; fn main () { let now = Instant :: now (); //START MEASURE let a = py_matrix ( vec ! [ vec ! [ 1. , 2. , 3. ], vec ! [ 3. , 4. , 5. ], vec ! [ 0. , 5. , 6. ]]); let am0 = a . mean (); let as0 = a . sd (); let mut amax0 : Vec < f64 > = vec ! []; let cols = a . row ( 0 ). len (); for index in 0 .. cols { amax0 . push ( max ( a . col ( index ))) } let at = & a . transpose (); let b = & a * at ; let dt = & a . det (); let i = & a . inv (). expect ( \"inverse failed\" ); let new_now = Instant :: now (); //END MEASURE am0 . print (); as0 . print (); println ! ( \"{:?}\" , amax0 ); at . print (); b . print (); dt . print (); i . print (); println ! ( \"Elapsed: {:?}\" , new_now . duration_since ( now )); }","title":"Numeric"},{"location":"Numeric/#numeric","text":"","title":"Numeric"},{"location":"Numeric/#c35","text":"//dotnet add package Microsoft.ML.Probabilistic using System ; using Microsoft.ML.Probabilistic.Math ; public class Program { public static void Main ( string [] args ) { double [,] x = {{ 1.0 , 2.0 , 3.0 },{ 3.0 , 4.0 , 5.0 },{ 0.0 , 5.0 , 6.0 }}; var a = new Matrix ( x ); var at = a . Transpose (); var b = a * at ; var dt = a . Determinant (); //var i = a.Inverse(); not implemented yet Console . WriteLine ( \"{0}\" , at ); Console . WriteLine ( \"{0}\" , b ); Console . WriteLine ( \"{0}\" , dt ); //Console.WriteLine(\"{0}\", i); } }","title":"C#"},{"location":"Numeric/#python","text":"import time import numpy as np start_time : float = time . time () # START MEASURE a = np . array ([[ 1. , 2. , 3. ],[ 3. , 4. , 5. ],[ 0. , 5. , 6. ]]) am0 = np . mean ( a , axis = 0 ) as0 = np . std ( a , axis = 0 ) amax0 = np . max ( a , 0 ) at = np . transpose ( a ) b = np . dot ( a , at ) dt = np . linalg . det ( a ); i = np . linalg . inv ( a ) end_time : float = time . time () # END MEASURE print ( am0 ) print ( as0 ) print ( amax0 ) print ( at ) print ( b ) print ( dt ) print ( i ) print ( f \"Elapsed: {((end_time - start_time)*1000)} ms\" )","title":"Python"},{"location":"Numeric/#rust","text":"//[dependencies] //peroxide = \"0.18.1\" extern crate peroxide ; use peroxide :: * ; use std :: time :: { Instant }; fn main () { let now = Instant :: now (); //START MEASURE let a = py_matrix ( vec ! [ vec ! [ 1. , 2. , 3. ], vec ! [ 3. , 4. , 5. ], vec ! [ 0. , 5. , 6. ]]); let am0 = a . mean (); let as0 = a . sd (); let mut amax0 : Vec < f64 > = vec ! []; let cols = a . row ( 0 ). len (); for index in 0 .. cols { amax0 . push ( max ( a . col ( index ))) } let at = & a . transpose (); let b = & a * at ; let dt = & a . det (); let i = & a . inv (). expect ( \"inverse failed\" ); let new_now = Instant :: now (); //END MEASURE am0 . print (); as0 . print (); println ! ( \"{:?}\" , amax0 ); at . print (); b . print (); dt . print (); i . print (); println ! ( \"Elapsed: {:?}\" , new_now . duration_since ( now )); }","title":"Rust"},{"location":"Playground links/","text":"Playground links C# .NET Fiddle Tio C# (.NET Core) Dart DatPad Tio Dart Go Go Playground Tio Go Nim Nim Playground Tio Nim Python Tio Python3 Rust Rust Playground Tio Rust TypeScript Tio TypeScript","title":"Playground links"},{"location":"Playground links/#playground-links","text":"","title":"Playground links"},{"location":"Playground links/#c35","text":".NET Fiddle Tio C# (.NET Core)","title":"C#"},{"location":"Playground links/#dart","text":"DatPad Tio Dart","title":"Dart"},{"location":"Playground links/#go","text":"Go Playground Tio Go","title":"Go"},{"location":"Playground links/#nim","text":"Nim Playground Tio Nim","title":"Nim"},{"location":"Playground links/#python","text":"Tio Python3","title":"Python"},{"location":"Playground links/#rust","text":"Rust Playground Tio Rust","title":"Rust"},{"location":"Playground links/#typescript","text":"Tio TypeScript","title":"TypeScript"},{"location":"Scaffold with CLI/","text":"Scaffold with CLI C# dotnet new console -o hello cd hello dotnet run Dart pub global activate stagehand mkdir hello cd hello stagehand console-full pub get dart bin/main.dart Rust cargo new hello -- bin cd hello cargo run","title":"Scaffold with CLI"},{"location":"Scaffold with CLI/#scaffold-with-cli","text":"","title":"Scaffold with CLI"},{"location":"Scaffold with CLI/#c35","text":"dotnet new console -o hello cd hello dotnet run","title":"C#"},{"location":"Scaffold with CLI/#dart","text":"pub global activate stagehand mkdir hello cd hello stagehand console-full pub get dart bin/main.dart","title":"Dart"},{"location":"Scaffold with CLI/#rust","text":"cargo new hello -- bin cd hello cargo run","title":"Rust"},{"location":"String/","text":"String C# using System ; class Program { static void Main ( string [] args ) { var name = \"John\" ; var age = 21 ; var date = DateTime . Now ; // String interpolation: var str1 = $ \"{name} age is {age}, today is {date.DayOfWeek}, {date:HH:mm} now.\" ; Console . WriteLine ( str1 ); // String formatting: Console . WriteLine ( \"{0} age is {1}, today is {2}, {3:HH:mm} now.\" , name , age , date . DayOfWeek , date ); // float, hexadecimal var str2 = String . Format ( \"four decimals: {0:0.0000}, hex for {1}: 0x{2:X}\" , 0.123456 , 16 , 16 ); Console . WriteLine ( str2 ); // Parse numbers in string var elems = str2 . Split ( \" \" ); char [] toTrim = { ':' , ',' }; foreach ( var item in elems ) { try { var num = Double . Parse ( item . Trim ( toTrim )); Console . WriteLine ( \"Found float {0} in \\\"{1}\\\"\" , num , item ); } catch ( FormatException e ) { } } } } Dart // dependencies: // sprintf: ^4.0.2 import 'package:sprintf/sprintf.dart' ; main ( List < String > arguments ) { var name = \"John\" ; var age = 21 ; var date = DateTime . now (); var day = date . weekday ; // String interpolation var str1 = \" $ name age is $ age , weekday is $ day , ${ date . hour } : ${ date . minute } \" ; print ( str1 ); // String formatting float hex var str2 = sprintf ( \" \\n four decimals: %.4f, hex for %d: 0x%x\" , [ 0.123456 , 16 , 16 ]); print ( str2 ); // Parse number in string // Eliminate ',', ':' str2 = str2 . replaceAll ( ',' , '' ); str2 = str2 . replaceAll ( ':' , '' ); var elems = str2 . split ( \" \" ); for ( var item in elems ) { try { var num = double . parse ( item ); print ( \" Found float $ num in \\\" $ item \\\" \" ); } catch ( e ) { } } } Go package main import ( \"fmt\" \"strings\" \"time\" ) func main () { name := \"John\" age := 21 date := time . Now () // String interpolation str1 := fmt . Sprintf ( \"%s age is %d, weekday is %s, %d:%d\\n\" , name , age , date . Weekday (), date . Hour (), date . Minute ()) fmt . Print ( str1 ) str2 := fmt . Sprintf ( \"four decimals %.4f, hex for %d: 0x%x \\n\" , 1.23456 , 16 , 16 ) fmt . Print ( str2 ) elems := strings . Split ( str2 , \" \" ) var num float64 for _ , item := range elems { item = strings . Trim ( item , \",:\" ) _ , err := fmt . Sscanf ( item , \"%f\" , & num ) if err == nil { fmt . Printf ( \"Found float %f in \\\"%s\\\"\\n\" , num , item ) } } } Nim import strformat import times import strutils import sequtils let name = \"John\" ; let age = 21 ; let date = now () # String interpolation let str1 = & \"{name} age is {age}, weekday is {date.weekday}, {date.hour}:{date.minute}\" echo str1 # String formatting let str2 = & \"four decimals: {0.123456:2.4f}, hex for {16}: 0x{16:X}\" echo str2 var elems = str2 . split ( \" \" ) # Eliminate ',', ':' elems = map ( elems , proc ( x : string ): string = x . replace ( \",\" , \"\" )) elems = map ( elems , proc ( x : string ): string = x . replace ( \":\" , \"\" )) # Parse string for numbers for item in elems : try : let num = parseFloat ( item ) echo & \"Found float {num} in \\\" {item} \\\" \" except : discard Python import datetime name = \"John\" age = 21 date = datetime . datetime . now () # String interpolation str1 = f \"{name } age is {age}, today is {date.day}, {date.hour}:{date.minute}\" print ( str1 ) # String formatting str1 = \"{} age is {}, today us {}, {}:{}\" . format ( name , age , date . day , date . hour , date . minute ) print ( str1 ) # float, hexadecimal str2 = \"four decimals: {:.4f}, hex for {}: 0x{:x}\" . format ( 0.123456 , 16 , 16 ) print ( str2 ) # parse string for numbers elems = str2 . split ( \" \" ) for item in elems : item = item . replace ( \",\" , \"\" ) item = item . replace ( \":\" , \"\" ) try : num = float ( item ) print ( f \"Found {num} in \\\" {item} \\\" \" ) except : pass Rust // [dependencies] // chrono = \"*\" use chrono :: { Datelike , Timelike , Utc }; fn main () { let name = \"John\" ; let age = 21 ; let date = Utc :: now (); // STring formatting: string, int, date let str1 = & format ! ( \"{} age is {} weekday is, {:?}, {:?}:{:?}\" , name , age , date . weekday (), date . hour (), date . minute () ); println ! ( \"{}\" , str1 ); //float, hex let str2 = & format ! ( \"four decimals: {:.4}, hex for {}: 0x{:X}\" , 0.123456 , 16 , 16 ); println ! ( \"{}\" , str2 ); // Parse string for numbers let elems : Vec <& str > = str2 . split ( \" \" ). collect (); // Eliminate ',', ':' let mut elems1 : Vec < String > = elems . into_iter (). map ( | x | x . replace ( \",\" , \"\" )). collect (); elems1 = elems1 . into_iter (). map ( | x | x . replace ( \":\" , \"\" )). collect (); for item in elems1 { match item . parse :: < f64 > () { Ok ( num ) => println ! ( \" Found float {} in \\\" {} \\\" \" , num , item ), Err ( _ ) => {} } } } TypeScript let name1 = \"John\" ; let age = 21 ; let date = new Date (); // String interpolation (use backtick) let str1 = ` ${ name1 } age is ${ age } , today is ${ date . getDay () } , ${ date . getHours () } : ${ date . getMinutes () } ` ; console . log ( str1 ); let num = 16 let str2 = `four decimals: ${ 1.23456 . toFixed ( 4 ) } , hex for ${ num } is 0x ${ num . toString ( 16 ) } ` ; console . log ( str2 ); // Parse string for number let elems = str2 . split ( \" \" ); elems . forEach ( item => { let num = parseFloat ( item ); if ( ! isNaN ( num )) { console . log ( `Found float ${ num } in \\ \" ${ item } \\ \"` ); } });","title":"String"},{"location":"String/#string","text":"","title":"String"},{"location":"String/#c35","text":"using System ; class Program { static void Main ( string [] args ) { var name = \"John\" ; var age = 21 ; var date = DateTime . Now ; // String interpolation: var str1 = $ \"{name} age is {age}, today is {date.DayOfWeek}, {date:HH:mm} now.\" ; Console . WriteLine ( str1 ); // String formatting: Console . WriteLine ( \"{0} age is {1}, today is {2}, {3:HH:mm} now.\" , name , age , date . DayOfWeek , date ); // float, hexadecimal var str2 = String . Format ( \"four decimals: {0:0.0000}, hex for {1}: 0x{2:X}\" , 0.123456 , 16 , 16 ); Console . WriteLine ( str2 ); // Parse numbers in string var elems = str2 . Split ( \" \" ); char [] toTrim = { ':' , ',' }; foreach ( var item in elems ) { try { var num = Double . Parse ( item . Trim ( toTrim )); Console . WriteLine ( \"Found float {0} in \\\"{1}\\\"\" , num , item ); } catch ( FormatException e ) { } } } }","title":"C#"},{"location":"String/#dart","text":"// dependencies: // sprintf: ^4.0.2 import 'package:sprintf/sprintf.dart' ; main ( List < String > arguments ) { var name = \"John\" ; var age = 21 ; var date = DateTime . now (); var day = date . weekday ; // String interpolation var str1 = \" $ name age is $ age , weekday is $ day , ${ date . hour } : ${ date . minute } \" ; print ( str1 ); // String formatting float hex var str2 = sprintf ( \" \\n four decimals: %.4f, hex for %d: 0x%x\" , [ 0.123456 , 16 , 16 ]); print ( str2 ); // Parse number in string // Eliminate ',', ':' str2 = str2 . replaceAll ( ',' , '' ); str2 = str2 . replaceAll ( ':' , '' ); var elems = str2 . split ( \" \" ); for ( var item in elems ) { try { var num = double . parse ( item ); print ( \" Found float $ num in \\\" $ item \\\" \" ); } catch ( e ) { } } }","title":"Dart"},{"location":"String/#go","text":"package main import ( \"fmt\" \"strings\" \"time\" ) func main () { name := \"John\" age := 21 date := time . Now () // String interpolation str1 := fmt . Sprintf ( \"%s age is %d, weekday is %s, %d:%d\\n\" , name , age , date . Weekday (), date . Hour (), date . Minute ()) fmt . Print ( str1 ) str2 := fmt . Sprintf ( \"four decimals %.4f, hex for %d: 0x%x \\n\" , 1.23456 , 16 , 16 ) fmt . Print ( str2 ) elems := strings . Split ( str2 , \" \" ) var num float64 for _ , item := range elems { item = strings . Trim ( item , \",:\" ) _ , err := fmt . Sscanf ( item , \"%f\" , & num ) if err == nil { fmt . Printf ( \"Found float %f in \\\"%s\\\"\\n\" , num , item ) } } }","title":"Go"},{"location":"String/#nim","text":"import strformat import times import strutils import sequtils let name = \"John\" ; let age = 21 ; let date = now () # String interpolation let str1 = & \"{name} age is {age}, weekday is {date.weekday}, {date.hour}:{date.minute}\" echo str1 # String formatting let str2 = & \"four decimals: {0.123456:2.4f}, hex for {16}: 0x{16:X}\" echo str2 var elems = str2 . split ( \" \" ) # Eliminate ',', ':' elems = map ( elems , proc ( x : string ): string = x . replace ( \",\" , \"\" )) elems = map ( elems , proc ( x : string ): string = x . replace ( \":\" , \"\" )) # Parse string for numbers for item in elems : try : let num = parseFloat ( item ) echo & \"Found float {num} in \\\" {item} \\\" \" except : discard","title":"Nim"},{"location":"String/#python","text":"import datetime name = \"John\" age = 21 date = datetime . datetime . now () # String interpolation str1 = f \"{name } age is {age}, today is {date.day}, {date.hour}:{date.minute}\" print ( str1 ) # String formatting str1 = \"{} age is {}, today us {}, {}:{}\" . format ( name , age , date . day , date . hour , date . minute ) print ( str1 ) # float, hexadecimal str2 = \"four decimals: {:.4f}, hex for {}: 0x{:x}\" . format ( 0.123456 , 16 , 16 ) print ( str2 ) # parse string for numbers elems = str2 . split ( \" \" ) for item in elems : item = item . replace ( \",\" , \"\" ) item = item . replace ( \":\" , \"\" ) try : num = float ( item ) print ( f \"Found {num} in \\\" {item} \\\" \" ) except : pass","title":"Python"},{"location":"String/#rust","text":"// [dependencies] // chrono = \"*\" use chrono :: { Datelike , Timelike , Utc }; fn main () { let name = \"John\" ; let age = 21 ; let date = Utc :: now (); // STring formatting: string, int, date let str1 = & format ! ( \"{} age is {} weekday is, {:?}, {:?}:{:?}\" , name , age , date . weekday (), date . hour (), date . minute () ); println ! ( \"{}\" , str1 ); //float, hex let str2 = & format ! ( \"four decimals: {:.4}, hex for {}: 0x{:X}\" , 0.123456 , 16 , 16 ); println ! ( \"{}\" , str2 ); // Parse string for numbers let elems : Vec <& str > = str2 . split ( \" \" ). collect (); // Eliminate ',', ':' let mut elems1 : Vec < String > = elems . into_iter (). map ( | x | x . replace ( \",\" , \"\" )). collect (); elems1 = elems1 . into_iter (). map ( | x | x . replace ( \":\" , \"\" )). collect (); for item in elems1 { match item . parse :: < f64 > () { Ok ( num ) => println ! ( \" Found float {} in \\\" {} \\\" \" , num , item ), Err ( _ ) => {} } } }","title":"Rust"},{"location":"String/#typescript","text":"let name1 = \"John\" ; let age = 21 ; let date = new Date (); // String interpolation (use backtick) let str1 = ` ${ name1 } age is ${ age } , today is ${ date . getDay () } , ${ date . getHours () } : ${ date . getMinutes () } ` ; console . log ( str1 ); let num = 16 let str2 = `four decimals: ${ 1.23456 . toFixed ( 4 ) } , hex for ${ num } is 0x ${ num . toString ( 16 ) } ` ; console . log ( str2 ); // Parse string for number let elems = str2 . split ( \" \" ); elems . forEach ( item => { let num = parseFloat ( item ); if ( ! isNaN ( num )) { console . log ( `Found float ${ num } in \\ \" ${ item } \\ \"` ); } });","title":"TypeScript"},{"location":"Structure or Class/","text":"Structure or Class C# using System ; class Person { public string firstName ; public string secondName ; //constructor with default arguments public Person ( string fname = \"John\" , string sname = \"Doe\" ) { firstName = fname ; secondName = sname ; } } class Customer { public Person person ; //keep balance private double balance = 0.0 ; public Customer ( Person p ) { person = p ; } //methods public void AddToBalance ( double sum ) { balance += sum ; } public double GetBalance () { return balance ; } } class Program { static void Main ( string [] args ) { var p1 = new Person ( \"Mark\" ); var c1 = new Customer ( p1 ); //methos c1 . AddToBalance ( 100.0 ); c1 . AddToBalance ( 10.0 ); //property Console . WriteLine ( \"New {0} balance: {1}\" , c1 . person . firstName , c1 . GetBalance ()); } } Dart //file moda.dart -> package moda class Person { String firstName ; String secondName ; //Default/Optional parameters between [] Person ([ this . firstName = \"John\" , this . secondName = \"Doe\" ]) ; } class Customer { Person person ; //starting underscore: not visible outside package double _balance ; Customer ( this . person , [ this . _balance = 0.0 ]); void addToBalance ( double sum ) { this . _balance += sum ; } double getBalance () { return this . _balance ; } } import 'moda.dart' ; main ( List < String > args ) { var p1 = Person ( \"Mark\" ); var c1 = Customer ( p1 ); c1 . person = p1 ; //Method c1 . addToBalance ( 100.0 ); c1 . addToBalance ( 10.0 ); //Property var name = c1 . person . firstName ; var balance = c1 . getBalance (); print ( \"New $ name balance: $ balance \" ); } Go //file src/moda/moda.go -> package moda package moda // all public identifier must start with Uppercase type Person struct { FirstName string SecondName string } type Customer struct { Person Person balance float64 //lowercase because private } // struct creation with optional parameters func NewPerson ( args ... string ) Person { firstName := \"John\" secondName := \"Doe\" if len ( args ) > 0 { firstName = args [ 0 ] } if len ( args ) > 1 { secondName = args [ 1 ] } return Person { FirstName : firstName , SecondName : secondName } } // struct creation func NewCustomer ( person Person ) Customer { return Customer { Person : person , balance : 0.0 } } // public methods for Customer func ( customer * Customer ) AddToBalance ( sum float64 ) { customer . balance += sum } func ( customer * Customer ) GetBalance () float64 { return customer . balance } package main import ( \"fmt\" \"moda\" ) func main () { p1 := moda . NewPerson ( \"Mark\" ) c1 := moda . NewCustomer ( p1 ) //method c1 . AddToBalance ( 100.0 ) c1 . AddToBalance ( 10.0 ) balance := c1 . GetBalance () //property fmt . Printf ( \"\\nNew %v balance: %v\" , c1 . Person . FirstName , balance ) } Nim # file moda.nim -> module moda type Person * = ref object # asterisk for public firstName : string secondName : string # getter proc firstName * ( person : Person ): string = person . firstName proc newPerson * ( fName : string = \"John\" , sName : string = \"Doe\" ): Person = Person ( firstName : fName , secondName : sName ) type Customer * = ref object person : Person balance : float64 # getter proc person * ( customer : Customer ): Person = customer . person # getter proc balance * ( customer : Customer ): float64 = customer . balance proc newCustomer * ( p : Person , b : float64 = 0.0 ): Customer = Customer ( person : p , balance : b ) # method proc addToBalance * ( c : Customer , sum : float64 ) = c . balance = c . balance + sum import moda import strformat as sf let p1 : Person = moda . newPerson ( \"Mark\" ) #use default for secondName var c1 = moda . newCustomer ( p1 ) #use default for balance # method c1 . addToBalance ( 100.0 ) c1 . addToBalance ( 10.0 ) # property, reading only through getter echo sf . fmt\"New {c1.person.first_name} balance: {c1.balance}\" Python from dataclasses import dataclass @dataclass class Person : first_name : str = \"John\" second_name : str = \"Doe\" @dataclass class Customer : person : Person # double initial underscore for private __balance : float = 0.0 def add_to_balance ( self , num : float ): self . __balance += num def get_balance ( self ) -> float : return self . __balance p1 = Person ( \"Mark\" ) # use default for second_name c1 = Customer ( p1 ) #use default for balance # method c1 . add_to_balance ( 100.0 ) c1 . add_to_balance ( 10.0 ) new_balance = c1 . get_balance () # property print ( f \" New {c1.person.firstName} balance: {new_balance}\" ) Rust //private fields/methods are not visible outside the module mod mod1 { #[derive(Debug)] pub struct Person { pub first_name : String , pub second_name : String , } #[derive(Debug)] pub struct Customer { pub person : Person , balance : f64 , } //default accessible outside only if fields are all public impl Default for Person { fn default () -> Self { Person { first_name : \"John\" . to_string (), second_name : \"Doe\" . to_string (), } } } impl Customer { pub fn new () -> Self { Customer { person : Person {.. Person :: default ()}, balance : 0.0 } } pub fn add_to_balance ( & mut self , sum : f64 ) { self . balance += sum ; } pub fn get_balance ( & self ) -> f64 { self . balance } } } use mod1 :: * ; fn main () { let mut c1 = Customer :: new (); //use person and balance default c1 . person . first_name = \"Mark\" . to_string (); //change first_name println ! ( \"{:?}\" , & c1 ); //Method c1 . add_to_balance ( 100.0 ); c1 . add_to_balance ( 10.0 ); //Property println ! ( \"New {} balance: {} \" , & c1 . person . first_name , c1 . get_balance ()); } TypeScript class Person { firstName : string ; secondName : string ; //Default/Optional parameters constructor ( fname : string = \"John\" , sname : string = \"Doe\" ) { this . firstName = fname ; this . secondName = sname ; } } class Customer { person : Person ; private _balance : number = 0.0 ; constructor ( p : Person ) { this . person = p ; } addToBalance ( sum : number ) { this . _balance += sum ; } getBalance() { return this . _balance ; } } var p1 = new Person ( \"Mark\" ); var c1 = new Customer ( p1 ); c1 . person = p1 ; //Method c1 . addToBalance ( 100.0 ); c1 . addToBalance ( 10.0 ); //Property var pname = c1 . person . firstName ; var balance = c1 . getBalance (); console . log ( `New ${ pname } balance: ${ balance } ` );","title":"Structure or Class"},{"location":"Structure or Class/#structure-or-class","text":"","title":"Structure or Class"},{"location":"Structure or Class/#c35","text":"using System ; class Person { public string firstName ; public string secondName ; //constructor with default arguments public Person ( string fname = \"John\" , string sname = \"Doe\" ) { firstName = fname ; secondName = sname ; } } class Customer { public Person person ; //keep balance private double balance = 0.0 ; public Customer ( Person p ) { person = p ; } //methods public void AddToBalance ( double sum ) { balance += sum ; } public double GetBalance () { return balance ; } } class Program { static void Main ( string [] args ) { var p1 = new Person ( \"Mark\" ); var c1 = new Customer ( p1 ); //methos c1 . AddToBalance ( 100.0 ); c1 . AddToBalance ( 10.0 ); //property Console . WriteLine ( \"New {0} balance: {1}\" , c1 . person . firstName , c1 . GetBalance ()); } }","title":"C#"},{"location":"Structure or Class/#dart","text":"//file moda.dart -> package moda class Person { String firstName ; String secondName ; //Default/Optional parameters between [] Person ([ this . firstName = \"John\" , this . secondName = \"Doe\" ]) ; } class Customer { Person person ; //starting underscore: not visible outside package double _balance ; Customer ( this . person , [ this . _balance = 0.0 ]); void addToBalance ( double sum ) { this . _balance += sum ; } double getBalance () { return this . _balance ; } } import 'moda.dart' ; main ( List < String > args ) { var p1 = Person ( \"Mark\" ); var c1 = Customer ( p1 ); c1 . person = p1 ; //Method c1 . addToBalance ( 100.0 ); c1 . addToBalance ( 10.0 ); //Property var name = c1 . person . firstName ; var balance = c1 . getBalance (); print ( \"New $ name balance: $ balance \" ); }","title":"Dart"},{"location":"Structure or Class/#go","text":"//file src/moda/moda.go -> package moda package moda // all public identifier must start with Uppercase type Person struct { FirstName string SecondName string } type Customer struct { Person Person balance float64 //lowercase because private } // struct creation with optional parameters func NewPerson ( args ... string ) Person { firstName := \"John\" secondName := \"Doe\" if len ( args ) > 0 { firstName = args [ 0 ] } if len ( args ) > 1 { secondName = args [ 1 ] } return Person { FirstName : firstName , SecondName : secondName } } // struct creation func NewCustomer ( person Person ) Customer { return Customer { Person : person , balance : 0.0 } } // public methods for Customer func ( customer * Customer ) AddToBalance ( sum float64 ) { customer . balance += sum } func ( customer * Customer ) GetBalance () float64 { return customer . balance } package main import ( \"fmt\" \"moda\" ) func main () { p1 := moda . NewPerson ( \"Mark\" ) c1 := moda . NewCustomer ( p1 ) //method c1 . AddToBalance ( 100.0 ) c1 . AddToBalance ( 10.0 ) balance := c1 . GetBalance () //property fmt . Printf ( \"\\nNew %v balance: %v\" , c1 . Person . FirstName , balance ) }","title":"Go"},{"location":"Structure or Class/#nim","text":"# file moda.nim -> module moda type Person * = ref object # asterisk for public firstName : string secondName : string # getter proc firstName * ( person : Person ): string = person . firstName proc newPerson * ( fName : string = \"John\" , sName : string = \"Doe\" ): Person = Person ( firstName : fName , secondName : sName ) type Customer * = ref object person : Person balance : float64 # getter proc person * ( customer : Customer ): Person = customer . person # getter proc balance * ( customer : Customer ): float64 = customer . balance proc newCustomer * ( p : Person , b : float64 = 0.0 ): Customer = Customer ( person : p , balance : b ) # method proc addToBalance * ( c : Customer , sum : float64 ) = c . balance = c . balance + sum import moda import strformat as sf let p1 : Person = moda . newPerson ( \"Mark\" ) #use default for secondName var c1 = moda . newCustomer ( p1 ) #use default for balance # method c1 . addToBalance ( 100.0 ) c1 . addToBalance ( 10.0 ) # property, reading only through getter echo sf . fmt\"New {c1.person.first_name} balance: {c1.balance}\"","title":"Nim"},{"location":"Structure or Class/#python","text":"from dataclasses import dataclass @dataclass class Person : first_name : str = \"John\" second_name : str = \"Doe\" @dataclass class Customer : person : Person # double initial underscore for private __balance : float = 0.0 def add_to_balance ( self , num : float ): self . __balance += num def get_balance ( self ) -> float : return self . __balance p1 = Person ( \"Mark\" ) # use default for second_name c1 = Customer ( p1 ) #use default for balance # method c1 . add_to_balance ( 100.0 ) c1 . add_to_balance ( 10.0 ) new_balance = c1 . get_balance () # property print ( f \" New {c1.person.firstName} balance: {new_balance}\" )","title":"Python"},{"location":"Structure or Class/#rust","text":"//private fields/methods are not visible outside the module mod mod1 { #[derive(Debug)] pub struct Person { pub first_name : String , pub second_name : String , } #[derive(Debug)] pub struct Customer { pub person : Person , balance : f64 , } //default accessible outside only if fields are all public impl Default for Person { fn default () -> Self { Person { first_name : \"John\" . to_string (), second_name : \"Doe\" . to_string (), } } } impl Customer { pub fn new () -> Self { Customer { person : Person {.. Person :: default ()}, balance : 0.0 } } pub fn add_to_balance ( & mut self , sum : f64 ) { self . balance += sum ; } pub fn get_balance ( & self ) -> f64 { self . balance } } } use mod1 :: * ; fn main () { let mut c1 = Customer :: new (); //use person and balance default c1 . person . first_name = \"Mark\" . to_string (); //change first_name println ! ( \"{:?}\" , & c1 ); //Method c1 . add_to_balance ( 100.0 ); c1 . add_to_balance ( 10.0 ); //Property println ! ( \"New {} balance: {} \" , & c1 . person . first_name , c1 . get_balance ()); }","title":"Rust"},{"location":"Structure or Class/#typescript","text":"class Person { firstName : string ; secondName : string ; //Default/Optional parameters constructor ( fname : string = \"John\" , sname : string = \"Doe\" ) { this . firstName = fname ; this . secondName = sname ; } } class Customer { person : Person ; private _balance : number = 0.0 ; constructor ( p : Person ) { this . person = p ; } addToBalance ( sum : number ) { this . _balance += sum ; } getBalance() { return this . _balance ; } } var p1 = new Person ( \"Mark\" ); var c1 = new Customer ( p1 ); c1 . person = p1 ; //Method c1 . addToBalance ( 100.0 ); c1 . addToBalance ( 10.0 ); //Property var pname = c1 . person . firstName ; var balance = c1 . getBalance (); console . log ( `New ${ pname } balance: ${ balance } ` );","title":"TypeScript"},{"location":"System command/","text":"System command C# using System ; using System.Diagnostics ; public class Program { public static void Main ( string [] args ) { var psi = new ProcessStartInfo (); var process = new Process (); //(\"cargo\", \"version\"); psi . Arguments = \"--version\" ; psi . FileName = \"dotnet\" ; psi . RedirectStandardOutput = true ; psi . UseShellExecute = false ; process . StartInfo = psi ; process . Start (); while (! process . StandardOutput . EndOfStream ) { var line = process . StandardOutput . ReadLine (); Console . WriteLine ( line ); } } } Dart import \"dart:io\" ; main ( List < String > arguments ) { Process . run ( 'cargo' , [ 'version' ]). then (( ProcessResult result ) { print ( result . stdout ); }); } Go package main import ( \"fmt\" \"os/exec\" ) func main () { out , _ := exec . Command ( \"go\" , \"version\" ). Output () output := string ( out ) fmt . Printf ( \"\\n%s\" , output ) } Python import subprocess outp = subprocess . run ([ \"pip\" , \"--version\" ], capture_output = True , text = True ) print ( outp . stdout ) Rust use std :: process :: Command ; fn main () { let output = Command :: new ( \"cargo\" ) . args ( & [ \"version\" ]) . output () . expect ( \"failed to execute process\" ); println ! ( \"stdout: {}\" , String :: from_utf8_lossy ( & output . stdout )); }","title":"System command"},{"location":"System command/#system-command","text":"","title":"System command"},{"location":"System command/#c35","text":"using System ; using System.Diagnostics ; public class Program { public static void Main ( string [] args ) { var psi = new ProcessStartInfo (); var process = new Process (); //(\"cargo\", \"version\"); psi . Arguments = \"--version\" ; psi . FileName = \"dotnet\" ; psi . RedirectStandardOutput = true ; psi . UseShellExecute = false ; process . StartInfo = psi ; process . Start (); while (! process . StandardOutput . EndOfStream ) { var line = process . StandardOutput . ReadLine (); Console . WriteLine ( line ); } } }","title":"C#"},{"location":"System command/#dart","text":"import \"dart:io\" ; main ( List < String > arguments ) { Process . run ( 'cargo' , [ 'version' ]). then (( ProcessResult result ) { print ( result . stdout ); }); }","title":"Dart"},{"location":"System command/#go","text":"package main import ( \"fmt\" \"os/exec\" ) func main () { out , _ := exec . Command ( \"go\" , \"version\" ). Output () output := string ( out ) fmt . Printf ( \"\\n%s\" , output ) }","title":"Go"},{"location":"System command/#python","text":"import subprocess outp = subprocess . run ([ \"pip\" , \"--version\" ], capture_output = True , text = True ) print ( outp . stdout )","title":"Python"},{"location":"System command/#rust","text":"use std :: process :: Command ; fn main () { let output = Command :: new ( \"cargo\" ) . args ( & [ \"version\" ]) . output () . expect ( \"failed to execute process\" ); println ! ( \"stdout: {}\" , String :: from_utf8_lossy ( & output . stdout )); }","title":"Rust"},{"location":"Union/","text":"Union C# using System ; using System.Collections.Generic ; public interface IComposite { bool isComposite (); } class Person : IComposite { public string firstName ; public string secondName ; //constructor with default arguments public Person ( string fname = \"John\" , string sname = \"Doe\" ) { firstName = fname ; secondName = sname ; } bool IComposite . isComposite () { return true ; } } public class CInt : IComposite { bool IComposite . isComposite () { return true ; } public int value ; public CInt ( int num ) { value = num ; } } public class Program { public static void Main ( string [] args ) { var p1 = new Person (); var c1 = new CInt ( 12 ); cType ( p1 ); cType ( c1 ); //int needs to be enveloped in CInt } public static void cType ( IComposite c ) { if ( c is Person cp ) { Console . Write ( \"Person {0}\\n\" , cp . firstName ); } else if ( c is CInt ci ) { Console . Write ( \"Number {0}\\n\" , ci . value ); } } } Dart // interface to represent union class IComposite { bool isComposite () { return true ;} } class Person implements IComposite { String firstName ; String secondName ; Person ([ this . firstName = \"John\" , this . secondName = \"Doe\" ]); bool isComposite () { return true ; } } class CInt implements IComposite { int value ; CInt ( this . value ); bool isComposite () { return true ; } } main ( List < String > args ) { var p1 = Person (); cType ( p1 ); cType ( CInt ( 12 )); //int needs to be enveloped in CInt } cType ( IComposite c ) { if ( c is CInt ) { //cast to the actual type var c1 = c as CInt ; var value = c1 . value ; print ( \"Number $ value \" ); } else if ( c is Person ) { //cast to the actual type var p1 = c as Person ; var name = p1 . firstName ; print ( \"Person $ name \" ); } } Go package main import ( \"fmt\" ) type CompositeType interface { isComposite () bool } type Person struct { FirstName string SecondName string } // struct creation func NewPerson ( firstName string , secondName string ) Person { return Person { FirstName : firstName , SecondName : secondName } } type CInt struct { value int } // struct creation func NewCInt ( num int ) CInt { return CInt { value : num } } //link Person and CInt to CompositeType func ( p Person ) isComposite () bool { return true } func ( c CInt ) isComposite () bool { return true } func cType ( c CompositeType ) { switch c .( type ) { case Person : //cast to actual tyupe fmt . Printf ( \"\\nPerson %v\" , c .( Person ). FirstName ) case CInt : //cast to actual tyupe fmt . Printf ( \"\\nNumber %v\" , c .( CInt ). value ) } } func main () { p1 := NewPerson ( \"John\" , \"Doe\" ) c1 := NewCInt ( 12 ) //int needs to be enveloped in CInt cType ( p1 ) cType ( c1 ) } Nim import strformat type Person = ref object firstName : string secondName : string type CompositeKind = enum cPerson , cInt Composite = ref object case kind : CompositeKind of cInt : value : int of cPerson : person : Person proc cType ( c : Composite ) = if c . kind == cPerson : echo & \"Person {c.person.firstName}\" if c . kind == cInt : echo & \"Number {c.value}\" let p1 = Person ( firstName : \"John\" , secondName : \"Doe\" ) let cp1 = Composite ( kind : cPerson , person : p1 ) let cnum = Composite ( kind : cInt , value : 12 ) cType ( cp1 ) cType ( cnum ) Python from dataclasses import dataclass from typing import Union @dataclass class Person : first_name : str = \"John\" second_name : str = \"Doe\" Composite = Union [ Person , int ] def c_type ( c : Composite ): if type ( c ) == int : print ( f \"Number {c}\" ) elif isinstance ( c , Person ): print ( f \"Person {c.first_name}\" ) p1 = Person () c_type ( p1 ) c_type ( 12 ) Rust pub enum Composite { Person ( Person ), CInt ( i32 ) } pub struct Person { pub first_name : String , pub second_name : String , } pub fn c_type ( c : Composite ) { match c { Composite :: Person ( p ) => println ! ( \"Person {}\" , p . first_name ) , Composite :: CInt ( c ) => println ! ( \"Number {}\" , c ), } } fn main () { let p1 = Person { first_name : \"John\" . to_string (), second_name : \"Doe\" . to_string (), }; //all types must be enveloped in the containing enum c_type ( Composite :: Person ( p1 )); c_type ( Composite :: CInt ( 12 )); } TypeScript class Person { firstName : string ; secondName : string ; constructor ( fname : string = \"John\" , sname : string = \"Doe\" ) { this . firstName = fname ; this . secondName = sname ; } } type Composite = number | Person ; function cType ( c : Composite ) { if ( c instanceof Person ) { // non primitive type, needs casting var person = ( c as Person ); //tsc gives error here but generated js works console . log ( `Person ${ person . firstName } ` ); } else if ( typeof ( c ) == \"number\" ) { console . log ( `Number ${ c } ` ); } } let p1 = new Person (); cType ( p1 ); cType ( 12 );","title":"Union"},{"location":"Union/#union","text":"","title":"Union"},{"location":"Union/#c35","text":"using System ; using System.Collections.Generic ; public interface IComposite { bool isComposite (); } class Person : IComposite { public string firstName ; public string secondName ; //constructor with default arguments public Person ( string fname = \"John\" , string sname = \"Doe\" ) { firstName = fname ; secondName = sname ; } bool IComposite . isComposite () { return true ; } } public class CInt : IComposite { bool IComposite . isComposite () { return true ; } public int value ; public CInt ( int num ) { value = num ; } } public class Program { public static void Main ( string [] args ) { var p1 = new Person (); var c1 = new CInt ( 12 ); cType ( p1 ); cType ( c1 ); //int needs to be enveloped in CInt } public static void cType ( IComposite c ) { if ( c is Person cp ) { Console . Write ( \"Person {0}\\n\" , cp . firstName ); } else if ( c is CInt ci ) { Console . Write ( \"Number {0}\\n\" , ci . value ); } } }","title":"C#"},{"location":"Union/#dart","text":"// interface to represent union class IComposite { bool isComposite () { return true ;} } class Person implements IComposite { String firstName ; String secondName ; Person ([ this . firstName = \"John\" , this . secondName = \"Doe\" ]); bool isComposite () { return true ; } } class CInt implements IComposite { int value ; CInt ( this . value ); bool isComposite () { return true ; } } main ( List < String > args ) { var p1 = Person (); cType ( p1 ); cType ( CInt ( 12 )); //int needs to be enveloped in CInt } cType ( IComposite c ) { if ( c is CInt ) { //cast to the actual type var c1 = c as CInt ; var value = c1 . value ; print ( \"Number $ value \" ); } else if ( c is Person ) { //cast to the actual type var p1 = c as Person ; var name = p1 . firstName ; print ( \"Person $ name \" ); } }","title":"Dart"},{"location":"Union/#go","text":"package main import ( \"fmt\" ) type CompositeType interface { isComposite () bool } type Person struct { FirstName string SecondName string } // struct creation func NewPerson ( firstName string , secondName string ) Person { return Person { FirstName : firstName , SecondName : secondName } } type CInt struct { value int } // struct creation func NewCInt ( num int ) CInt { return CInt { value : num } } //link Person and CInt to CompositeType func ( p Person ) isComposite () bool { return true } func ( c CInt ) isComposite () bool { return true } func cType ( c CompositeType ) { switch c .( type ) { case Person : //cast to actual tyupe fmt . Printf ( \"\\nPerson %v\" , c .( Person ). FirstName ) case CInt : //cast to actual tyupe fmt . Printf ( \"\\nNumber %v\" , c .( CInt ). value ) } } func main () { p1 := NewPerson ( \"John\" , \"Doe\" ) c1 := NewCInt ( 12 ) //int needs to be enveloped in CInt cType ( p1 ) cType ( c1 ) }","title":"Go"},{"location":"Union/#nim","text":"import strformat type Person = ref object firstName : string secondName : string type CompositeKind = enum cPerson , cInt Composite = ref object case kind : CompositeKind of cInt : value : int of cPerson : person : Person proc cType ( c : Composite ) = if c . kind == cPerson : echo & \"Person {c.person.firstName}\" if c . kind == cInt : echo & \"Number {c.value}\" let p1 = Person ( firstName : \"John\" , secondName : \"Doe\" ) let cp1 = Composite ( kind : cPerson , person : p1 ) let cnum = Composite ( kind : cInt , value : 12 ) cType ( cp1 ) cType ( cnum )","title":"Nim"},{"location":"Union/#python","text":"from dataclasses import dataclass from typing import Union @dataclass class Person : first_name : str = \"John\" second_name : str = \"Doe\" Composite = Union [ Person , int ] def c_type ( c : Composite ): if type ( c ) == int : print ( f \"Number {c}\" ) elif isinstance ( c , Person ): print ( f \"Person {c.first_name}\" ) p1 = Person () c_type ( p1 ) c_type ( 12 )","title":"Python"},{"location":"Union/#rust","text":"pub enum Composite { Person ( Person ), CInt ( i32 ) } pub struct Person { pub first_name : String , pub second_name : String , } pub fn c_type ( c : Composite ) { match c { Composite :: Person ( p ) => println ! ( \"Person {}\" , p . first_name ) , Composite :: CInt ( c ) => println ! ( \"Number {}\" , c ), } } fn main () { let p1 = Person { first_name : \"John\" . to_string (), second_name : \"Doe\" . to_string (), }; //all types must be enveloped in the containing enum c_type ( Composite :: Person ( p1 )); c_type ( Composite :: CInt ( 12 )); }","title":"Rust"},{"location":"Union/#typescript","text":"class Person { firstName : string ; secondName : string ; constructor ( fname : string = \"John\" , sname : string = \"Doe\" ) { this . firstName = fname ; this . secondName = sname ; } } type Composite = number | Person ; function cType ( c : Composite ) { if ( c instanceof Person ) { // non primitive type, needs casting var person = ( c as Person ); //tsc gives error here but generated js works console . log ( `Person ${ person . firstName } ` ); } else if ( typeof ( c ) == \"number\" ) { console . log ( `Number ${ c } ` ); } } let p1 = new Person (); cType ( p1 ); cType ( 12 );","title":"TypeScript"},{"location":"Write & Read lines/","text":"Write & Read Lines C# using System ; using System.IO ; public class Program { public static void Main ( string [] args ) { var fileName = \"tmp01.txt\" ; using ( var f = File . CreateText ( fileName )) { f . WriteLine ( \"This is\\n\\na text\\nfile\" ); } try { using ( var f = File . OpenText ( fileName )) { string s ; while (( s = f . ReadLine ()) != null ) { Console . WriteLine ( s ); } } } catch { Console . WriteLine ( \"Could not find {0}\" , fileName ); } } } Dart import 'dart:io' ; import 'dart:convert' ; main () async { var fileName = \"tmp01.txt\" ; var f = File ( fileName ); var sink = f . openWrite (); sink . write ( \"This is \\n\\n a text \\n file\" ); await sink . close (); var fRead = File ( fileName ); Stream < List < int >> inputStream = fRead . openRead (); var lines = utf8 . decoder . bind ( inputStream ). transform ( LineSplitter ()); try { await for ( var line in lines ) { print ( ' $ line ' ); } } catch ( e ) { print ( \"Cannot find $ fileName \" ); } } Go package main import ( \"bufio\" \"fmt\" \"os\" ) func main () { fileName := \"tmp01.txt\" file , err := os . Create ( fileName ) if err != nil { fmt . Printf ( \"Can't create %s\\n\" , fileName ) os . Exit ( 0 ) } toWrite := [] byte ( \"This is\\n\\na text\\nfile\" ) file . Write ( toWrite ) file . Close () file , err = os . Open ( fileName ) if err != nil { fmt . Printf ( \"Can't open %s\\n\" , fileName ) os . Exit ( 0 ) } defer file . Close () scanner := bufio . NewScanner ( file ) for scanner . Scan () { fmt . Println ( scanner . Text ()) } if err := scanner . Err (); err != nil { fmt . Println ( \"Reading error: \" , err ) } } Nim import streams let fileName = \"tmp01.txt\" var strm = newFileStream ( fileName , fmWrite ) strm . write ( \"This is \\n\\n a text \\n file\" ) strm . close () let strmRead = newFileStream ( fileName , fmRead ) var line = \"\" if not isNil ( strmRead ): while strmRead . readLine ( line ): echo line strmRead . close () Python import os import sys file_name = \"tmp01.txt\" try : with open ( file_name , \"w\" ) as file : file . write ( \"This is \\n\\n a text \\n file\" ) except : print ( f \"Error writing {file_name}\" ) try : with open ( file_name , \"r\" ) as file : for line in file : print ( line , end = '' ) except : print ( f \"Error reading {file_name}\" ) Rust use std :: fs :: File ; use std :: io :: prelude :: * ; //without this, no write use std :: io :: BufRead ; use std :: io :: BufReader ; fn main () { let file_name = \"tmp01.txt\" ; let mut f = File :: create ( file_name ) . expect ( & format ! ( \"Cannot create {}\" , file_name )); f . write ( \"This is \\n\\n a text \\n file\" . as_bytes ()) . expect ( & format ! ( \"Cannot write to {}\" , file_name )); let f = File :: open ( file_name ) . expect ( & format ! ( \"File {} not found\" , file_name )); let file = BufReader :: new ( & f ); for line in file . lines () { let str1 : String = match line { Ok ( str1 ) => str1 . to_ascii_lowercase (), Err ( _ ) => { String :: new () //return empty string } }; println ! ( \"{}\" , & str1 ); } }","title":"Write & Read Lines"},{"location":"Write & Read lines/#write-read-lines","text":"","title":"Write &amp; Read Lines"},{"location":"Write & Read lines/#c35","text":"using System ; using System.IO ; public class Program { public static void Main ( string [] args ) { var fileName = \"tmp01.txt\" ; using ( var f = File . CreateText ( fileName )) { f . WriteLine ( \"This is\\n\\na text\\nfile\" ); } try { using ( var f = File . OpenText ( fileName )) { string s ; while (( s = f . ReadLine ()) != null ) { Console . WriteLine ( s ); } } } catch { Console . WriteLine ( \"Could not find {0}\" , fileName ); } } }","title":"C#"},{"location":"Write & Read lines/#dart","text":"import 'dart:io' ; import 'dart:convert' ; main () async { var fileName = \"tmp01.txt\" ; var f = File ( fileName ); var sink = f . openWrite (); sink . write ( \"This is \\n\\n a text \\n file\" ); await sink . close (); var fRead = File ( fileName ); Stream < List < int >> inputStream = fRead . openRead (); var lines = utf8 . decoder . bind ( inputStream ). transform ( LineSplitter ()); try { await for ( var line in lines ) { print ( ' $ line ' ); } } catch ( e ) { print ( \"Cannot find $ fileName \" ); } }","title":"Dart"},{"location":"Write & Read lines/#go","text":"package main import ( \"bufio\" \"fmt\" \"os\" ) func main () { fileName := \"tmp01.txt\" file , err := os . Create ( fileName ) if err != nil { fmt . Printf ( \"Can't create %s\\n\" , fileName ) os . Exit ( 0 ) } toWrite := [] byte ( \"This is\\n\\na text\\nfile\" ) file . Write ( toWrite ) file . Close () file , err = os . Open ( fileName ) if err != nil { fmt . Printf ( \"Can't open %s\\n\" , fileName ) os . Exit ( 0 ) } defer file . Close () scanner := bufio . NewScanner ( file ) for scanner . Scan () { fmt . Println ( scanner . Text ()) } if err := scanner . Err (); err != nil { fmt . Println ( \"Reading error: \" , err ) } }","title":"Go"},{"location":"Write & Read lines/#nim","text":"import streams let fileName = \"tmp01.txt\" var strm = newFileStream ( fileName , fmWrite ) strm . write ( \"This is \\n\\n a text \\n file\" ) strm . close () let strmRead = newFileStream ( fileName , fmRead ) var line = \"\" if not isNil ( strmRead ): while strmRead . readLine ( line ): echo line strmRead . close ()","title":"Nim"},{"location":"Write & Read lines/#python","text":"import os import sys file_name = \"tmp01.txt\" try : with open ( file_name , \"w\" ) as file : file . write ( \"This is \\n\\n a text \\n file\" ) except : print ( f \"Error writing {file_name}\" ) try : with open ( file_name , \"r\" ) as file : for line in file : print ( line , end = '' ) except : print ( f \"Error reading {file_name}\" )","title":"Python"},{"location":"Write & Read lines/#rust","text":"use std :: fs :: File ; use std :: io :: prelude :: * ; //without this, no write use std :: io :: BufRead ; use std :: io :: BufReader ; fn main () { let file_name = \"tmp01.txt\" ; let mut f = File :: create ( file_name ) . expect ( & format ! ( \"Cannot create {}\" , file_name )); f . write ( \"This is \\n\\n a text \\n file\" . as_bytes ()) . expect ( & format ! ( \"Cannot write to {}\" , file_name )); let f = File :: open ( file_name ) . expect ( & format ! ( \"File {} not found\" , file_name )); let file = BufReader :: new ( & f ); for line in file . lines () { let str1 : String = match line { Ok ( str1 ) => str1 . to_ascii_lowercase (), Err ( _ ) => { String :: new () //return empty string } }; println ! ( \"{}\" , & str1 ); } }","title":"Rust"}]}