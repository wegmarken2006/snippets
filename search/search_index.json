{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Runnable Snippets Languages: C# 8.0 Dart 2.5.0 Flutter 2.5.0 Go 1.17 Kotlin 1.3 Nim 1.0 Python 3.7.1 Rust 1.55.0 Sing 0.41.0 Singlang website Typescript 4.0.3 V 0.3 Still updating.","title":"Home"},{"location":"#runnable-snippets","text":"Languages: C# 8.0 Dart 2.5.0 Flutter 2.5.0 Go 1.17 Kotlin 1.3 Nim 1.0 Python 3.7.1 Rust 1.55.0 Sing 0.41.0 Singlang website Typescript 4.0.3 V 0.3 Still updating.","title":"Runnable Snippets"},{"location":"Android/","text":"Android Flutter Use dynamic libraries (i.e. Rust generated) in Flutter plugin flutter create --template=plugin native_add cd native_add mkdir example\\android\\app\\src\\main\\jniLibs\\x86_64 mkdir example\\android\\app\\src\\main\\jniLibs\\x86 mkdir example\\android\\app\\src\\main\\jniLibs\\arm64-v8a mkdir example\\android\\app\\src\\main\\jniLibs\\armeabi-v7a copy <dyn lib project>\\target\\x86_64-linux-android\\release\\libxxx.so example\\android\\app\\src\\main\\jniLibs\\x86_64 copy <dyn lib project>\\target\\i686-linux-android\\release\\libxxx.so example\\android\\app\\src\\main\\jniLibs\\x86 copy <dyn lib project>\\target\\aarch64-linux-android\\release\\libxxx.so example\\android\\app\\src\\main\\jniLibs\\arm64-v8a copy <dyn lib project>\\target\\armv7-linux-androideabi\\release\\libxxx.so example\\android\\app\\src\\main\\jniLibs\\armeabi-v7a cd example flutter run Rust Compile for Android rustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android x86_64-linux-android cargo install cargo-ndk cargo ndk --target aarch64-linux-android --android-platform 21 -- build --release cargo ndk --target armv7-linux-androideabi --android-platform 21 -- build --release cargo ndk --target i686-linux-android --android-platform 21 -- build --release cargo ndk --target x86_64-linux-android --android-platform 21 -- build --release","title":"Android"},{"location":"Android/#android","text":"","title":"Android"},{"location":"Android/#flutter","text":"","title":"Flutter"},{"location":"Android/#use-dynamic-libraries-ie-rust-generated-in-flutter-plugin","text":"flutter create --template=plugin native_add cd native_add mkdir example\\android\\app\\src\\main\\jniLibs\\x86_64 mkdir example\\android\\app\\src\\main\\jniLibs\\x86 mkdir example\\android\\app\\src\\main\\jniLibs\\arm64-v8a mkdir example\\android\\app\\src\\main\\jniLibs\\armeabi-v7a copy <dyn lib project>\\target\\x86_64-linux-android\\release\\libxxx.so example\\android\\app\\src\\main\\jniLibs\\x86_64 copy <dyn lib project>\\target\\i686-linux-android\\release\\libxxx.so example\\android\\app\\src\\main\\jniLibs\\x86 copy <dyn lib project>\\target\\aarch64-linux-android\\release\\libxxx.so example\\android\\app\\src\\main\\jniLibs\\arm64-v8a copy <dyn lib project>\\target\\armv7-linux-androideabi\\release\\libxxx.so example\\android\\app\\src\\main\\jniLibs\\armeabi-v7a cd example flutter run","title":"Use dynamic libraries (i.e. Rust generated) in Flutter plugin"},{"location":"Android/#rust","text":"","title":"Rust"},{"location":"Android/#compile-for-android","text":"rustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android x86_64-linux-android cargo install cargo-ndk cargo ndk --target aarch64-linux-android --android-platform 21 -- build --release cargo ndk --target armv7-linux-androideabi --android-platform 21 -- build --release cargo ndk --target i686-linux-android --android-platform 21 -- build --release cargo ndk --target x86_64-linux-android --android-platform 21 -- build --release","title":"Compile for Android"},{"location":"Async/","text":"Async C# using System ; using System.Net ; using System.IO ; using System.Collections.Generic ; using System.Threading.Tasks ; public class Program { public static void Main ( string [] args ) { var task = SumPageSizesAsync (); task . Wait (); } static async Task SumPageSizesAsync () { var total = 0 ; var urls = new List < string > { \"https://wegmarken2006.github.io/snippets/\" , \"https://wegmarken2006.github.io/snippets/Cross/\" , \"https://wegmarken2006.github.io/snippets/Dict/\" , \"https://wegmarken2006.github.io/snippets/Execution%20time/\" }; foreach ( var url in urls ) { var content = await GetURLContentsAsync ( url ); total += content . Length ; } Console . WriteLine ( \"{0}\" , total ); } static async Task < byte []> GetURLContentsAsync ( string url ) { var content = new MemoryStream (); var webReq = ( HttpWebRequest ) WebRequest . Create ( url ); using ( WebResponse response = await webReq . GetResponseAsync ()) { using ( Stream responseStream = response . GetResponseStream ()) { await responseStream . CopyToAsync ( content ); } } return content . ToArray (); } } Dart import 'package:http/http.dart' as http ; main () async { var urls = [ \"https://wegmarken2006.github.io/snippets/\" , \"https://wegmarken2006.github.io/snippets/Cross/\" , \"https://wegmarken2006.github.io/snippets/Dict/\" , \"https://wegmarken2006.github.io/snippets/Execution%20time/\" ]; var total = 0 ; for ( var url in urls ) { var text = await http . read ( url ); total = total + text . length ; } print ( \" $ total \" ); } Nim import strformat import httpClient import asyncdispatch proc sumPageSizesAsync () {. async .} = let urls = [ \"https://wegmarken2006.github.io/snippets/\" , \"https://wegmarken2006.github.io/snippets/Cross/\" , \"https://wegmarken2006.github.io/snippets/Dict/\" , \"https://wegmarken2006.github.io/snippets/Execution%20time/\" ] ; var total = 0 ; var client = newAsyncHttpClient () for url in urls : let text = await client . getContent ( url ) total = total + text . len () echo & \"{total}\" waitFor ( sumPageSizesAsync ()); Python # pip install aiohttp import aiohttp import asyncio async def sum_page_sizes (): urls = [ \"https://wegmarken2006.github.io/snippets/\" , \"https://wegmarken2006.github.io/snippets/Cross/\" , \"https://wegmarken2006.github.io/snippets/Dict/\" , \"https://wegmarken2006.github.io/snippets/Execution%20time/\" ] total = 0 for url in urls : async with aiohttp . ClientSession () as session : async with session . get ( url ) as response : text = await response . text () total = total + len ( text ) print ( total ) loop = asyncio . get_event_loop () loop . run_until_complete ( sum_page_sizes ()) Rust //[dependencies] //async-std = \"1.0.1\" //surf = \"1.0.3\" use async_std :: task :: * ; use surf :: { get }; fn main () { block_on ( sum_page_sizes ()); } async fn sum_page_sizes () { let urls = vec ! [ \"https://wegmarken2006.github.io/snippets/\" , \"https://wegmarken2006.github.io/snippets/Cross/\" , \"https://wegmarken2006.github.io/snippets/Dict/\" , \"https://wegmarken2006.github.io/snippets/Execution%20time/\" , ]; let mut total = 0 ; for url in urls { let response = get ( & url ). recv_string (). await . unwrap (); total = total + response . len (); } println ! ( \"{}\" , total ); }","title":"Async"},{"location":"Async/#async","text":"","title":"Async"},{"location":"Async/#c","text":"using System ; using System.Net ; using System.IO ; using System.Collections.Generic ; using System.Threading.Tasks ; public class Program { public static void Main ( string [] args ) { var task = SumPageSizesAsync (); task . Wait (); } static async Task SumPageSizesAsync () { var total = 0 ; var urls = new List < string > { \"https://wegmarken2006.github.io/snippets/\" , \"https://wegmarken2006.github.io/snippets/Cross/\" , \"https://wegmarken2006.github.io/snippets/Dict/\" , \"https://wegmarken2006.github.io/snippets/Execution%20time/\" }; foreach ( var url in urls ) { var content = await GetURLContentsAsync ( url ); total += content . Length ; } Console . WriteLine ( \"{0}\" , total ); } static async Task < byte []> GetURLContentsAsync ( string url ) { var content = new MemoryStream (); var webReq = ( HttpWebRequest ) WebRequest . Create ( url ); using ( WebResponse response = await webReq . GetResponseAsync ()) { using ( Stream responseStream = response . GetResponseStream ()) { await responseStream . CopyToAsync ( content ); } } return content . ToArray (); } }","title":"C#"},{"location":"Async/#dart","text":"import 'package:http/http.dart' as http ; main () async { var urls = [ \"https://wegmarken2006.github.io/snippets/\" , \"https://wegmarken2006.github.io/snippets/Cross/\" , \"https://wegmarken2006.github.io/snippets/Dict/\" , \"https://wegmarken2006.github.io/snippets/Execution%20time/\" ]; var total = 0 ; for ( var url in urls ) { var text = await http . read ( url ); total = total + text . length ; } print ( \" $ total \" ); }","title":"Dart"},{"location":"Async/#nim","text":"import strformat import httpClient import asyncdispatch proc sumPageSizesAsync () {. async .} = let urls = [ \"https://wegmarken2006.github.io/snippets/\" , \"https://wegmarken2006.github.io/snippets/Cross/\" , \"https://wegmarken2006.github.io/snippets/Dict/\" , \"https://wegmarken2006.github.io/snippets/Execution%20time/\" ] ; var total = 0 ; var client = newAsyncHttpClient () for url in urls : let text = await client . getContent ( url ) total = total + text . len () echo & \"{total}\" waitFor ( sumPageSizesAsync ());","title":"Nim"},{"location":"Async/#python","text":"# pip install aiohttp import aiohttp import asyncio async def sum_page_sizes (): urls = [ \"https://wegmarken2006.github.io/snippets/\" , \"https://wegmarken2006.github.io/snippets/Cross/\" , \"https://wegmarken2006.github.io/snippets/Dict/\" , \"https://wegmarken2006.github.io/snippets/Execution%20time/\" ] total = 0 for url in urls : async with aiohttp . ClientSession () as session : async with session . get ( url ) as response : text = await response . text () total = total + len ( text ) print ( total ) loop = asyncio . get_event_loop () loop . run_until_complete ( sum_page_sizes ())","title":"Python"},{"location":"Async/#rust","text":"//[dependencies] //async-std = \"1.0.1\" //surf = \"1.0.3\" use async_std :: task :: * ; use surf :: { get }; fn main () { block_on ( sum_page_sizes ()); } async fn sum_page_sizes () { let urls = vec ! [ \"https://wegmarken2006.github.io/snippets/\" , \"https://wegmarken2006.github.io/snippets/Cross/\" , \"https://wegmarken2006.github.io/snippets/Dict/\" , \"https://wegmarken2006.github.io/snippets/Execution%20time/\" , ]; let mut total = 0 ; for url in urls { let response = get ( & url ). recv_string (). await . unwrap (); total = total + response . len (); } println ! ( \"{}\" , total ); }","title":"Rust"},{"location":"C%20Call/","text":"C Call Dart //Copy test_ffi.dll into the project root //dependencies: // ffi: ^0.1.3 import 'dart:ffi' as ffi ; import 'package:ffi/ffi.dart' ; import 'dart:typed_data' ; typedef NativeDoubleFunction = ffi . Double Function ( ffi . Double ); typedef NativeOpFunction = double Function ( double ); typedef NativeFunction2 = ffi . Void Function ( ffi . Pointer < ffi . Void > , ffi . Int32 ); typedef NativeOpFunction2 = void Function ( ffi . Pointer < ffi . Void > , int ); main () { var dl = ffi . DynamicLibrary . open ( \"test_ffi.dll\" ); NativeOpFunction test_ffi = dl . lookup < ffi . NativeFunction < NativeDoubleFunction >> ( 'mul_2' ) . asFunction (); var res = test_ffi ( 3.0 ); print ( ' $ res ' ); NativeOpFunction2 test_ffi2 = dl . lookup < ffi . NativeFunction < NativeFunction2 >> ( 'inc_u8_vec' ) . asFunction (); Uint8List a8 = Uint8List . fromList ([ 1 , 2 , 3 , 4 ]); print ( ' $ a8 ' ); var pointer = allocate < ffi . Uint8 > ( count: a8 . length ); for ( int i = 0 ; i < a8 . length ; i ++ ){ pointer [ i ] = a8 [ i ]; } final voidP = pointer . cast < ffi . Void > (); test_ffi2 ( voidP , a8 . length ); for ( int i = 0 ; i < a8 . length ; i ++ ){ a8 [ i ] = pointer [ i ]; } print ( ' $ a8 ' ); free ( pointer ); } Python from ctypes import cdll , c_double lib = cdll . LoadLibrary ( \"test_ffi\" ) mul_2 = lib . mul_2 mul_2 . restype = c_double res = mul_2 ( c_double ( 3.0 )) print ( res )","title":"C Call"},{"location":"C%20Call/#c-call","text":"","title":"C Call"},{"location":"C%20Call/#dart","text":"//Copy test_ffi.dll into the project root //dependencies: // ffi: ^0.1.3 import 'dart:ffi' as ffi ; import 'package:ffi/ffi.dart' ; import 'dart:typed_data' ; typedef NativeDoubleFunction = ffi . Double Function ( ffi . Double ); typedef NativeOpFunction = double Function ( double ); typedef NativeFunction2 = ffi . Void Function ( ffi . Pointer < ffi . Void > , ffi . Int32 ); typedef NativeOpFunction2 = void Function ( ffi . Pointer < ffi . Void > , int ); main () { var dl = ffi . DynamicLibrary . open ( \"test_ffi.dll\" ); NativeOpFunction test_ffi = dl . lookup < ffi . NativeFunction < NativeDoubleFunction >> ( 'mul_2' ) . asFunction (); var res = test_ffi ( 3.0 ); print ( ' $ res ' ); NativeOpFunction2 test_ffi2 = dl . lookup < ffi . NativeFunction < NativeFunction2 >> ( 'inc_u8_vec' ) . asFunction (); Uint8List a8 = Uint8List . fromList ([ 1 , 2 , 3 , 4 ]); print ( ' $ a8 ' ); var pointer = allocate < ffi . Uint8 > ( count: a8 . length ); for ( int i = 0 ; i < a8 . length ; i ++ ){ pointer [ i ] = a8 [ i ]; } final voidP = pointer . cast < ffi . Void > (); test_ffi2 ( voidP , a8 . length ); for ( int i = 0 ; i < a8 . length ; i ++ ){ a8 [ i ] = pointer [ i ]; } print ( ' $ a8 ' ); free ( pointer ); }","title":"Dart"},{"location":"C%20Call/#python","text":"from ctypes import cdll , c_double lib = cdll . LoadLibrary ( \"test_ffi\" ) mul_2 = lib . mul_2 mul_2 . restype = c_double res = mul_2 ( c_double ( 3.0 )) print ( res )","title":"Python"},{"location":"C%20Callable/","text":"C Callable Rust //[lib] //name = \"test_ffi\" //crate-type = [\"cdylib\"] #dynamic library use std :: os :: raw :: c_double ; use std :: os :: raw :: { c_uchar , c_int }; use std :: slice ; #[no_mangle] pub extern \"C\" fn mul_2 ( val : c_double ) -> c_double { val * 2.0 } #[no_mangle] pub extern \"C\" fn inc_u8_vec ( in_vec : * mut c_uchar , len : c_int ) { assert ! ( ! in_vec . is_null (), \"Null pointer in function\" ); let in_vec : & mut [ c_uchar ] = unsafe { slice :: from_raw_parts_mut ( in_vec , len as usize )}; for elem in in_vec { * elem = * elem + 1 ; } }","title":"C Callable"},{"location":"C%20Callable/#c-callable","text":"","title":"C Callable"},{"location":"C%20Callable/#rust","text":"//[lib] //name = \"test_ffi\" //crate-type = [\"cdylib\"] #dynamic library use std :: os :: raw :: c_double ; use std :: os :: raw :: { c_uchar , c_int }; use std :: slice ; #[no_mangle] pub extern \"C\" fn mul_2 ( val : c_double ) -> c_double { val * 2.0 } #[no_mangle] pub extern \"C\" fn inc_u8_vec ( in_vec : * mut c_uchar , len : c_int ) { assert ! ( ! in_vec . is_null (), \"Null pointer in function\" ); let in_vec : & mut [ c_uchar ] = unsafe { slice :: from_raw_parts_mut ( in_vec , len as usize )}; for elem in in_vec { * elem = * elem + 1 ; } }","title":"Rust"},{"location":"CSV/","text":"CSV Dart //dependencies: // csv: ^4.0.3 import 'package:csv/csv.dart' ; import 'dart:io' ; import 'dart:convert' ; main () async { const CSV_PATH = 'tmp001.csv' ; var llWrite = [[ 'FirstName' , 'SecondName' ], [ 'John' , 'Doe' ], [ 'Mark' , 'Smith' ]]; String csv = const ListToCsvConverter ( fieldDelimiter: ' \\t ' ). convert ( llWrite ); var f = File ( CSV_PATH ); var sink = f . openWrite (); sink . write ( csv ); await sink . close (); var input = File ( CSV_PATH ). openRead (); var llRead = await input . transform ( utf8 . decoder ) . transform ( CsvToListConverter ( fieldDelimiter: ' \\t ' )) . toList (); for ( var elem in llRead ) { print ( 'First: ${ elem [ 0 ] } , Second: ${ elem [ 1 ] } ' ); } } Go package main import ( \"encoding/csv\" \"fmt\" \"io\" \"os\" ) func main () { records := [][] string { { \"FirstName\" , \"SecondName\" }, { \"John\" , \"Doe\" }, { \"Mark\" , \"Smith\" }, } fileName := \"tmp001.csv\" file , err := os . Create ( fileName ) if err != nil { fmt . Printf ( \"Can't create %s\\n\" , fileName ) os . Exit ( 0 ) } w := csv . NewWriter ( file ) w . WriteAll ( records ) // calls file . Close () file , err = os . Open ( fileName ) if err != nil { fmt . Printf ( \"Can't open %s\\n\" , fileName ) os . Exit ( 0 ) } defer file . Close () r := csv . NewReader ( file ) for { record , err := r . Read () if err == io . EOF { break } if err != nil { fmt . Println ( \"Record reading error\" ) os . Exit ( 0 ) } fmt . Printf ( \"First: %s, Second: %s\\n\" , record [ 0 ], record [ 1 ]) } } Python import csv CSV_PATH = 'tmp001.csv' with open ( CSV_PATH , 'w' , newline = '' ) as csvfile : wr = csv . writer ( csvfile , delimiter = ' \\t ' ) wr . writerow ([ 'FirstName' , 'SecondName' ]) wr . writerow ([ 'John' , 'Doe' ]) wr . writerow ([ 'Mark' , 'Smith' ]) with open ( CSV_PATH ) as csvfile : rd = csv . reader ( csvfile , delimiter = ' \\t ' ) for rw in rd : print ( f \"First: {rw[0]} , Second: {rw[1]} \" ) Rust //[dependencies] //csv = \"1.1.2\" use csv :: { ReaderBuilder , WriterBuilder }; fn main () { const CSV_PATH : & str = \"tmp001.csv\" ; let mut wtr = WriterBuilder :: new () . delimiter ( b'\\t' ) . quote_style ( csv :: QuoteStyle :: NonNumeric ) . from_path ( CSV_PATH ) . expect ( \"Error opening\" ); //write Header wtr . write_record ( & [ \"FirstName\" , \"SecondName\" ]) . expect ( \"Error writing header\" ); wtr . write_record ( & [ \"John\" , \"Doe\" ]) . expect ( \"Error writing record\" ); wtr . write_record ( & [ \"Mark\" , \"Smith\" ]) . expect ( \"Error writing record\" ); wtr . flush (). expect ( \"Error flushing\" ); let mut rdr = ReaderBuilder :: new () . delimiter ( b'\\t' ) . from_path ( CSV_PATH ) . expect ( \"Error reading CSV\" ); for result in rdr . records () { let record = result . expect ( \"No record\" ); let first : String = match record [ 0 ]. parse () { Ok ( st ) => st , Err ( _ ) => String :: from ( \"\" ), }; let second : String = match record [ 1 ]. parse () { Ok ( st ) => st , Err ( _ ) => String :: from ( \"\" ), }; println ! ( \"First: {}, Second: {}\" , first , second ); } } Rust (with serialization) //[dependencies] //csv = \"1.1.2\" //serde = \"1.0.125\" //serde_derive = \"1.0.125\" use csv :: { ReaderBuilder , WriterBuilder }; use serde_derive :: { Deserialize , Serialize }; #[derive(Debug, Serialize, Deserialize)] struct Record { FirstName : String , SecondName : String , } fn main () { const CSV_PATH : & str = \"tmp001.csv\" ; let mut wtr = WriterBuilder :: new () . delimiter ( b'\\t' ) . quote_style ( csv :: QuoteStyle :: NonNumeric ) . from_path ( CSV_PATH ) . expect ( \"Error opening\" ); //write Header wtr . write_record ( & [ \"FirstName\" , \"SecondName\" ]) . expect ( \"Error writing header\" ); let rec1 = Record { FirstName : \"John\" . to_string (), SecondName : \"Doe\" . to_string (), }; wtr . serialize ( rec1 ). expect ( \"Error writing record\" ); let rec2 = Record { FirstName : \"Mark\" . to_string (), SecondName : \"Smith\" . to_string (), }; wtr . serialize ( rec2 ). expect ( \"Error writing record\" ); wtr . flush (). expect ( \"Error flushing\" ); let mut rdr = ReaderBuilder :: new () . delimiter ( b'\\t' ) . has_headers ( true ) . from_path ( CSV_PATH ) . expect ( \"Error reading CSV\" ); for result in rdr . deserialize () { let record : Record = result . expect ( \"No record\" ); println ! ( \"{:?}\" , record ); } } V (vlang) import encoding . csv import os fn main () { records := [[ \"FirstName\" , \"SecondName\" ], [ \"John\" , \"Doe\" ], [ \"Mark\" , \"Smith\" ]] file_name := \"tmp0.txt\" mut f1 := os . create ( file_name ) or { panic ( \"cannot create $file_name\" )} mut writer := csv . new_writer () for record in records { writer . write ( record ) or {} to_write := writer . str () f1 . write ( to_write . bytes ()) or { panic ( \"cannot write $file_name\" )} } f1 . close () lines := os . read_lines ( file_name ) or { panic ( \"cannot read $file_name\" )} for ind , line in lines { //skip header if ind == 0 { continue } line_nl := \"$line\\n\" mut parser := csv . new_reader ( line_nl ) items := parser . read () or { break } println ( \"First: ${items[0]}, Second: ${items[1]}\" ) } }","title":"CSV"},{"location":"CSV/#csv","text":"","title":"CSV"},{"location":"CSV/#dart","text":"//dependencies: // csv: ^4.0.3 import 'package:csv/csv.dart' ; import 'dart:io' ; import 'dart:convert' ; main () async { const CSV_PATH = 'tmp001.csv' ; var llWrite = [[ 'FirstName' , 'SecondName' ], [ 'John' , 'Doe' ], [ 'Mark' , 'Smith' ]]; String csv = const ListToCsvConverter ( fieldDelimiter: ' \\t ' ). convert ( llWrite ); var f = File ( CSV_PATH ); var sink = f . openWrite (); sink . write ( csv ); await sink . close (); var input = File ( CSV_PATH ). openRead (); var llRead = await input . transform ( utf8 . decoder ) . transform ( CsvToListConverter ( fieldDelimiter: ' \\t ' )) . toList (); for ( var elem in llRead ) { print ( 'First: ${ elem [ 0 ] } , Second: ${ elem [ 1 ] } ' ); } }","title":"Dart"},{"location":"CSV/#go","text":"package main import ( \"encoding/csv\" \"fmt\" \"io\" \"os\" ) func main () { records := [][] string { { \"FirstName\" , \"SecondName\" }, { \"John\" , \"Doe\" }, { \"Mark\" , \"Smith\" }, } fileName := \"tmp001.csv\" file , err := os . Create ( fileName ) if err != nil { fmt . Printf ( \"Can't create %s\\n\" , fileName ) os . Exit ( 0 ) } w := csv . NewWriter ( file ) w . WriteAll ( records ) // calls file . Close () file , err = os . Open ( fileName ) if err != nil { fmt . Printf ( \"Can't open %s\\n\" , fileName ) os . Exit ( 0 ) } defer file . Close () r := csv . NewReader ( file ) for { record , err := r . Read () if err == io . EOF { break } if err != nil { fmt . Println ( \"Record reading error\" ) os . Exit ( 0 ) } fmt . Printf ( \"First: %s, Second: %s\\n\" , record [ 0 ], record [ 1 ]) } }","title":"Go"},{"location":"CSV/#python","text":"import csv CSV_PATH = 'tmp001.csv' with open ( CSV_PATH , 'w' , newline = '' ) as csvfile : wr = csv . writer ( csvfile , delimiter = ' \\t ' ) wr . writerow ([ 'FirstName' , 'SecondName' ]) wr . writerow ([ 'John' , 'Doe' ]) wr . writerow ([ 'Mark' , 'Smith' ]) with open ( CSV_PATH ) as csvfile : rd = csv . reader ( csvfile , delimiter = ' \\t ' ) for rw in rd : print ( f \"First: {rw[0]} , Second: {rw[1]} \" )","title":"Python"},{"location":"CSV/#rust","text":"//[dependencies] //csv = \"1.1.2\" use csv :: { ReaderBuilder , WriterBuilder }; fn main () { const CSV_PATH : & str = \"tmp001.csv\" ; let mut wtr = WriterBuilder :: new () . delimiter ( b'\\t' ) . quote_style ( csv :: QuoteStyle :: NonNumeric ) . from_path ( CSV_PATH ) . expect ( \"Error opening\" ); //write Header wtr . write_record ( & [ \"FirstName\" , \"SecondName\" ]) . expect ( \"Error writing header\" ); wtr . write_record ( & [ \"John\" , \"Doe\" ]) . expect ( \"Error writing record\" ); wtr . write_record ( & [ \"Mark\" , \"Smith\" ]) . expect ( \"Error writing record\" ); wtr . flush (). expect ( \"Error flushing\" ); let mut rdr = ReaderBuilder :: new () . delimiter ( b'\\t' ) . from_path ( CSV_PATH ) . expect ( \"Error reading CSV\" ); for result in rdr . records () { let record = result . expect ( \"No record\" ); let first : String = match record [ 0 ]. parse () { Ok ( st ) => st , Err ( _ ) => String :: from ( \"\" ), }; let second : String = match record [ 1 ]. parse () { Ok ( st ) => st , Err ( _ ) => String :: from ( \"\" ), }; println ! ( \"First: {}, Second: {}\" , first , second ); } }","title":"Rust"},{"location":"CSV/#rust-with-serialization","text":"//[dependencies] //csv = \"1.1.2\" //serde = \"1.0.125\" //serde_derive = \"1.0.125\" use csv :: { ReaderBuilder , WriterBuilder }; use serde_derive :: { Deserialize , Serialize }; #[derive(Debug, Serialize, Deserialize)] struct Record { FirstName : String , SecondName : String , } fn main () { const CSV_PATH : & str = \"tmp001.csv\" ; let mut wtr = WriterBuilder :: new () . delimiter ( b'\\t' ) . quote_style ( csv :: QuoteStyle :: NonNumeric ) . from_path ( CSV_PATH ) . expect ( \"Error opening\" ); //write Header wtr . write_record ( & [ \"FirstName\" , \"SecondName\" ]) . expect ( \"Error writing header\" ); let rec1 = Record { FirstName : \"John\" . to_string (), SecondName : \"Doe\" . to_string (), }; wtr . serialize ( rec1 ). expect ( \"Error writing record\" ); let rec2 = Record { FirstName : \"Mark\" . to_string (), SecondName : \"Smith\" . to_string (), }; wtr . serialize ( rec2 ). expect ( \"Error writing record\" ); wtr . flush (). expect ( \"Error flushing\" ); let mut rdr = ReaderBuilder :: new () . delimiter ( b'\\t' ) . has_headers ( true ) . from_path ( CSV_PATH ) . expect ( \"Error reading CSV\" ); for result in rdr . deserialize () { let record : Record = result . expect ( \"No record\" ); println ! ( \"{:?}\" , record ); } }","title":"Rust (with serialization)"},{"location":"CSV/#v-vlang","text":"import encoding . csv import os fn main () { records := [[ \"FirstName\" , \"SecondName\" ], [ \"John\" , \"Doe\" ], [ \"Mark\" , \"Smith\" ]] file_name := \"tmp0.txt\" mut f1 := os . create ( file_name ) or { panic ( \"cannot create $file_name\" )} mut writer := csv . new_writer () for record in records { writer . write ( record ) or {} to_write := writer . str () f1 . write ( to_write . bytes ()) or { panic ( \"cannot write $file_name\" )} } f1 . close () lines := os . read_lines ( file_name ) or { panic ( \"cannot read $file_name\" )} for ind , line in lines { //skip header if ind == 0 { continue } line_nl := \"$line\\n\" mut parser := csv . new_reader ( line_nl ) items := parser . read () or { break } println ( \"First: ${items[0]}, Second: ${items[1]}\" ) } }","title":"V (vlang)"},{"location":"Channels/","text":"Channels C# Go package main import ( \"fmt\" \"io/ioutil\" \"log\" \"net/http\" ) func main () { fmt . Printf ( \"\\n%d\" , sumPageSizes ()) } func sumPageSizes () int { urls := [] string { \"https://wegmarken2006.github.io/snippets/\" , \"https://wegmarken2006.github.io/snippets/Cross/\" , \"https://wegmarken2006.github.io/snippets/Dict/\" , \"https://wegmarken2006.github.io/snippets/Execution%20time/\" , } var ch = make ( chan int ) for _ , url := range urls { go getTextLen ( url , ch ) } total := 0 respCount := 0 for { select { case ln := <- ch : respCount ++ total = total + ln if respCount == len ( urls ) { return total } } } } func getTextLen ( url string , ch chan int ) { resp , err := http . Get ( url ) if err != nil { log . Fatal ( err ) } defer resp . Body . Close () bodyBytes , _ := ioutil . ReadAll ( resp . Body ) ch <- len ( bodyBytes ) } Rust //[dependencies] //ureq = \"0.11.2\" use std :: io :: Read ; use std :: sync :: mpsc ; use std :: sync :: mpsc :: { Receiver , Sender }; use std :: thread ; fn main () { sum_page_sizes (); } fn sum_page_sizes () { let urls = vec ! [ \"https://wegmarken2006.github.io/snippets/\" , \"https://wegmarken2006.github.io/snippets/Cross/\" , \"https://wegmarken2006.github.io/snippets/Dict/\" , \"https://wegmarken2006.github.io/snippets/Execution%20time/\" , ]; let ( tx , rx ) : ( Sender < usize > , Receiver < usize > ) = mpsc :: channel (); let mut children = Vec :: new (); let urls_len = urls . len (); let mut total = 0 ; for url in urls { let tx_chan = tx . clone (); let child = thread :: spawn ( move || { let resp = ureq :: get ( url ). call (); let status = resp . status (); if status != 500 { let mut buffer = String :: new (); resp . into_reader () . read_to_string ( & mut buffer ) . expect ( \"Reading error\" ); let ln = buffer . len (); tx_chan . send ( ln ). expect ( \"Transmitting error\" ); } else { tx_chan . send ( 0 ). expect ( \"Transmitting error\" ); } }); children . push ( child ); } //Receive messages for _ in 0 .. urls_len { total = total + rx . recv (). expect ( \"Receiving error\" ); } // Wait for the threads to complete any remaining work for child in children { child . join (). expect ( \"Join error\" ); } println ! ( \"{}\" , total ); } V (vlang) import net . http fn main () { sizes := sum_page_sizes () print ( \"\\n$sizes\" ) } fn sum_page_sizes () int { mut urls := [] string {} urls = [ \"https://wegmarken2006.github.io/snippets/\" , \"https://wegmarken2006.github.io/snippets/Cross/\" , \"https://wegmarken2006.github.io/snippets/Dict/\" , \"https://wegmarken2006.github.io/snippets/Execution%20time/\" , ] ch := chan int {} for _ , url in urls { go get_text_len ( url , ch ) } mut total := 0 mut resp_count := 0 for { select { ln := <- ch { resp_count ++ total = total + ln if resp_count == urls . len { return total } } } } return total } fn get_text_len ( url string , ch chan int ) { resp := http . get ( url ) or { panic ( \"get error $err\" )} //close? ch <- resp . body . len }","title":"Channels"},{"location":"Channels/#channels","text":"","title":"Channels"},{"location":"Channels/#c","text":"","title":"C#"},{"location":"Channels/#go","text":"package main import ( \"fmt\" \"io/ioutil\" \"log\" \"net/http\" ) func main () { fmt . Printf ( \"\\n%d\" , sumPageSizes ()) } func sumPageSizes () int { urls := [] string { \"https://wegmarken2006.github.io/snippets/\" , \"https://wegmarken2006.github.io/snippets/Cross/\" , \"https://wegmarken2006.github.io/snippets/Dict/\" , \"https://wegmarken2006.github.io/snippets/Execution%20time/\" , } var ch = make ( chan int ) for _ , url := range urls { go getTextLen ( url , ch ) } total := 0 respCount := 0 for { select { case ln := <- ch : respCount ++ total = total + ln if respCount == len ( urls ) { return total } } } } func getTextLen ( url string , ch chan int ) { resp , err := http . Get ( url ) if err != nil { log . Fatal ( err ) } defer resp . Body . Close () bodyBytes , _ := ioutil . ReadAll ( resp . Body ) ch <- len ( bodyBytes ) }","title":"Go"},{"location":"Channels/#rust","text":"//[dependencies] //ureq = \"0.11.2\" use std :: io :: Read ; use std :: sync :: mpsc ; use std :: sync :: mpsc :: { Receiver , Sender }; use std :: thread ; fn main () { sum_page_sizes (); } fn sum_page_sizes () { let urls = vec ! [ \"https://wegmarken2006.github.io/snippets/\" , \"https://wegmarken2006.github.io/snippets/Cross/\" , \"https://wegmarken2006.github.io/snippets/Dict/\" , \"https://wegmarken2006.github.io/snippets/Execution%20time/\" , ]; let ( tx , rx ) : ( Sender < usize > , Receiver < usize > ) = mpsc :: channel (); let mut children = Vec :: new (); let urls_len = urls . len (); let mut total = 0 ; for url in urls { let tx_chan = tx . clone (); let child = thread :: spawn ( move || { let resp = ureq :: get ( url ). call (); let status = resp . status (); if status != 500 { let mut buffer = String :: new (); resp . into_reader () . read_to_string ( & mut buffer ) . expect ( \"Reading error\" ); let ln = buffer . len (); tx_chan . send ( ln ). expect ( \"Transmitting error\" ); } else { tx_chan . send ( 0 ). expect ( \"Transmitting error\" ); } }); children . push ( child ); } //Receive messages for _ in 0 .. urls_len { total = total + rx . recv (). expect ( \"Receiving error\" ); } // Wait for the threads to complete any remaining work for child in children { child . join (). expect ( \"Join error\" ); } println ! ( \"{}\" , total ); }","title":"Rust"},{"location":"Channels/#v-vlang","text":"import net . http fn main () { sizes := sum_page_sizes () print ( \"\\n$sizes\" ) } fn sum_page_sizes () int { mut urls := [] string {} urls = [ \"https://wegmarken2006.github.io/snippets/\" , \"https://wegmarken2006.github.io/snippets/Cross/\" , \"https://wegmarken2006.github.io/snippets/Dict/\" , \"https://wegmarken2006.github.io/snippets/Execution%20time/\" , ] ch := chan int {} for _ , url in urls { go get_text_len ( url , ch ) } mut total := 0 mut resp_count := 0 for { select { ln := <- ch { resp_count ++ total = total + ln if resp_count == urls . len { return total } } } } return total } fn get_text_len ( url string , ch chan int ) { resp := http . get ( url ) or { panic ( \"get error $err\" )} //close? ch <- resp . body . len }","title":"V (vlang)"},{"location":"Charts/","text":"Charts Go //go.mode //require github.com/go-echarts/go-echarts/v2 v2.2.4 package main import ( \"fmt\" \"math\" \"os\" \"github.com/go-echarts/go-echarts/v2/charts\" \"github.com/go-echarts/go-echarts/v2/opts\" ) func main () { var yLineVals [] opts . LineData var yBarVals [] opts . BarData var xVals [] string //prepare data for ind := - 314 ; ind <= 314 ; ind += 10 { xVals = append ( xVals , fmt . Sprintf ( \"%d\" , ind )) yLineVals = append ( yLineVals , opts . LineData { Value : math . Sin ( float64 ( ind ) / 100. )}) yBarVals = append ( yBarVals , opts . BarData { Value : math . Sin ( float64 ( ind ) / 100. )}) } line := charts . NewLine () line . SetGlobalOptions ( charts . WithXAxisOpts ( opts . XAxis { Name : \"X\" }), charts . WithYAxisOpts ( opts . YAxis { Name : \"Sin(x)\" }), charts . WithTitleOpts ( opts . Title { Title : \"Sin(x)\" , Subtitle : \"\" , })) line . SetXAxis ( xVals ). AddSeries ( \"Sin(x)\" , yLineVals ) f , _ := os . Create ( \"line.html\" ) line . Render ( f ) bar := charts . NewBar () bar . SetGlobalOptions ( charts . WithTitleOpts ( opts . Title { Title : \"Sin(x)\" , Subtitle : \"\" , })) bar . SetXAxis ( xVals ). AddSeries ( \"Sin(x)\" , yBarVals ) g , _ := os . Create ( \"bar.html\" ) bar . Render ( g ) } Rust //[dependencies] //plotters = \"0.2.12\" use plotters :: prelude :: * ; fn main () { let root = BitMapBackend :: new ( \"tmp0.png\" , ( 640 , 480 )). into_drawing_area (); root . fill ( & WHITE ). unwrap (); let mut chart = ChartBuilder :: on ( & root ) . caption ( \"y=sin2(x)\" , ( \"sans-serif\" , 50 ). into_font ()) . margin ( 5 ) . x_label_area_size ( 30 ) . y_label_area_size ( 30 ) . build_ranged ( - 4 f32 .. 4 f32 , - 1 f32 .. 1 f32 ) . unwrap (); chart . configure_mesh (). draw (). unwrap (); let x_list = ( - 314 .. 314 ). step_by ( 10 ); let x_list_f = x_list . map ( | x | x as f32 / 100.0 ). map ( | x | ( x , x . sin ())); //let xx = (-50..=50).map(|x| x as f32 / 50.0).map(|x| (x, x * x)); chart . draw_series ( LineSeries :: new ( x_list_f , & RED )) . unwrap () . label ( \"y = sin(x)\" ) . legend ( | ( x , y ) | PathElement :: new ( vec ! [( x , y ), ( x + 20 , y )], & RED )); chart . configure_series_labels () . background_style ( & WHITE . mix ( 0.8 )) . border_style ( & BLACK ) . draw () . unwrap (); } Typescript //npm install --save plotly.js-dist //npm install --save @types/plotly.js //browserify hello.js -o hello2.js import * as Plotly from 'plotly.js-dist' ; function range ( start , end , step ) { var ans = []; for ( let i = start ; i <= end ; i = i + step ) { ans . push ( i ); } return ans ; } let x = range ( - 314 , 314 , 10 ); let y = x . map (( x ) => Math . sin ( x / 100 .)); var trace1 : Partial < Plotly . PlotData > = { x : x , y : y , name : 'Sine' , type : '' }; var data : Partial < Plotly . PlotData > [] = [ trace1 ]; var layout : Partial < Plotly . Layout > = { yaxis : { 'title' : 'sin(x)' } }; Plotly . newPlot ( 'myDiv' , data , layout ); <!-- hello2.html --> < head > < meta charset = \"utf-8\" > </ head > < body > < div id = \"myDiv\" ></ div > </ body > < script src = \"hello2.js\" ></ script >","title":"Charts"},{"location":"Charts/#charts","text":"","title":"Charts"},{"location":"Charts/#go","text":"//go.mode //require github.com/go-echarts/go-echarts/v2 v2.2.4 package main import ( \"fmt\" \"math\" \"os\" \"github.com/go-echarts/go-echarts/v2/charts\" \"github.com/go-echarts/go-echarts/v2/opts\" ) func main () { var yLineVals [] opts . LineData var yBarVals [] opts . BarData var xVals [] string //prepare data for ind := - 314 ; ind <= 314 ; ind += 10 { xVals = append ( xVals , fmt . Sprintf ( \"%d\" , ind )) yLineVals = append ( yLineVals , opts . LineData { Value : math . Sin ( float64 ( ind ) / 100. )}) yBarVals = append ( yBarVals , opts . BarData { Value : math . Sin ( float64 ( ind ) / 100. )}) } line := charts . NewLine () line . SetGlobalOptions ( charts . WithXAxisOpts ( opts . XAxis { Name : \"X\" }), charts . WithYAxisOpts ( opts . YAxis { Name : \"Sin(x)\" }), charts . WithTitleOpts ( opts . Title { Title : \"Sin(x)\" , Subtitle : \"\" , })) line . SetXAxis ( xVals ). AddSeries ( \"Sin(x)\" , yLineVals ) f , _ := os . Create ( \"line.html\" ) line . Render ( f ) bar := charts . NewBar () bar . SetGlobalOptions ( charts . WithTitleOpts ( opts . Title { Title : \"Sin(x)\" , Subtitle : \"\" , })) bar . SetXAxis ( xVals ). AddSeries ( \"Sin(x)\" , yBarVals ) g , _ := os . Create ( \"bar.html\" ) bar . Render ( g ) }","title":"Go"},{"location":"Charts/#rust","text":"//[dependencies] //plotters = \"0.2.12\" use plotters :: prelude :: * ; fn main () { let root = BitMapBackend :: new ( \"tmp0.png\" , ( 640 , 480 )). into_drawing_area (); root . fill ( & WHITE ). unwrap (); let mut chart = ChartBuilder :: on ( & root ) . caption ( \"y=sin2(x)\" , ( \"sans-serif\" , 50 ). into_font ()) . margin ( 5 ) . x_label_area_size ( 30 ) . y_label_area_size ( 30 ) . build_ranged ( - 4 f32 .. 4 f32 , - 1 f32 .. 1 f32 ) . unwrap (); chart . configure_mesh (). draw (). unwrap (); let x_list = ( - 314 .. 314 ). step_by ( 10 ); let x_list_f = x_list . map ( | x | x as f32 / 100.0 ). map ( | x | ( x , x . sin ())); //let xx = (-50..=50).map(|x| x as f32 / 50.0).map(|x| (x, x * x)); chart . draw_series ( LineSeries :: new ( x_list_f , & RED )) . unwrap () . label ( \"y = sin(x)\" ) . legend ( | ( x , y ) | PathElement :: new ( vec ! [( x , y ), ( x + 20 , y )], & RED )); chart . configure_series_labels () . background_style ( & WHITE . mix ( 0.8 )) . border_style ( & BLACK ) . draw () . unwrap (); }","title":"Rust"},{"location":"Charts/#typescript","text":"//npm install --save plotly.js-dist //npm install --save @types/plotly.js //browserify hello.js -o hello2.js import * as Plotly from 'plotly.js-dist' ; function range ( start , end , step ) { var ans = []; for ( let i = start ; i <= end ; i = i + step ) { ans . push ( i ); } return ans ; } let x = range ( - 314 , 314 , 10 ); let y = x . map (( x ) => Math . sin ( x / 100 .)); var trace1 : Partial < Plotly . PlotData > = { x : x , y : y , name : 'Sine' , type : '' }; var data : Partial < Plotly . PlotData > [] = [ trace1 ]; var layout : Partial < Plotly . Layout > = { yaxis : { 'title' : 'sin(x)' } }; Plotly . newPlot ( 'myDiv' , data , layout ); <!-- hello2.html --> < head > < meta charset = \"utf-8\" > </ head > < body > < div id = \"myDiv\" ></ div > </ body > < script src = \"hello2.js\" ></ script >","title":"Typescript"},{"location":"Conversions/","text":"Conversions Go package main import ( \"bytes\" \"encoding/binary\" . \"fmt\" ) func main () { b1 := i32_to_bytes ( 112 ) i1 := bytes_to_i32 ( b1 ) Println ( i1 ) //string to bytes, bytes to string s2 := \"113.45\" b2 := [] byte ( s2 ) s2b := string ( b2 ) Println ( s2b ) //int to string, string to int s3 := Sprintf ( \"%d\" , 114 ) var i3 int32 Sscanf ( s3 , \"%d\" , & i3 ) Println ( i3 ) b4 := f32_to_bytes ( 115.67 ) f4 := bytes_to_f32 ( b4 ) Println ( f4 ) } func i32_to_bytes ( num int32 ) [] byte { b1 := new ( bytes . Buffer ) binary . Write ( b1 , binary . LittleEndian , uint32 ( num )) return b1 . Bytes () } func bytes_to_i32 ( b1 [] byte ) int32 { bb1 := bytes . NewBuffer ( b1 ) var i1 int32 binary . Read ( bb1 , binary . LittleEndian , & i1 ) return i1 } func f32_to_bytes ( num float32 ) [] byte { b1 := new ( bytes . Buffer ) binary . Write ( b1 , binary . LittleEndian , float64 ( num )) return b1 . Bytes () } func bytes_to_f32 ( b1 [] byte ) float32 { bb1 := bytes . NewBuffer ( b1 ) var f1 float64 binary . Read ( bb1 , binary . LittleEndian , & f1 ) return float32 ( f1 ) } Rust use std :: { str }; fn main () { let v1 = i32_to_bytes ( 112 ); let i1 = bytes_to_i32 ( & v1 ); println ! ( \"{}\" , i1 ); let v2 = str_to_bytes ( & String :: from ( \"113.45\" )); let s2 = bytes_to_str ( & v2 ); println ! ( \"{}\" , s2 ); let s3 = i32_to_str ( 114 ); let i3 = str_to_i32 ( & s3 ); println ! ( \"{}\" , i3 ); let v4 = f32_to_bytes ( 115.67 ); let f4 = bytes_to_f32 ( v4 ); println ! ( \"{:?}\" , f4 ); } fn i32_to_bytes ( num : i32 ) -> Vec < u8 > { let n1 = ( num & 0xff ) as u8 ; let n2 = (( num >> 8 ) & 0xff ) as u8 ; let n3 = (( num >> 16 ) & 0xff ) as u8 ; let n4 = (( num >> 24 ) & 0xff ) as u8 ; vec ! [ n4 , n3 , n2 , n1 ] } fn bytes_to_i32 ( buf : & Vec < u8 > ) -> i32 { let n1 : u32 = ( buf [ 0 ] as u32 ) << 8 ; let n2 : u32 = ( buf [ 1 ] as u32 ) << 16 ; let n3 : u32 = ( buf [ 2 ] as u32 ) << 24 ; let num = buf [ 3 ] as u32 | n3 | n2 | n1 ; num as i32 } fn f32_to_bytes ( num : f32 ) -> [ u8 ; 4 ] { num . to_be_bytes () } fn bytes_to_f32 ( buf : [ u8 ; 4 ]) -> f32 { f32 :: from_be_bytes ( buf ) } fn str_to_bytes ( str1 : & String ) -> Vec < u8 > { let bb = str1 . clone (). into_bytes (); bb } fn bytes_to_str ( buf : & Vec < u8 > ) -> & str { str :: from_utf8 ( buf ). unwrap () } fn str_to_i32 ( str1 : & String ) -> i32 { str1 . parse :: < i32 > (). unwrap () } fn i32_to_str ( num : i32 ) -> String { format ! ( \"{}\" , num ) }","title":"Conversions"},{"location":"Conversions/#conversions","text":"","title":"Conversions"},{"location":"Conversions/#go","text":"package main import ( \"bytes\" \"encoding/binary\" . \"fmt\" ) func main () { b1 := i32_to_bytes ( 112 ) i1 := bytes_to_i32 ( b1 ) Println ( i1 ) //string to bytes, bytes to string s2 := \"113.45\" b2 := [] byte ( s2 ) s2b := string ( b2 ) Println ( s2b ) //int to string, string to int s3 := Sprintf ( \"%d\" , 114 ) var i3 int32 Sscanf ( s3 , \"%d\" , & i3 ) Println ( i3 ) b4 := f32_to_bytes ( 115.67 ) f4 := bytes_to_f32 ( b4 ) Println ( f4 ) } func i32_to_bytes ( num int32 ) [] byte { b1 := new ( bytes . Buffer ) binary . Write ( b1 , binary . LittleEndian , uint32 ( num )) return b1 . Bytes () } func bytes_to_i32 ( b1 [] byte ) int32 { bb1 := bytes . NewBuffer ( b1 ) var i1 int32 binary . Read ( bb1 , binary . LittleEndian , & i1 ) return i1 } func f32_to_bytes ( num float32 ) [] byte { b1 := new ( bytes . Buffer ) binary . Write ( b1 , binary . LittleEndian , float64 ( num )) return b1 . Bytes () } func bytes_to_f32 ( b1 [] byte ) float32 { bb1 := bytes . NewBuffer ( b1 ) var f1 float64 binary . Read ( bb1 , binary . LittleEndian , & f1 ) return float32 ( f1 ) }","title":"Go"},{"location":"Conversions/#rust","text":"use std :: { str }; fn main () { let v1 = i32_to_bytes ( 112 ); let i1 = bytes_to_i32 ( & v1 ); println ! ( \"{}\" , i1 ); let v2 = str_to_bytes ( & String :: from ( \"113.45\" )); let s2 = bytes_to_str ( & v2 ); println ! ( \"{}\" , s2 ); let s3 = i32_to_str ( 114 ); let i3 = str_to_i32 ( & s3 ); println ! ( \"{}\" , i3 ); let v4 = f32_to_bytes ( 115.67 ); let f4 = bytes_to_f32 ( v4 ); println ! ( \"{:?}\" , f4 ); } fn i32_to_bytes ( num : i32 ) -> Vec < u8 > { let n1 = ( num & 0xff ) as u8 ; let n2 = (( num >> 8 ) & 0xff ) as u8 ; let n3 = (( num >> 16 ) & 0xff ) as u8 ; let n4 = (( num >> 24 ) & 0xff ) as u8 ; vec ! [ n4 , n3 , n2 , n1 ] } fn bytes_to_i32 ( buf : & Vec < u8 > ) -> i32 { let n1 : u32 = ( buf [ 0 ] as u32 ) << 8 ; let n2 : u32 = ( buf [ 1 ] as u32 ) << 16 ; let n3 : u32 = ( buf [ 2 ] as u32 ) << 24 ; let num = buf [ 3 ] as u32 | n3 | n2 | n1 ; num as i32 } fn f32_to_bytes ( num : f32 ) -> [ u8 ; 4 ] { num . to_be_bytes () } fn bytes_to_f32 ( buf : [ u8 ; 4 ]) -> f32 { f32 :: from_be_bytes ( buf ) } fn str_to_bytes ( str1 : & String ) -> Vec < u8 > { let bb = str1 . clone (). into_bytes (); bb } fn bytes_to_str ( buf : & Vec < u8 > ) -> & str { str :: from_utf8 ( buf ). unwrap () } fn str_to_i32 ( str1 : & String ) -> i32 { str1 . parse :: < i32 > (). unwrap () } fn i32_to_str ( num : i32 ) -> String { format ! ( \"{}\" , num ) }","title":"Rust"},{"location":"Cross/","text":"Cross Compilation C# dotnet publish -c Release -r linux-arm64 --self-contained true Go On windows: set GOOS=linux set GOARCH=arm64 go build Rust rustup target add mips-unknown-linux-gnu rustup target add aarch64-linux-gnu-gcc On linux, edit .cargo/config: [target.mips-unknown-linux-gnu] linker = \"mips-linux-gnu-gcc\" [target.aarch64-unknown-linux-gnu] linker = \"aarch64-linux-gnu-gcc\" To compile, run: cargo build --target=\"aarch64-linux-gnu-gcc \"","title":"Cross Compilation"},{"location":"Cross/#cross-compilation","text":"","title":"Cross Compilation"},{"location":"Cross/#c","text":"dotnet publish -c Release -r linux-arm64 --self-contained true","title":"C#"},{"location":"Cross/#go","text":"On windows: set GOOS=linux set GOARCH=arm64 go build","title":"Go"},{"location":"Cross/#rust","text":"rustup target add mips-unknown-linux-gnu rustup target add aarch64-linux-gnu-gcc On linux, edit .cargo/config: [target.mips-unknown-linux-gnu] linker = \"mips-linux-gnu-gcc\" [target.aarch64-unknown-linux-gnu] linker = \"aarch64-linux-gnu-gcc\" To compile, run: cargo build --target=\"aarch64-linux-gnu-gcc \"","title":"Rust"},{"location":"DateTime/","text":"Date & Time Dart //dependencies: // intl: ^0.16.1 import 'package:intl/intl.dart' ; main () async { var today = DateTime . now (); // from date to string var today_str = DateFormat ( 'yyyy-MM-dd**kk:mm:ss' ). format ( today ); var date_str = DateFormat ( 'dd-MM-yyyy' ). format ( today ); var time_str = DateFormat ( 'kk:mm' ). format ( today ); // from string to date var today2 = DateFormat ( 'yyyy-MM-dd**kk:mm:ss' ). parse ( today_str ); var hour = today . hour ; var minute = today . minute ; var day = today . day ; var month = today . month ; var year = today . year ; // weekday var days_of_week = [ \"sun\" , \"mon\" , \"tue\" , \"wed\" , \"thu\" , \"fry\" , \"sat\" ]; var weekday = days_of_week [ today . weekday ]; var tomorrow = today . add ( Duration ( days: 1 )); // difference between dates var next_week = today . add ( Duration ( days: 7 )); var delta_w = next_week . difference ( today ). inDays ; var next_year = today . add ( Duration ( days: 366 )); var n_year = next_year . year ; var delta_y = n_year - year ; print ( today ); print ( today_str ); print ( ' $ day - $ month - $ year $ hour : $ minute ' ); print ( date_str ); print ( time_str ); print ( today2 ); print ( weekday ); print ( tomorrow ); print ( delta_w ); print ( delta_y ); } Go package main import ( \"fmt\" \"time\" ) func main () { today := time . Now () year := today . Year () month := today . Month () day := today . Day () hour := today . Hour () minute := today . Minute () second := today . Second () // from date to string todayStr := fmt . Sprintf ( \"%d-%02d-%02d**%02d:%02d:%02d\" , year , month , day , hour , minute , second ) dateStr := today . Format ( \"2006-01-02\" ) timeStr := today . Format ( \"15:04:05\" ) // from string to date today2 , _ := time . Parse ( \"2006-01-02**15:04:05\" , todayStr ) // weekday weekday := today . Weekday () tomorrow := today . AddDate ( 0 , 0 , 1 ) // difference between dates nextWeek := today . AddDate ( 0 , 0 , 7 ) deltaW := nextWeek . Sub ( today ). Hours () / 24 nextYear := today . AddDate ( 1 , 0 , 0 ) nYear := nextYear . Year () deltaY := nYear - year fmt . Printf ( \"%v\\n\" , today ) fmt . Printf ( \"%v\\n\" , todayStr ) fmt . Printf ( \"%v\\n\" , dateStr ) fmt . Printf ( \"%v\\n\" , timeStr ) fmt . Printf ( \"%v\\n\" , today2 ) fmt . Printf ( \"%v\\n\" , weekday ) fmt . Printf ( \"%v\\n\" , tomorrow ) fmt . Printf ( \"%v\\n\" , deltaW ) fmt . Printf ( \"%v\\n\" , deltaY ) } Python import datetime as dt from dateutil import relativedelta today = dt . datetime . today () # from date to string today_str = dt . datetime . strftime ( today , '%Y-%m- %d **%H:%M:%S' ) date_str = dt . datetime . strftime ( today , ' %d -%m-%Y' ) time_str = dt . datetime . strftime ( today , '%H:%M' ) # from string to date today2 = dt . datetime . strptime ( today_str , '%Y-%m- %d **%H:%M:%S' ) hour = today . hour minute = today . minute day = today . day month = today . month year = today . year # weekday days_of_week = [ \"mon\" , \"tue\" , \"wed\" , \"thu\" , \"fry\" , \"sat\" , \"sun\" ] weekday = days_of_week [ today . weekday ()] tomorrow = today + dt . timedelta ( days = 1 ) tomorrow_str = dt . datetime . strftime ( tomorrow , ' %d -%m-%Y' ) # difference between dates next_week = today + dt . timedelta ( days = 7 ) delta_w = ( next_week - today ) . days next_year = today + dt . timedelta ( days = 366 ) delta_y = ( relativedelta . relativedelta ( next_year , today )) . years print ( today ) print ( today_str ) print ( f ' {day} - {month} - {year} {hour} : {minute} ' ) print ( date_str ) print ( time_str ) print ( today2 ) print ( weekday ) print ( tomorrow_str ) print ( delta_w ) print ( delta_y ) Rust // chrono = \"*\" use chrono :: { Datelike , Duration , NaiveDateTime , Timelike , Utc }; fn main () { let today = Utc :: now (); //from date to string let today_str = format ! ( \"{}\" , today . format ( \"%Y-%m-%d**%H:%M:%S\" )); let date_str = format ! ( \"{}\" , today . format ( \"%d-%m-%Y\" )); let time_str = format ! ( \"{}\" , today . format ( \"%H:%M\" )); // from string to date let today2 = NaiveDateTime :: parse_from_str ( & today_str , \"%Y-%m-%d**%H:%M:%S\" ). expect ( \"Error parse\" ); let hour = today . hour (); let minute = today . minute (); let day = today . day (); let month = today . month (); let year = today . year (); // weekday let weekday = today . weekday (); let tomorrow = today + Duration :: days ( 1 ); let tomorrow_str = format ! ( \"{}\" , tomorrow . format ( \"%d-%m-%Y\" )); // difference between dates let next_week = today + Duration :: days ( 7 ); let delta_w = next_week . signed_duration_since ( today ). num_days (); let next_year = today + Duration :: days ( 366 ); let nyear = next_year . year (); let delta_y = nyear - year ; println ! ( \"{:?}\" , today ); println ! ( \"{}\" , today_str ); println ! ( \"{}-{}-{} {}:{}\" , day , month , year , hour , minute ); println ! ( \"{}\" , date_str ); println ! ( \"{}\" , time_str ); println ! ( \"{}\" , today2 ); println ! ( \"{}\" , weekday ); println ! ( \"{}\" , tomorrow_str ); println ! ( \"{}\" , delta_w ); println ! ( \"{}\" , delta_y ); } V (vlang) import time fn main () { today := time . now () year := today . year month := today . month day := today . day hour := today . hour minute := today . minute second := today . second // from date to string today_str := \"$year-${month:02}-${day:02} ${hour:02}:${minute:02}:${second:02}\" date_str := today . get_fmt_date_str ( time . FormatDelimiter . hyphen , time . FormatDate . yyyymmdd ) time_str := today . get_fmt_time_str ( time . FormatTime . hhmmss24 ) // from string to date today2 := time . parse ( today_str ) or { panic ( \"Parse error $err\" )} today2_str := today2 . str () weekday_str := today . weekday_str () tomorrow := today . add_days ( 1 ) tomorrow_str := tomorrow . str () // difference between dates next_week := today . add_days ( 7 ) delta_w := next_week - today delta_d := delta_w . hours () / 24.0 mut days_per_year := 365 if time . is_leap_year ( year ) { days_per_year = 366 } next_year := today . add_days ( days_per_year ) n_year := next_year . year delta_y := n_year - year println ( today_str ) println ( date_str ) println ( time_str ) println ( today2_str ) println ( weekday_str ) println ( tomorrow_str ) println ( delta_d ) println ( delta_y ) }","title":"Date & Time"},{"location":"DateTime/#date-time","text":"","title":"Date &amp; Time"},{"location":"DateTime/#dart","text":"//dependencies: // intl: ^0.16.1 import 'package:intl/intl.dart' ; main () async { var today = DateTime . now (); // from date to string var today_str = DateFormat ( 'yyyy-MM-dd**kk:mm:ss' ). format ( today ); var date_str = DateFormat ( 'dd-MM-yyyy' ). format ( today ); var time_str = DateFormat ( 'kk:mm' ). format ( today ); // from string to date var today2 = DateFormat ( 'yyyy-MM-dd**kk:mm:ss' ). parse ( today_str ); var hour = today . hour ; var minute = today . minute ; var day = today . day ; var month = today . month ; var year = today . year ; // weekday var days_of_week = [ \"sun\" , \"mon\" , \"tue\" , \"wed\" , \"thu\" , \"fry\" , \"sat\" ]; var weekday = days_of_week [ today . weekday ]; var tomorrow = today . add ( Duration ( days: 1 )); // difference between dates var next_week = today . add ( Duration ( days: 7 )); var delta_w = next_week . difference ( today ). inDays ; var next_year = today . add ( Duration ( days: 366 )); var n_year = next_year . year ; var delta_y = n_year - year ; print ( today ); print ( today_str ); print ( ' $ day - $ month - $ year $ hour : $ minute ' ); print ( date_str ); print ( time_str ); print ( today2 ); print ( weekday ); print ( tomorrow ); print ( delta_w ); print ( delta_y ); }","title":"Dart"},{"location":"DateTime/#go","text":"package main import ( \"fmt\" \"time\" ) func main () { today := time . Now () year := today . Year () month := today . Month () day := today . Day () hour := today . Hour () minute := today . Minute () second := today . Second () // from date to string todayStr := fmt . Sprintf ( \"%d-%02d-%02d**%02d:%02d:%02d\" , year , month , day , hour , minute , second ) dateStr := today . Format ( \"2006-01-02\" ) timeStr := today . Format ( \"15:04:05\" ) // from string to date today2 , _ := time . Parse ( \"2006-01-02**15:04:05\" , todayStr ) // weekday weekday := today . Weekday () tomorrow := today . AddDate ( 0 , 0 , 1 ) // difference between dates nextWeek := today . AddDate ( 0 , 0 , 7 ) deltaW := nextWeek . Sub ( today ). Hours () / 24 nextYear := today . AddDate ( 1 , 0 , 0 ) nYear := nextYear . Year () deltaY := nYear - year fmt . Printf ( \"%v\\n\" , today ) fmt . Printf ( \"%v\\n\" , todayStr ) fmt . Printf ( \"%v\\n\" , dateStr ) fmt . Printf ( \"%v\\n\" , timeStr ) fmt . Printf ( \"%v\\n\" , today2 ) fmt . Printf ( \"%v\\n\" , weekday ) fmt . Printf ( \"%v\\n\" , tomorrow ) fmt . Printf ( \"%v\\n\" , deltaW ) fmt . Printf ( \"%v\\n\" , deltaY ) }","title":"Go"},{"location":"DateTime/#python","text":"import datetime as dt from dateutil import relativedelta today = dt . datetime . today () # from date to string today_str = dt . datetime . strftime ( today , '%Y-%m- %d **%H:%M:%S' ) date_str = dt . datetime . strftime ( today , ' %d -%m-%Y' ) time_str = dt . datetime . strftime ( today , '%H:%M' ) # from string to date today2 = dt . datetime . strptime ( today_str , '%Y-%m- %d **%H:%M:%S' ) hour = today . hour minute = today . minute day = today . day month = today . month year = today . year # weekday days_of_week = [ \"mon\" , \"tue\" , \"wed\" , \"thu\" , \"fry\" , \"sat\" , \"sun\" ] weekday = days_of_week [ today . weekday ()] tomorrow = today + dt . timedelta ( days = 1 ) tomorrow_str = dt . datetime . strftime ( tomorrow , ' %d -%m-%Y' ) # difference between dates next_week = today + dt . timedelta ( days = 7 ) delta_w = ( next_week - today ) . days next_year = today + dt . timedelta ( days = 366 ) delta_y = ( relativedelta . relativedelta ( next_year , today )) . years print ( today ) print ( today_str ) print ( f ' {day} - {month} - {year} {hour} : {minute} ' ) print ( date_str ) print ( time_str ) print ( today2 ) print ( weekday ) print ( tomorrow_str ) print ( delta_w ) print ( delta_y )","title":"Python"},{"location":"DateTime/#rust","text":"// chrono = \"*\" use chrono :: { Datelike , Duration , NaiveDateTime , Timelike , Utc }; fn main () { let today = Utc :: now (); //from date to string let today_str = format ! ( \"{}\" , today . format ( \"%Y-%m-%d**%H:%M:%S\" )); let date_str = format ! ( \"{}\" , today . format ( \"%d-%m-%Y\" )); let time_str = format ! ( \"{}\" , today . format ( \"%H:%M\" )); // from string to date let today2 = NaiveDateTime :: parse_from_str ( & today_str , \"%Y-%m-%d**%H:%M:%S\" ). expect ( \"Error parse\" ); let hour = today . hour (); let minute = today . minute (); let day = today . day (); let month = today . month (); let year = today . year (); // weekday let weekday = today . weekday (); let tomorrow = today + Duration :: days ( 1 ); let tomorrow_str = format ! ( \"{}\" , tomorrow . format ( \"%d-%m-%Y\" )); // difference between dates let next_week = today + Duration :: days ( 7 ); let delta_w = next_week . signed_duration_since ( today ). num_days (); let next_year = today + Duration :: days ( 366 ); let nyear = next_year . year (); let delta_y = nyear - year ; println ! ( \"{:?}\" , today ); println ! ( \"{}\" , today_str ); println ! ( \"{}-{}-{} {}:{}\" , day , month , year , hour , minute ); println ! ( \"{}\" , date_str ); println ! ( \"{}\" , time_str ); println ! ( \"{}\" , today2 ); println ! ( \"{}\" , weekday ); println ! ( \"{}\" , tomorrow_str ); println ! ( \"{}\" , delta_w ); println ! ( \"{}\" , delta_y ); }","title":"Rust"},{"location":"DateTime/#v-vlang","text":"import time fn main () { today := time . now () year := today . year month := today . month day := today . day hour := today . hour minute := today . minute second := today . second // from date to string today_str := \"$year-${month:02}-${day:02} ${hour:02}:${minute:02}:${second:02}\" date_str := today . get_fmt_date_str ( time . FormatDelimiter . hyphen , time . FormatDate . yyyymmdd ) time_str := today . get_fmt_time_str ( time . FormatTime . hhmmss24 ) // from string to date today2 := time . parse ( today_str ) or { panic ( \"Parse error $err\" )} today2_str := today2 . str () weekday_str := today . weekday_str () tomorrow := today . add_days ( 1 ) tomorrow_str := tomorrow . str () // difference between dates next_week := today . add_days ( 7 ) delta_w := next_week - today delta_d := delta_w . hours () / 24.0 mut days_per_year := 365 if time . is_leap_year ( year ) { days_per_year = 366 } next_year := today . add_days ( days_per_year ) n_year := next_year . year delta_y := n_year - year println ( today_str ) println ( date_str ) println ( time_str ) println ( today2_str ) println ( weekday_str ) println ( tomorrow_str ) println ( delta_d ) println ( delta_y ) }","title":"V (vlang)"},{"location":"Dict/","text":"Dictionary C# using System ; using System.Collections.Generic ; using System.Linq ; public class Program { public static void Main ( string [] args ) { //count words var wordList = new List < string > { \"glass\" , \"table\" , \"chair\" , \"chair\" }; var words = new Dictionary < string , int >(); foreach ( var item in wordList ) { if ( words . ContainsKey ( item )) { words [ item ] = ( int ) words [ item ] + 1 ; } else { words . Add ( item , 1 ); } } Console . WriteLine (); foreach ( var item in words ) { Console . Write ( \"{0}:{1} \" , item . Key , item . Value ); } Console . WriteLine (); var sorted = words . OrderBy ( x => - x . Value ); foreach ( var item in sorted ) { Console . Write ( \"{0}:{1} \" , item . Key , item . Value ); } } } Dart import 'dart:collection' ; main ( List < String > arguments ) { //count words var wordList = [ \"glass\" , \"table\" , \"chair\" , \"chair\" ]; var words = Map (); for ( var item in wordList ) { if ( words . containsKey ( item )) { words [ item ] += 1 ; } else { words [ item ] = 1 ; } } print ( ' $ words ' ); //sort values descending order var sorted = sortMap ( words ); print ( ' $ sorted ' ); } LinkedHashMap sortMap ( Map map ) { var mapk = map . keys . toList (); //sort keys according to values descending order mapk . sort (( k1 , k2 ) => map [ k2 ]. compareTo ( map [ k1 ])); var outMap = LinkedHashMap . fromIterable ( mapk , key: ( k ) => k , value: ( k ) => map [ k ]); return ( outMap ); } Go package main import ( \"fmt\" \"sort\" ) func main () { //count words wordList := [] string { \"glass\" , \"table\" , \"chair\" , \"chair\" } words := make ( map [ string ] int ) for _ , item := range wordList { words [ item ] ++ } fmt . Printf ( \"\\n%v\" , words ) //sort by descending value fmt . Printf ( \"\\n%v\" , mapSort ( words )) } func mapSort ( mapIn map [ string ] int ) keyValList { //dict to slice mapS := keyValList {} for k , v := range mapIn { mapS = append ( mapS , keyVal { k , v }) } sort . Sort ( sort . Reverse ( mapS )) return mapS } type keyVal struct { key string val int } type keyValList [] keyVal func ( p keyValList ) Len () int { return len ( p ) } func ( p keyValList ) Less ( i , j int ) bool { return p [ i ]. val < p [ j ]. val } func ( p keyValList ) Swap ( i , j int ){ p [ i ], p [ j ] = p [ j ], p [ i ] } Nim import tables import algorithm as al # count words var wordList = @[ \"glass\" , \"table\" , \"chair\" , \"chair\" ] var words = initOrderedTable [ string , int ] () for item in wordList : if words . hasKey ( item ): words [ item ] += 1 else : words . add ( item , 1 ) echo words # sort by descending value words . sort ( proc ( x , y : ( string , int )): int = x [ 1 ] - y [ 1 ] , order = al . SortOrder . Descending ) echo words Python from typing import Dict , List , Tuple from operator import itemgetter # count words word_list : List [ str ] = [ \"glass\" , \"table\" , \"chair\" , \"chair\" ] words : Dict [ str , int ] = {} for item in word_list : try : words [ item ] += 1 except : words [ item ] = 1 print ( words ) # sort by descending value words_l : List [ Tuple [ str , int ]] = list ( words . items ()) words_l = sorted ( words_l , reverse = True , key = itemgetter ( 1 )) print ( words_l ) Rust use std :: collections :: HashMap ; use std :: cmp :: Reverse ; fn main () { //count words let word_list = vec ! [ \"glass\" , \"table\" , \"chair\" , \"chair\" ]; let mut words : HashMap < String , usize > = HashMap :: new (); for item in word_list { let count = words . entry (( * item ). to_string ()). or_insert ( 0 ); * count += 1 ; } //get specific key value let value = words . get ( \"chair\" ). expect ( \"no key\" ); println ! ( \"{:?} {:?}\" , & words , value ); //sort by descending value let mut words_v : Vec < _ > = words . iter (). collect (); words_v . sort_by_key ( |& ( word , count ) | ( Reverse ( count ), word )); println ! ( \"{:?}\" , & words_v ); } Sing requires \"sio\" ; requires \"sort\" ; public fn singmain ( argv [ * ] string ) i32 { //count words let word_list [ * ] string = { \"glass\" , \"chair\" , \"glass\" , \"table\" , \"chair\" , \"chair\" }; var words map ( string ) i32 ; for ( elem in word_list ) { var value = words . get_safe ( elem , - 1 ); if ( value == - 1 ) { value = 1 ; } else { value = value + 1 ; } words . insert ( elem , value ); } //get specified value let value = words . get ( \"chair\" ); sio . print ( \" \\n\\r chair: \" + string ( value )); //sort by descending value var sort_index [ * ] i32 ; var sort_keys [ * ] i32 ; var map_keys [ * ] string ; sort . indexInit ( sort_index , words . size ()); for ( i in 0 : words . size ()) { map_keys . push_back ( words . key_at ( i )); sort_keys . push_back ( words . value_at ( i )); } sort . ksort_i32 ( sort_index , sort_keys ); var rev_index [ * ] i32 ; // reverse sort_index let i_size = sort_index . size (); for ( i in 0 : i_size ) { rev_index . push_back ( sort_index [ i_size - i - 1 ]); } sio . print ( \" \\n\\r \" ); for ( i in rev_index ) { sio . print ( \" \\n\\r \" + map_keys [ i ]); } return ( 0 ); } Typescript let wordList : string [] = [ \"glass\" , \"chair\" , \"table\" , \"chair\" ]; let words : Map < string , number > = new Map (); for ( var item of wordList ) { if ( words . has ( item ) ) { words . set ( item , words . get ( item ) + 1 ); } else { words . set ( item , 1 ); } } console . log ( words ); let sorted = new Map ( Array . from ( words . entries ()). sort (( a , b ) => { return ( Array . from ( a . values ())[ 0 ] > Array . from ( b . values ())[ 0 ] ? - 1 : 1 )})); console . log ( sorted ); V (vlang) fn main () { //count words word_list := [ \"glass\" , \"table\" , \"chair\" , \"chair\" ] mut words := map [ string ] int {} for _ , item in word_list { words [ item ] ++ } print ( \"\\n$words\" ) //sort by descending value map_sorted := map_sort ( words ) print ( \"\\n$map_sorted\" ) } fn map_sort ( map_in map [ string ] int ) [] KeyVal { //map to array mut map_s := [] KeyVal {} for k , v in map_in { map_s << KeyVal { k , v } } map_s . sort ( a . val > b . val ) return map_s } struct KeyVal { key string val int }","title":"Dictionary"},{"location":"Dict/#dictionary","text":"","title":"Dictionary"},{"location":"Dict/#c","text":"using System ; using System.Collections.Generic ; using System.Linq ; public class Program { public static void Main ( string [] args ) { //count words var wordList = new List < string > { \"glass\" , \"table\" , \"chair\" , \"chair\" }; var words = new Dictionary < string , int >(); foreach ( var item in wordList ) { if ( words . ContainsKey ( item )) { words [ item ] = ( int ) words [ item ] + 1 ; } else { words . Add ( item , 1 ); } } Console . WriteLine (); foreach ( var item in words ) { Console . Write ( \"{0}:{1} \" , item . Key , item . Value ); } Console . WriteLine (); var sorted = words . OrderBy ( x => - x . Value ); foreach ( var item in sorted ) { Console . Write ( \"{0}:{1} \" , item . Key , item . Value ); } } }","title":"C#"},{"location":"Dict/#dart","text":"import 'dart:collection' ; main ( List < String > arguments ) { //count words var wordList = [ \"glass\" , \"table\" , \"chair\" , \"chair\" ]; var words = Map (); for ( var item in wordList ) { if ( words . containsKey ( item )) { words [ item ] += 1 ; } else { words [ item ] = 1 ; } } print ( ' $ words ' ); //sort values descending order var sorted = sortMap ( words ); print ( ' $ sorted ' ); } LinkedHashMap sortMap ( Map map ) { var mapk = map . keys . toList (); //sort keys according to values descending order mapk . sort (( k1 , k2 ) => map [ k2 ]. compareTo ( map [ k1 ])); var outMap = LinkedHashMap . fromIterable ( mapk , key: ( k ) => k , value: ( k ) => map [ k ]); return ( outMap ); }","title":"Dart"},{"location":"Dict/#go","text":"package main import ( \"fmt\" \"sort\" ) func main () { //count words wordList := [] string { \"glass\" , \"table\" , \"chair\" , \"chair\" } words := make ( map [ string ] int ) for _ , item := range wordList { words [ item ] ++ } fmt . Printf ( \"\\n%v\" , words ) //sort by descending value fmt . Printf ( \"\\n%v\" , mapSort ( words )) } func mapSort ( mapIn map [ string ] int ) keyValList { //dict to slice mapS := keyValList {} for k , v := range mapIn { mapS = append ( mapS , keyVal { k , v }) } sort . Sort ( sort . Reverse ( mapS )) return mapS } type keyVal struct { key string val int } type keyValList [] keyVal func ( p keyValList ) Len () int { return len ( p ) } func ( p keyValList ) Less ( i , j int ) bool { return p [ i ]. val < p [ j ]. val } func ( p keyValList ) Swap ( i , j int ){ p [ i ], p [ j ] = p [ j ], p [ i ] }","title":"Go"},{"location":"Dict/#nim","text":"import tables import algorithm as al # count words var wordList = @[ \"glass\" , \"table\" , \"chair\" , \"chair\" ] var words = initOrderedTable [ string , int ] () for item in wordList : if words . hasKey ( item ): words [ item ] += 1 else : words . add ( item , 1 ) echo words # sort by descending value words . sort ( proc ( x , y : ( string , int )): int = x [ 1 ] - y [ 1 ] , order = al . SortOrder . Descending ) echo words","title":"Nim"},{"location":"Dict/#python","text":"from typing import Dict , List , Tuple from operator import itemgetter # count words word_list : List [ str ] = [ \"glass\" , \"table\" , \"chair\" , \"chair\" ] words : Dict [ str , int ] = {} for item in word_list : try : words [ item ] += 1 except : words [ item ] = 1 print ( words ) # sort by descending value words_l : List [ Tuple [ str , int ]] = list ( words . items ()) words_l = sorted ( words_l , reverse = True , key = itemgetter ( 1 )) print ( words_l )","title":"Python"},{"location":"Dict/#rust","text":"use std :: collections :: HashMap ; use std :: cmp :: Reverse ; fn main () { //count words let word_list = vec ! [ \"glass\" , \"table\" , \"chair\" , \"chair\" ]; let mut words : HashMap < String , usize > = HashMap :: new (); for item in word_list { let count = words . entry (( * item ). to_string ()). or_insert ( 0 ); * count += 1 ; } //get specific key value let value = words . get ( \"chair\" ). expect ( \"no key\" ); println ! ( \"{:?} {:?}\" , & words , value ); //sort by descending value let mut words_v : Vec < _ > = words . iter (). collect (); words_v . sort_by_key ( |& ( word , count ) | ( Reverse ( count ), word )); println ! ( \"{:?}\" , & words_v ); }","title":"Rust"},{"location":"Dict/#sing","text":"requires \"sio\" ; requires \"sort\" ; public fn singmain ( argv [ * ] string ) i32 { //count words let word_list [ * ] string = { \"glass\" , \"chair\" , \"glass\" , \"table\" , \"chair\" , \"chair\" }; var words map ( string ) i32 ; for ( elem in word_list ) { var value = words . get_safe ( elem , - 1 ); if ( value == - 1 ) { value = 1 ; } else { value = value + 1 ; } words . insert ( elem , value ); } //get specified value let value = words . get ( \"chair\" ); sio . print ( \" \\n\\r chair: \" + string ( value )); //sort by descending value var sort_index [ * ] i32 ; var sort_keys [ * ] i32 ; var map_keys [ * ] string ; sort . indexInit ( sort_index , words . size ()); for ( i in 0 : words . size ()) { map_keys . push_back ( words . key_at ( i )); sort_keys . push_back ( words . value_at ( i )); } sort . ksort_i32 ( sort_index , sort_keys ); var rev_index [ * ] i32 ; // reverse sort_index let i_size = sort_index . size (); for ( i in 0 : i_size ) { rev_index . push_back ( sort_index [ i_size - i - 1 ]); } sio . print ( \" \\n\\r \" ); for ( i in rev_index ) { sio . print ( \" \\n\\r \" + map_keys [ i ]); } return ( 0 ); }","title":"Sing"},{"location":"Dict/#typescript","text":"let wordList : string [] = [ \"glass\" , \"chair\" , \"table\" , \"chair\" ]; let words : Map < string , number > = new Map (); for ( var item of wordList ) { if ( words . has ( item ) ) { words . set ( item , words . get ( item ) + 1 ); } else { words . set ( item , 1 ); } } console . log ( words ); let sorted = new Map ( Array . from ( words . entries ()). sort (( a , b ) => { return ( Array . from ( a . values ())[ 0 ] > Array . from ( b . values ())[ 0 ] ? - 1 : 1 )})); console . log ( sorted );","title":"Typescript"},{"location":"Dict/#v-vlang","text":"fn main () { //count words word_list := [ \"glass\" , \"table\" , \"chair\" , \"chair\" ] mut words := map [ string ] int {} for _ , item in word_list { words [ item ] ++ } print ( \"\\n$words\" ) //sort by descending value map_sorted := map_sort ( words ) print ( \"\\n$map_sorted\" ) } fn map_sort ( map_in map [ string ] int ) [] KeyVal { //map to array mut map_s := [] KeyVal {} for k , v in map_in { map_s << KeyVal { k , v } } map_s . sort ( a . val > b . val ) return map_s } struct KeyVal { key string val int }","title":"V (vlang)"},{"location":"Excel%20Read/","text":"Excel Read Python # pip install pandas # pip install numpy # pip install xlrd import pandas as pd import numpy as np \"\"\" col0 col1 col2 col3 xx xx xx xx item1 1 2 3 item2 4 5 6 \"\"\" df = pd . read_excel ( \"tmp.xlsx\" , \"Sheet1\" ) # get cols, discard firt row col1 = df [ \"col1\" ][ 1 :] col2 = df [ \"col2\" ][ 1 :] col3 = df [ \"col3\" ][ 1 :] for num in col1 : print ( f \" {num} \" ) # get item2 row, numeric values only num_cols = df . columns [ 1 :] row2 = df [ df [ \"col0\" ] == \"item2\" ][ num_cols ] row2 = row2 . to_numpy ( dtype = float )[ 0 ] for num in row2 : print ( f \" {num} \" ) Rust //[dependencies] //calamine = \"0.16.1\" use calamine :: { open_workbook , Reader , Xlsx }; use std :: collections :: HashMap ; fn main () { /* col0 col1 col2 col3 xx xx xx xx item1 1 2 3 item2 4 5 6 */ let mut excel : Xlsx < _ > = open_workbook ( \"tmp.xlsx\" ). unwrap (); let content = excel . worksheet_range ( \"Sheet1\" ). unwrap (). unwrap (); let mut col_names : Vec <& str > = vec ! []; let mut rows : Vec < Vec < f64 >> = vec ! []; let mut named_rows : HashMap <& str , Vec < f64 >> = HashMap :: new (); let mut ind = 0 ; for item in content . rows () { if ind == 0 { for elem in item { let col_name = match elem { calamine :: DataType :: String ( strt ) => strt , _ => \"\" , }; col_names . push ( col_name ); } } else if ind > 1 { let mut row : Vec < f64 > = vec ! []; let mut name : & str = \"\" ; for elem in item { match elem { calamine :: DataType :: Float ( num ) => { row . push ( * num ); () } calamine :: DataType :: String ( strt ) => { name = & strt ; () } _ => (), }; } rows . push ( row . clone ()); named_rows . entry ( name ). or_insert ( row ); } ind = ind + 1 ; } // get named column let col = get_column ( rows , \"col1\" , col_names ). unwrap (); println ! ( \"{:?}\" , col ); // get named row println ! ( \"{:?}\" , named_rows . get ( \"item1\" ). unwrap ()); } fn get_column ( rows : Vec < Vec < f64 >> , col_name : & str , col_names : Vec <& str > , ) -> Result < Vec < f64 > , & 'static str > { // get col index let mut col_index : i32 = - 1 ; for ( ind , item ) in col_names . iter (). enumerate () { if * item == col_name { col_index = ind as i32 ; break ; } } if col_index == - 1 { Err ( \"Column not found\" ) } else { let mut col : Vec < f64 > = vec ! []; for row in rows { col . push ( row [ col_index as usize ]); } Ok ( col ) } }","title":"Excel Read"},{"location":"Excel%20Read/#excel-read","text":"","title":"Excel Read"},{"location":"Excel%20Read/#python","text":"# pip install pandas # pip install numpy # pip install xlrd import pandas as pd import numpy as np \"\"\" col0 col1 col2 col3 xx xx xx xx item1 1 2 3 item2 4 5 6 \"\"\" df = pd . read_excel ( \"tmp.xlsx\" , \"Sheet1\" ) # get cols, discard firt row col1 = df [ \"col1\" ][ 1 :] col2 = df [ \"col2\" ][ 1 :] col3 = df [ \"col3\" ][ 1 :] for num in col1 : print ( f \" {num} \" ) # get item2 row, numeric values only num_cols = df . columns [ 1 :] row2 = df [ df [ \"col0\" ] == \"item2\" ][ num_cols ] row2 = row2 . to_numpy ( dtype = float )[ 0 ] for num in row2 : print ( f \" {num} \" )","title":"Python"},{"location":"Excel%20Read/#rust","text":"//[dependencies] //calamine = \"0.16.1\" use calamine :: { open_workbook , Reader , Xlsx }; use std :: collections :: HashMap ; fn main () { /* col0 col1 col2 col3 xx xx xx xx item1 1 2 3 item2 4 5 6 */ let mut excel : Xlsx < _ > = open_workbook ( \"tmp.xlsx\" ). unwrap (); let content = excel . worksheet_range ( \"Sheet1\" ). unwrap (). unwrap (); let mut col_names : Vec <& str > = vec ! []; let mut rows : Vec < Vec < f64 >> = vec ! []; let mut named_rows : HashMap <& str , Vec < f64 >> = HashMap :: new (); let mut ind = 0 ; for item in content . rows () { if ind == 0 { for elem in item { let col_name = match elem { calamine :: DataType :: String ( strt ) => strt , _ => \"\" , }; col_names . push ( col_name ); } } else if ind > 1 { let mut row : Vec < f64 > = vec ! []; let mut name : & str = \"\" ; for elem in item { match elem { calamine :: DataType :: Float ( num ) => { row . push ( * num ); () } calamine :: DataType :: String ( strt ) => { name = & strt ; () } _ => (), }; } rows . push ( row . clone ()); named_rows . entry ( name ). or_insert ( row ); } ind = ind + 1 ; } // get named column let col = get_column ( rows , \"col1\" , col_names ). unwrap (); println ! ( \"{:?}\" , col ); // get named row println ! ( \"{:?}\" , named_rows . get ( \"item1\" ). unwrap ()); } fn get_column ( rows : Vec < Vec < f64 >> , col_name : & str , col_names : Vec <& str > , ) -> Result < Vec < f64 > , & 'static str > { // get col index let mut col_index : i32 = - 1 ; for ( ind , item ) in col_names . iter (). enumerate () { if * item == col_name { col_index = ind as i32 ; break ; } } if col_index == - 1 { Err ( \"Column not found\" ) } else { let mut col : Vec < f64 > = vec ! []; for row in rows { col . push ( row [ col_index as usize ]); } Ok ( col ) } }","title":"Rust"},{"location":"Execution%20time/","text":"Execution time C# // exe -> dotnet publish -c Release -r win10-x64 --self-contained true using System ; using System.Collections.Generic ; using System.Diagnostics ; using System.Linq ; public class Program { public static void Main ( string [] args ) { var timer = Stopwatch . StartNew (); //START MEASURE var perfects = classifyPerfects ( 20001 ); timer . Stop (); //END MEASURE foreach ( var item in perfects ) { Console . Write ( \"{0} \" , item ); } Console . WriteLine ( \"\\nElapsed: {0}ms\" , timer . ElapsedMilliseconds ); } public static List < int > classifyPerfects ( int num ) { var perfects = new List < int >(); for ( int n = 1 ; n < num ; n ++) { var divisors = findProperDivisor ( n ); // list_sum var sum = divisors . Sum (); if ( sum == n ) { perfects . Add ( n ); } } return perfects ; } public static List < int > findProperDivisor ( int n ) { var divisors = new List < int >(); for ( int i = 1 ; i < ( n / 2 ) + 1 ; i ++) { if ( n % i == 0 ) { divisors . Add ( i ); } } return divisors ; } } Dart main ( List < String > arguments ) { var stopwatch = Stopwatch (); stopwatch . start (); //START MEASURE var perfects = classifyPerfect ( 20001 ); stopwatch . stop (); //END MEASURE var elapsed = stopwatch . elapsedMilliseconds ; print ( ' $ perfects ' ); print ( 'Elapsed: $ elapsed ms' ); } List < int > classifyPerfect ( int nnum ) { var perfects = List < int > (); for ( var n = 1 ; n < nnum ; n ++ ) { var divisors = findProperDivisor ( n ); var sum = 0 ; if ( divisors . isNotEmpty ) { sum = divisors . fold ( 0 , ( a , b ) => a + b ); } if ( sum == n ) { perfects . add ( n ); } } return perfects ; } List < int > findProperDivisor ( int n ) { var divisors = List < int > (); var endloop = n ~/ 2 + 1 ; for ( var i = 1 ; i < endloop ; i ++ ) { if ( n % i == 0 ) { divisors . add ( i ); } } return divisors ; } Go package main import ( \"fmt\" \"time\" ) func main () { start := time . Now () //START MEASURE perfects := classifyPerfect ( 20001 ) duration := time . Since ( start ) //END MEASURE fmt . Printf ( \"\\n%v\" , perfects ) fmt . Printf ( \"\\nElapsed: %v\" , duration ) } func classifyPerfect ( nnum int ) [] int { perfects := [] int {} for n := 1 ; n < nnum ; n ++ { divisors := findProperDivisor ( n ) sum := 0 for i := 0 ; i < len ( divisors ); i ++ { sum += divisors [ i ] } if sum == n { perfects = append ( perfects , n ) } } return perfects } func findProperDivisor ( n int ) [] int { divisors := [] int {} endloop := int ( n / 2 ) + 1 for i := 1 ; i < endloop ; i ++ { if n % i == 0 { divisors = append ( divisors , i ) } } return divisors } Nim # exe -> nim c -d:release <filename> import times as ts import sequtils as sq proc findProperDivisors ( n : int32 ): seq [ int32 ] = var divisors : seq [ int32 ] let endloop : int32 = int32 ( n / 2 ) for i in 1 .. endloop : if ( n mod i ) == 0 : divisors . add ( i ) divisors proc classifyPerfects ( num : int32 ): seq [ int32 ] = var perfects : seq [ int32 ] for n in 1 .. num : let divisors = findProperDivisors ( n ) var sumd = 0 if divisors . len > 0 : sumd = divisors . foldl ( a + b ) if sumd == n : perfects . add ( n ) perfects var start = ts . getTime () # START MEASURE var perfects = classifyPerfects ( 20001 ) var endt = ts . getTime () # END MEASURE echo perfects echo endt - start Python import time from typing import List def find_proper_divisors ( n : int ) -> List [ int ]: divisors : List [ int ] = [] for i in range ( 1 , int (( n / 2 ) + 1 )): if n % i == 0 : divisors += [ i ] return divisors def classify_perfects ( num : int ) -> List [ int ]: perfects : List [ int ] = [] for n in range ( 1 , num ): divisors = find_proper_divisors ( n ) # list_sum sumd = sum ( divisors ) if sumd == n : perfects += [ n ] return perfects start_time : float = time . time () # START MEASURE perfects = classify_perfects ( 20001 ) end_time : float = time . time () # END MEASURE for item in perfects : print ( f \" {item} \" ) print ( f \"Elapsed: {((end_time - start_time)*1000)} ms\" ) Rust //exe -> cargo build --release use std :: time :: { Instant }; fn main () { let now = Instant :: now (); //START MEASURE let perfects = classify_perfect ( 20001 ); let new_now = Instant :: now (); //END MEASURE println ! ( \"{:?}\" , perfects ); println ! ( \"Elapsed: {:?}\" , new_now . duration_since ( now )); } fn classify_perfect ( num : i32 ) -> Vec < i32 > { let mut perfects = vec ! []; for n in 1 .. num { let divisors = find_proper_divisors ( n ); // list_sum let sum : i32 = divisors . iter (). sum (); if sum == n { perfects . push ( n ); } } perfects } fn find_proper_divisors ( n : i32 ) -> Vec < i32 > { let mut divisors = vec ! []; for i in 1 ..(( n / 2 ) + 1 ) { if n % i == 0 { divisors . push ( i ); } } return divisors ; } Sing requires \"sio\" ; requires \"sys\" ; public fn singmain ( argv [ * ] string ) i32 { let now = sys . clock (); //START MEASURE let perfects = classify_perfect ( 20001 ); let new_now = sys . clock (); //END MEASURE let diff = sys . clocksDiff ( now , new_now ); //microseconds sio . print ( \" \\n\\r \" ); if ( perfects != null ) { for ( i in 0 : perfects . size ()) { sio . print ( string (( * perfects )[ i ]) + \", \" ); } } sio . print ( \" \\n\\r Elapsed: \" + string ( diff ) + \" us\" ); return ( 0 ); } fn classify_perfect ( num i32 ) * [ * ] i32 { var perfects [ * ] i32 ; for ( n in 1 : num ) { let divisors = find_proper_divisors ( n ); // list_sum // mandatory pointer check if ( divisors != null ) { var sum = 0 ; for ( j in 0 : divisors . size ()) { sum = sum + ( * divisors )[ j ]; } if ( sum == n ) { perfects . push_back ( n ); } } } return ( & perfects ); } fn find_proper_divisors ( n i32 ) * [ * ] i32 { var divisors [ * ] i32 ; for ( i in 1 : (( n / 2 ) + 1 )) { if (( n % i ) == 0 ) { divisors . push_back ( i ); } } return ( & divisors ); } TypeScript console . time ( \"Elapsed\" ); //START MEASURE let perfects = classifyPerfect ( 20001 ); console . timeEnd ( \"Elapsed\" ); //END MEASURE console . log ( ` ${ perfects } ` ); function classifyPerfect ( nnum : number ) { let perfects = []; for ( var n = 1 ; n < nnum ; n ++ ) { let divisors = findProperDivisor ( n ); var sum = 0 ; if ( divisors . length > 0 ) { divisors . forEach ( x => sum += x ); } if ( sum == n ) { perfects . push ( n ); } } return perfects ; } function findProperDivisor ( n : number ) { let divisors = []; let endloop = Math . floor ( n / 2 ) + 1 ; for ( let i = 1 ; i < endloop ; i ++ ) { if ( n % i == 0 ) { divisors . push ( i ); } } return divisors ; } V (vlang) import time fn main () { start := time . ticks () perfects := classify_perfect ( 20001 ) finish := time . ticks () println ( \"$perfects\" ) println ( ' Execution time $ { finish - start } ms ' ) } fn classify_perfect ( nnum int ) [] int { mut perfects := [] int {} for n := 1 ; n < nnum ; n ++ { divisors := find_proper_divisor ( n ) mut sum := 0 for i := 0 ; i < divisors . len ; i ++ { sum += divisors [ i ] } if sum == n { perfects << n } } return perfects } fn find_proper_divisor ( n int ) [] int { mut divisors := [] int {} endloop := int ( n / 2 ) + 1 for i := 1 ; i < endloop ; i ++ { if n % i == 0 { divisors << i } } return divisors }","title":"Execution time"},{"location":"Execution%20time/#execution-time","text":"","title":"Execution time"},{"location":"Execution%20time/#c","text":"// exe -> dotnet publish -c Release -r win10-x64 --self-contained true using System ; using System.Collections.Generic ; using System.Diagnostics ; using System.Linq ; public class Program { public static void Main ( string [] args ) { var timer = Stopwatch . StartNew (); //START MEASURE var perfects = classifyPerfects ( 20001 ); timer . Stop (); //END MEASURE foreach ( var item in perfects ) { Console . Write ( \"{0} \" , item ); } Console . WriteLine ( \"\\nElapsed: {0}ms\" , timer . ElapsedMilliseconds ); } public static List < int > classifyPerfects ( int num ) { var perfects = new List < int >(); for ( int n = 1 ; n < num ; n ++) { var divisors = findProperDivisor ( n ); // list_sum var sum = divisors . Sum (); if ( sum == n ) { perfects . Add ( n ); } } return perfects ; } public static List < int > findProperDivisor ( int n ) { var divisors = new List < int >(); for ( int i = 1 ; i < ( n / 2 ) + 1 ; i ++) { if ( n % i == 0 ) { divisors . Add ( i ); } } return divisors ; } }","title":"C#"},{"location":"Execution%20time/#dart","text":"main ( List < String > arguments ) { var stopwatch = Stopwatch (); stopwatch . start (); //START MEASURE var perfects = classifyPerfect ( 20001 ); stopwatch . stop (); //END MEASURE var elapsed = stopwatch . elapsedMilliseconds ; print ( ' $ perfects ' ); print ( 'Elapsed: $ elapsed ms' ); } List < int > classifyPerfect ( int nnum ) { var perfects = List < int > (); for ( var n = 1 ; n < nnum ; n ++ ) { var divisors = findProperDivisor ( n ); var sum = 0 ; if ( divisors . isNotEmpty ) { sum = divisors . fold ( 0 , ( a , b ) => a + b ); } if ( sum == n ) { perfects . add ( n ); } } return perfects ; } List < int > findProperDivisor ( int n ) { var divisors = List < int > (); var endloop = n ~/ 2 + 1 ; for ( var i = 1 ; i < endloop ; i ++ ) { if ( n % i == 0 ) { divisors . add ( i ); } } return divisors ; }","title":"Dart"},{"location":"Execution%20time/#go","text":"package main import ( \"fmt\" \"time\" ) func main () { start := time . Now () //START MEASURE perfects := classifyPerfect ( 20001 ) duration := time . Since ( start ) //END MEASURE fmt . Printf ( \"\\n%v\" , perfects ) fmt . Printf ( \"\\nElapsed: %v\" , duration ) } func classifyPerfect ( nnum int ) [] int { perfects := [] int {} for n := 1 ; n < nnum ; n ++ { divisors := findProperDivisor ( n ) sum := 0 for i := 0 ; i < len ( divisors ); i ++ { sum += divisors [ i ] } if sum == n { perfects = append ( perfects , n ) } } return perfects } func findProperDivisor ( n int ) [] int { divisors := [] int {} endloop := int ( n / 2 ) + 1 for i := 1 ; i < endloop ; i ++ { if n % i == 0 { divisors = append ( divisors , i ) } } return divisors }","title":"Go"},{"location":"Execution%20time/#nim","text":"# exe -> nim c -d:release <filename> import times as ts import sequtils as sq proc findProperDivisors ( n : int32 ): seq [ int32 ] = var divisors : seq [ int32 ] let endloop : int32 = int32 ( n / 2 ) for i in 1 .. endloop : if ( n mod i ) == 0 : divisors . add ( i ) divisors proc classifyPerfects ( num : int32 ): seq [ int32 ] = var perfects : seq [ int32 ] for n in 1 .. num : let divisors = findProperDivisors ( n ) var sumd = 0 if divisors . len > 0 : sumd = divisors . foldl ( a + b ) if sumd == n : perfects . add ( n ) perfects var start = ts . getTime () # START MEASURE var perfects = classifyPerfects ( 20001 ) var endt = ts . getTime () # END MEASURE echo perfects echo endt - start","title":"Nim"},{"location":"Execution%20time/#python","text":"import time from typing import List def find_proper_divisors ( n : int ) -> List [ int ]: divisors : List [ int ] = [] for i in range ( 1 , int (( n / 2 ) + 1 )): if n % i == 0 : divisors += [ i ] return divisors def classify_perfects ( num : int ) -> List [ int ]: perfects : List [ int ] = [] for n in range ( 1 , num ): divisors = find_proper_divisors ( n ) # list_sum sumd = sum ( divisors ) if sumd == n : perfects += [ n ] return perfects start_time : float = time . time () # START MEASURE perfects = classify_perfects ( 20001 ) end_time : float = time . time () # END MEASURE for item in perfects : print ( f \" {item} \" ) print ( f \"Elapsed: {((end_time - start_time)*1000)} ms\" )","title":"Python"},{"location":"Execution%20time/#rust","text":"//exe -> cargo build --release use std :: time :: { Instant }; fn main () { let now = Instant :: now (); //START MEASURE let perfects = classify_perfect ( 20001 ); let new_now = Instant :: now (); //END MEASURE println ! ( \"{:?}\" , perfects ); println ! ( \"Elapsed: {:?}\" , new_now . duration_since ( now )); } fn classify_perfect ( num : i32 ) -> Vec < i32 > { let mut perfects = vec ! []; for n in 1 .. num { let divisors = find_proper_divisors ( n ); // list_sum let sum : i32 = divisors . iter (). sum (); if sum == n { perfects . push ( n ); } } perfects } fn find_proper_divisors ( n : i32 ) -> Vec < i32 > { let mut divisors = vec ! []; for i in 1 ..(( n / 2 ) + 1 ) { if n % i == 0 { divisors . push ( i ); } } return divisors ; }","title":"Rust"},{"location":"Execution%20time/#sing","text":"requires \"sio\" ; requires \"sys\" ; public fn singmain ( argv [ * ] string ) i32 { let now = sys . clock (); //START MEASURE let perfects = classify_perfect ( 20001 ); let new_now = sys . clock (); //END MEASURE let diff = sys . clocksDiff ( now , new_now ); //microseconds sio . print ( \" \\n\\r \" ); if ( perfects != null ) { for ( i in 0 : perfects . size ()) { sio . print ( string (( * perfects )[ i ]) + \", \" ); } } sio . print ( \" \\n\\r Elapsed: \" + string ( diff ) + \" us\" ); return ( 0 ); } fn classify_perfect ( num i32 ) * [ * ] i32 { var perfects [ * ] i32 ; for ( n in 1 : num ) { let divisors = find_proper_divisors ( n ); // list_sum // mandatory pointer check if ( divisors != null ) { var sum = 0 ; for ( j in 0 : divisors . size ()) { sum = sum + ( * divisors )[ j ]; } if ( sum == n ) { perfects . push_back ( n ); } } } return ( & perfects ); } fn find_proper_divisors ( n i32 ) * [ * ] i32 { var divisors [ * ] i32 ; for ( i in 1 : (( n / 2 ) + 1 )) { if (( n % i ) == 0 ) { divisors . push_back ( i ); } } return ( & divisors ); }","title":"Sing"},{"location":"Execution%20time/#typescript","text":"console . time ( \"Elapsed\" ); //START MEASURE let perfects = classifyPerfect ( 20001 ); console . timeEnd ( \"Elapsed\" ); //END MEASURE console . log ( ` ${ perfects } ` ); function classifyPerfect ( nnum : number ) { let perfects = []; for ( var n = 1 ; n < nnum ; n ++ ) { let divisors = findProperDivisor ( n ); var sum = 0 ; if ( divisors . length > 0 ) { divisors . forEach ( x => sum += x ); } if ( sum == n ) { perfects . push ( n ); } } return perfects ; } function findProperDivisor ( n : number ) { let divisors = []; let endloop = Math . floor ( n / 2 ) + 1 ; for ( let i = 1 ; i < endloop ; i ++ ) { if ( n % i == 0 ) { divisors . push ( i ); } } return divisors ; }","title":"TypeScript"},{"location":"Execution%20time/#v-vlang","text":"import time fn main () { start := time . ticks () perfects := classify_perfect ( 20001 ) finish := time . ticks () println ( \"$perfects\" ) println ( ' Execution time $ { finish - start } ms ' ) } fn classify_perfect ( nnum int ) [] int { mut perfects := [] int {} for n := 1 ; n < nnum ; n ++ { divisors := find_proper_divisor ( n ) mut sum := 0 for i := 0 ; i < divisors . len ; i ++ { sum += divisors [ i ] } if sum == n { perfects << n } } return perfects } fn find_proper_divisor ( n int ) [] int { mut divisors := [] int {} endloop := int ( n / 2 ) + 1 for i := 1 ; i < endloop ; i ++ { if n % i == 0 { divisors << i } } return divisors }","title":"V (vlang)"},{"location":"FaceDetect/","text":"Face Detection Python Rust //compile in release for good performance //stream video with simple shapes overlay //[dependencies] //camera_capture = \"0.5.0\" //minifb = \"0.15.3\" //image = \"0.22.4\" //imageproc = \"0.19.2\" //rustface = \"0.1.2\" use image :: GrayImage ; use image :: { imageops , DynamicImage , ImageBuffer , Rgb , RgbImage }; use imageproc :: drawing :: { draw_hollow_rect_mut }; use imageproc :: rect :: Rect ; use minifb :: { Key , Window , WindowOptions }; use rustface :: { Detector , FaceInfo , ImageData }; const WIDTH : usize = 200 ; const HEIGHT : usize = 200 ; fn main () { let mut detector = rustface :: create_detector ( \"seeta_fd_frontal_v1.0.bin\" ). unwrap (); detector . set_min_face_size ( 20 ); detector . set_score_thresh ( 2.0 ); detector . set_pyramid_scale_factor ( 0.8 ); detector . set_slide_window_step ( 4 , 4 ); let cam = camera_capture :: create ( 0 ). expect ( \"Camera create error\" ); //let mut cam_iter = cam.fps(0.5).unwrap().start().unwrap(); let mut cam_iter = cam . start (). unwrap (); let mut window = Window :: new ( \"image, click or press ESC to exit\" , WIDTH , HEIGHT , WindowOptions { .. WindowOptions :: default () }, ) . expect ( \"Error opening window\" ); while window . is_open () && ! window . is_key_down ( Key :: Escape ) { let img = cam_iter . next (). unwrap (); let ( width , height ) = img . dimensions (); //Resize to WIDTH, HEIGHT -> a DynamicImage is needed let img_r = RgbImage :: from_vec ( width , height , img . to_vec ()). unwrap (); let img_d = DynamicImage :: ImageRgb8 ( img_r ); let img_d_resized = img_d . resize_exact ( WIDTH as u32 , HEIGHT as u32 , imageops :: Nearest ); //To draw pixels, an ImageBuffer is needed back let mut img_g_resized = ImageBuffer :: from_raw ( WIDTH as u32 , HEIGHT as u32 , img_d_resized . raw_pixels ()). unwrap (); let faces = detect_faces ( & mut * detector , & img_d_resized . to_luma ()); for face in faces { let bbox = face . bbox (); let rect = Rect :: at ( bbox . x (), bbox . y ()). of_size ( bbox . width (), bbox . height ()); draw_hollow_rect_mut ( & mut img_g_resized , rect , Rgb ([ 255 , 0 , 0 ])); } let u32_buffer : Vec < u32 > = img_g_resized . chunks ( 3 ) . map ( | v | (( v [ 0 ] as u32 ) << 16 ) | (( v [ 1 ] as u32 ) << 8 ) | v [ 2 ] as u32 ) . collect (); window . update_with_buffer ( & u32_buffer , WIDTH , HEIGHT ) . expect ( \"Error on update\" ); } } fn detect_faces ( detector : & mut dyn Detector , gray : & GrayImage ) -> Vec < FaceInfo > { let ( width , height ) = gray . dimensions (); let mut image = ImageData :: new ( gray . as_ptr (), width , height ); let faces = detector . detect ( & mut image ); faces }","title":"Face Detection"},{"location":"FaceDetect/#face-detection","text":"","title":"Face Detection"},{"location":"FaceDetect/#python","text":"","title":"Python"},{"location":"FaceDetect/#rust","text":"//compile in release for good performance //stream video with simple shapes overlay //[dependencies] //camera_capture = \"0.5.0\" //minifb = \"0.15.3\" //image = \"0.22.4\" //imageproc = \"0.19.2\" //rustface = \"0.1.2\" use image :: GrayImage ; use image :: { imageops , DynamicImage , ImageBuffer , Rgb , RgbImage }; use imageproc :: drawing :: { draw_hollow_rect_mut }; use imageproc :: rect :: Rect ; use minifb :: { Key , Window , WindowOptions }; use rustface :: { Detector , FaceInfo , ImageData }; const WIDTH : usize = 200 ; const HEIGHT : usize = 200 ; fn main () { let mut detector = rustface :: create_detector ( \"seeta_fd_frontal_v1.0.bin\" ). unwrap (); detector . set_min_face_size ( 20 ); detector . set_score_thresh ( 2.0 ); detector . set_pyramid_scale_factor ( 0.8 ); detector . set_slide_window_step ( 4 , 4 ); let cam = camera_capture :: create ( 0 ). expect ( \"Camera create error\" ); //let mut cam_iter = cam.fps(0.5).unwrap().start().unwrap(); let mut cam_iter = cam . start (). unwrap (); let mut window = Window :: new ( \"image, click or press ESC to exit\" , WIDTH , HEIGHT , WindowOptions { .. WindowOptions :: default () }, ) . expect ( \"Error opening window\" ); while window . is_open () && ! window . is_key_down ( Key :: Escape ) { let img = cam_iter . next (). unwrap (); let ( width , height ) = img . dimensions (); //Resize to WIDTH, HEIGHT -> a DynamicImage is needed let img_r = RgbImage :: from_vec ( width , height , img . to_vec ()). unwrap (); let img_d = DynamicImage :: ImageRgb8 ( img_r ); let img_d_resized = img_d . resize_exact ( WIDTH as u32 , HEIGHT as u32 , imageops :: Nearest ); //To draw pixels, an ImageBuffer is needed back let mut img_g_resized = ImageBuffer :: from_raw ( WIDTH as u32 , HEIGHT as u32 , img_d_resized . raw_pixels ()). unwrap (); let faces = detect_faces ( & mut * detector , & img_d_resized . to_luma ()); for face in faces { let bbox = face . bbox (); let rect = Rect :: at ( bbox . x (), bbox . y ()). of_size ( bbox . width (), bbox . height ()); draw_hollow_rect_mut ( & mut img_g_resized , rect , Rgb ([ 255 , 0 , 0 ])); } let u32_buffer : Vec < u32 > = img_g_resized . chunks ( 3 ) . map ( | v | (( v [ 0 ] as u32 ) << 16 ) | (( v [ 1 ] as u32 ) << 8 ) | v [ 2 ] as u32 ) . collect (); window . update_with_buffer ( & u32_buffer , WIDTH , HEIGHT ) . expect ( \"Error on update\" ); } } fn detect_faces ( detector : & mut dyn Detector , gray : & GrayImage ) -> Vec < FaceInfo > { let ( width , height ) = gray . dimensions (); let mut image = ImageData :: new ( gray . as_ptr (), width , height ); let faces = detector . detect ( & mut image ); faces }","title":"Rust"},{"location":"Fltk/","text":"Fltk Rust //[dependencies] //fltk = \"0.16.5\" use fltk :: { app :: * , button :: * , frame :: * , window :: * }; const WIN_X : i32 = 50 ; const WIN_Y : i32 = 50 ; const WIN_WIDTH : i32 = 800 ; const WIN_HEIGHT : i32 = 600 ; const B_W : i32 = 80 ; const B_H : i32 = 40 ; fn main () { let app = App :: default (). with_scheme ( Scheme :: Gtk ); let mut wind = Window :: new ( WIN_X , WIN_Y , WIN_WIDTH , WIN_HEIGHT , \"Fltk Test\" ); let bt1_x = WIN_X + 10 ; let mut bt1 = Button :: new ( bt1_x , WIN_Y + 10 , B_W , B_H , \"Press\" ); bt1 . set_tooltip ( \"Press to increment counter\" ); let ct1_y = WIN_Y + B_H + 10 ; let mut ct1 = Frame :: new ( bt1_x , ct1_y + 10 , B_W , B_H , \"0\" ); bt1 . set_callback2 ( move | bt | { bt . set_label ( \"Pressed\" ); let count = ( ct1 . label (). parse :: < i32 > (). unwrap () + 1 ). to_string (); ct1 . set_label ( & count ); }); wind . make_resizable ( true ); wind . end (); wind . show (); app . run (). unwrap (); }","title":"Fltk"},{"location":"Fltk/#fltk","text":"","title":"Fltk"},{"location":"Fltk/#rust","text":"//[dependencies] //fltk = \"0.16.5\" use fltk :: { app :: * , button :: * , frame :: * , window :: * }; const WIN_X : i32 = 50 ; const WIN_Y : i32 = 50 ; const WIN_WIDTH : i32 = 800 ; const WIN_HEIGHT : i32 = 600 ; const B_W : i32 = 80 ; const B_H : i32 = 40 ; fn main () { let app = App :: default (). with_scheme ( Scheme :: Gtk ); let mut wind = Window :: new ( WIN_X , WIN_Y , WIN_WIDTH , WIN_HEIGHT , \"Fltk Test\" ); let bt1_x = WIN_X + 10 ; let mut bt1 = Button :: new ( bt1_x , WIN_Y + 10 , B_W , B_H , \"Press\" ); bt1 . set_tooltip ( \"Press to increment counter\" ); let ct1_y = WIN_Y + B_H + 10 ; let mut ct1 = Frame :: new ( bt1_x , ct1_y + 10 , B_W , B_H , \"0\" ); bt1 . set_callback2 ( move | bt | { bt . set_label ( \"Pressed\" ); let count = ( ct1 . label (). parse :: < i32 > (). unwrap () + 1 ). to_string (); ct1 . set_label ( & count ); }); wind . make_resizable ( true ); wind . end (); wind . show (); app . run (). unwrap (); }","title":"Rust"},{"location":"Flutter/","text":"Flutter Dynamic List import 'package:flutter/material.dart' ; void main () => runApp ( MyApp ()); class MyApp extends StatelessWidget { @override Widget build ( BuildContext context ) { return MaterialApp ( debugShowCheckedModeBanner: false , title: 'MyApp' , theme: new ThemeData ( primarySwatch: Colors . green , ), home: Scaffold ( appBar: new AppBar ( title: new Text ( 'MyApp' ), ), body: BodyLayout (), ), ); } } class BodyLayout extends StatefulWidget { @override BodyLayoutState createState () { return new BodyLayoutState (); } } class BodyLayoutState extends State < BodyLayout > { var lst = [ \"aaa - tap to copy\" , \"bbb - tap to copy\" ]; @override Widget build ( BuildContext context ) { return _listBuild ( lst ); } ListView _listBuild ( List lst ) { return ListView . builder ( itemCount: lst . length , itemBuilder: ( BuildContext context , int index ) { return ListTile ( leading: CircleAvatar ( backgroundColor: Colors . lightGreenAccent , child: Text ( ' ${ index + 1 } ' ), ), title: Text ( ' ${ lst [ index ] } ' ), subtitle: Text ( ' ${ lst [ index ] } ' ), onTap: () { setState (() { lst . add ( lst [ index ]); }); }, ); }, ); } } Page Navigation import 'package:flutter/material.dart' ; void main () => runApp ( MyApp ()); class MyApp extends StatelessWidget { @override Widget build ( BuildContext context ) { return MaterialApp ( debugShowCheckedModeBanner: false , title: 'MyApp' , theme: new ThemeData ( primarySwatch: Colors . green , ), home: Scaffold ( appBar: new AppBar ( title: new Text ( 'MyApp' ), ), body: bodyLayout (), ), ); } } Widget bodyLayout () { var lst = [ \"aaa\" , \"bbb\" ]; var pages = [ ClassPageAAA (), ClassPageBBB ()]; return ListView . builder ( itemCount: lst . length , itemBuilder: ( BuildContext context , int index ) { return ListTile ( leading: CircleAvatar ( backgroundColor: Colors . lightGreenAccent , child: Text ( ' ${ index + 1 } ' ), ), title: Text ( ' ${ lst [ index ] } ' ), subtitle: Text ( ' ${ lst [ index ] } ' ), trailing: IconButton ( icon: Icon ( Icons . keyboard_arrow_right ), onPressed: () { Navigator . push ( context , MaterialPageRoute ( builder: ( context ) => pages [ index ]), ); }), ); }); } MaterialApp _page ( BuildContext context , String text ) { return MaterialApp ( debugShowCheckedModeBanner: false , title: text , theme: new ThemeData ( primarySwatch: Colors . green , ), home: Scaffold ( appBar: new AppBar ( title: new Text ( text ), leading: IconButton ( icon: Icon ( Icons . arrow_back ), onPressed: () => Navigator . pop ( context , false ), )), body: Text ( 'Page $ text ' ), ), ); } class ClassPageAAA extends StatelessWidget { @override Widget build ( BuildContext context ) { return _page ( context , 'AAA' ); } } class ClassPageBBB extends StatelessWidget { @override Widget build ( BuildContext context ) { return _page ( context , 'BBB' ); } } Input Fields import 'package:flutter/material.dart' ; void main () => runApp ( MyApp ()); class MyApp extends StatelessWidget { @override Widget build ( BuildContext context ) { return MaterialApp ( debugShowCheckedModeBanner: false , title: 'MyApp' , theme: new ThemeData ( primarySwatch: Colors . green , ), home: Scaffold ( appBar: new AppBar ( title: new Text ( 'MyApp' ), ), body: BodyLayout (), ), ); } } class BodyLayout extends StatefulWidget { @override BodyLayoutState createState () { return new BodyLayoutState (); } } class DataToElab { String f1 , f2 ; DataToElab ([ this . f1 = '0' , this . f2 = '0' ]); } class BodyLayoutState extends State < BodyLayout > { final contr1 = TextEditingController ( text: '0' ); final contr2 = TextEditingController ( text: '0' ); final contr3 = TextEditingController ( text: '0' ); DataToElab _dElab = DataToElab (); String _elabFields ( DataToElab dElab ) { var add1 = double . parse ( dElab . f1 ); var add2 = double . parse ( dElab . f2 ); var res = add1 + add2 ; return ' $ res ' ; } @override Widget build ( BuildContext context ) { return Form ( child: ListView ( children: < Widget > [ TextFormField ( controller: contr1 , decoration: const InputDecoration ( icon: const Icon ( Icons . euro_symbol ), hintText: 'Enter number' , labelText: 'First' , ), onFieldSubmitted: ( text ) { setState (() { _dElab . f1 = text ; var res = _elabFields ( _dElab ); contr3 . text = res ; }); }, ), TextFormField ( controller: contr2 , decoration: const InputDecoration ( icon: const Icon ( Icons . euro_symbol ), hintText: 'Enter number' , labelText: 'Second' , ), onFieldSubmitted: ( text ) { setState (() { _dElab . f2 = text ; var res = _elabFields ( _dElab ); contr3 . text = res ; }); }, ), TextFormField ( controller: contr3 , decoration: const InputDecoration ( icon: const Icon ( Icons . add_circle ), labelText: 'Result' , ), ), Padding ( padding: const EdgeInsets . symmetric ( horizontal: 64.0 ), child: RaisedButton ( onPressed: () { _dElab . f1 = contr1 . text ; _dElab . f2 = contr2 . text ; var res = _elabFields ( _dElab ); contr3 . text = res ; }, child: Text ( 'Calculate' ), ), ), ], ), ); } } Multiple Columns form import 'package:flutter/material.dart' ; void main () => runApp ( MyApp ()); class MyApp extends StatelessWidget { @override Widget build ( BuildContext context ) { return MaterialApp ( debugShowCheckedModeBanner: false , title: 'MyApp' , theme: new ThemeData ( primarySwatch: Colors . green , ), home: Scaffold ( appBar: new AppBar ( title: new Text ( 'MyApp' ), ), body: BodyLayout (), ), ); } } class BodyLayout extends StatefulWidget { @override BodyLayoutState createState () { return new BodyLayoutState (); } } class DataToElab { String f1 , f2 ; DataToElab ([ this . f1 = '0' , this . f2 = '0' ]); } class BodyLayoutState extends State < BodyLayout > { final contr1 = TextEditingController ( text: '0' ); final contr2 = TextEditingController ( text: '0' ); Column _form1 () { return Column ( children: < Widget > [ Flexible ( child: TextFormField ( controller: contr1 , decoration: const InputDecoration ( icon: const Icon ( Icons . euro_symbol ), hintText: 'Enter number' , labelText: 'First' , ), ), ), Flexible ( child: TextFormField ( controller: contr2 , decoration: const InputDecoration ( icon: const Icon ( Icons . euro_symbol ), hintText: 'Enter number' , labelText: 'Second' , ), ), ), ], ); } @override Widget build ( BuildContext context ) { return Column ( children: [ Flexible ( child: Row ( children: [ Flexible ( child: _form1 (), ), Flexible ( child: _form1 (), ), ], ), ), Flexible ( child: TextFormField ( //controller: contr3, decoration: const InputDecoration ( icon: const Icon ( Icons . add_circle ), labelText: 'Result' , ), ), ), Flexible ( child: Padding ( padding: const EdgeInsets . symmetric ( horizontal: 64.0 ), child: RaisedButton ( onPressed: () {}, child: Text ( 'Calculate' ), ), ), ), ], ); } } Persistence, Key/Value //dependencies: // shared_preferences: ^0.5.6 import 'package:shared_preferences/shared_preferences.dart' ; import 'package:flutter/material.dart' ; void main () => runApp ( MyApp ()); class MyApp extends StatelessWidget { @override Widget build ( BuildContext context ) { return MaterialApp ( debugShowCheckedModeBanner: false , title: 'MyApp' , theme: new ThemeData ( primarySwatch: Colors . green , ), home: Scaffold ( appBar: new AppBar ( title: new Text ( 'MyApp' ), ), body: BodyLayout (), ), ); } } Future < SharedPreferences > _getPrefs () async { final prefs = await SharedPreferences . getInstance (); return prefs ; } void _setVal ( SharedPreferences prefs , String key , int value ) { prefs . setInt ( key , value ); } int _getVal ( SharedPreferences prefs , String key ) { final value = prefs . getInt ( key ) ?? 0 ; return value ; } class BodyLayout extends StatefulWidget { @override BodyLayoutState createState () { return new BodyLayoutState (); } } class BodyLayoutState extends State < BodyLayout > { final contr3 = TextEditingController (); SharedPreferences _prefs ; @override void initState () { _getPrefs (). then (( onValue ) { _prefs = onValue ; //Init Output field with current key value var tmp = _getVal ( _prefs , 'key1' ); contr3 . text = ' $ tmp ' ; }); } @override Widget build ( BuildContext context ) { return Form ( child: ListView ( children: < Widget > [ TextFormField ( controller: contr3 , decoration: const InputDecoration ( icon: const Icon ( Icons . add_circle ), labelText: 'Key Value' , ), ), Padding ( padding: const EdgeInsets . symmetric ( horizontal: 64.0 ), child: RaisedButton ( onPressed: () { var tmp = _getVal ( _prefs , 'key1' ); tmp = tmp + 1 ; _setVal ( _prefs , 'key1' , tmp ); contr3 . text = ' $ tmp ' ; }, child: Text ( 'Inc Key' ), ), ), ], ), ); } } Notification // <uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\"/> //dependencies: // rxdart: ^0.24.0 // flutter_local_notifications: ^2.0.1 import 'dart:async' ; import 'package:flutter/cupertino.dart' ; import 'package:flutter/material.dart' ; import 'package:flutter_local_notifications/flutter_local_notifications.dart' ; import 'package:rxdart/subjects.dart' ; final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin = FlutterLocalNotificationsPlugin (); /// Streams are created so that app can respond to notification-related events /// since the plugin is initialised in the `main` function final BehaviorSubject < ReceivedNotification > didReceiveLocalNotificationSubject = BehaviorSubject < ReceivedNotification > (); final BehaviorSubject < String > selectNotificationSubject = BehaviorSubject < String > (); class ReceivedNotification { ReceivedNotification ({ @required this . id , @required this . title , @required this . body , @required this . payload , }); final int id ; final String title ; final String body ; final String payload ; } Future < void > main () async { // needed if you intend to initialize in the `main` function WidgetsFlutterBinding . ensureInitialized (); const AndroidInitializationSettings initializationSettingsAndroid = AndroidInitializationSettings ( 'app_icon' ); /// Note: permissions aren't requested here just to demonstrate that can be /// done later final InitializationSettings initializationSettings = InitializationSettings ( android: initializationSettingsAndroid ); await flutterLocalNotificationsPlugin . initialize ( initializationSettings , onSelectNotification: ( String payload ) async { selectNotificationSubject . add ( payload ); }); runApp ( MaterialApp ( home: HomePage (), ), ); } class HomePage extends StatefulWidget { @override _HomePageState createState () => _HomePageState (); } class _HomePageState extends State < HomePage > { int _counter = 0 ; @override void initState () { super . initState (); _configureSelectNotificationSubject (); } void _configureSelectNotificationSubject () { selectNotificationSubject . stream . listen (( String payload ) async { setState (() { _counter = _counter + 1 ; }); }); } @override void dispose () { didReceiveLocalNotificationSubject . close (); selectNotificationSubject . close (); super . dispose (); } @override Widget build ( BuildContext context ) => MaterialApp ( home: Scaffold ( appBar: AppBar ( title: const Text ( 'Plugin example app' ), ), body: Center ( child: RaisedButton ( child: Text ( 'Notify $ _counter ' ), onPressed: () async { await _showNotification (); }, ), ), ), ); Future < void > _showNotification () async { const AndroidNotificationDetails androidPlatformChannelSpecifics = AndroidNotificationDetails ( 'your channel id' , 'your channel name' , 'your channel description' , importance: Importance . max , priority: Priority . high , ticker: 'ticker' ); const NotificationDetails platformChannelSpecifics = NotificationDetails ( android: androidPlatformChannelSpecifics ); await flutterLocalNotificationsPlugin . show ( 0 , 'plain title' , 'plain body' , platformChannelSpecifics , payload: 'item x' ); } } Isolate, RSS Feed, Nullable values //dependencies: // http: ^0.13.3 // webfeed: ^0.7.0 // url_launcher: ^6.0.9 //add in AndroidManifest.xml // <queries> // <!-- If your app opens https URLs --> // <intent> // <action android:name=\"android.intent.action.VIEW\" /> // <data android:scheme=\"https\" /> // </intent> // </queries> // <uses-permission android:name=\"android.permission.INTERNET\"/> import 'dart:async' ; import 'package:flutter/material.dart' ; import 'dart:isolate' ; import 'package:http/http.dart' as http ; import 'package:webfeed/webfeed.dart' ; import 'package:url_launcher/url_launcher.dart' as launch ; void main () { runApp ( MyApp ()); } class MyApp extends StatefulWidget { const MyApp ({ Key ? key }) : super ( key: key ); @override _MyAppState createState () => _MyAppState (); } class _MyAppState extends State < MyApp > { static const int MAX_LIST_LENGTH = 30 ; late ReceivePort _receivePort ; late Isolate _isolate ; List < String > _titleLst = []; List < String > _linkLst = []; static bool _running = false ; void _start () async { _receivePort = ReceivePort (); _isolate = await Isolate . spawn ( _checkTimer , _receivePort . sendPort ); _running = true ; _receivePort . listen ( _handleMessage , onDone: () {}); } void _handleMessage ( dynamic tuple ) { setState (() { _titleLst . add ( tuple [ 0 ]); _linkLst . add ( tuple [ 1 ]); if ( _titleLst . length > MAX_LIST_LENGTH ) { _titleLst . removeLast (); } }); } static void _checkTimer ( SendPort sendPort ) async { var period = 10 ; Timer . periodic ( new Duration ( seconds: period ), ( Timer t ) { var feedUrl = \"https://hnrss.org/frontpage\" ; http . read ( Uri . parse ( feedUrl )). then (( text ) { var channel = RssFeed . parse ( text ); //nullable values handling in Flutter 2.6.0 if ( channel . items != null ) { //force channel.itens non null with '!' for ( var item in channel . items ! ) { sendPort . send ([ item . title , item . link ]); } } }); }); } void _stop () { setState (() { _running = false ; }); _receivePort . close (); _isolate . kill ( priority: Isolate . immediate ); } @override void initState () { _start (); super . initState (); } @override void dispose () { try { _isolate . kill (); } catch ( e ) {} super . dispose (); } ListView _listBuild ( List lst , List links ) { return ListView . builder ( itemCount: lst . length , itemBuilder: ( BuildContext context , int index ) { return ListTile ( leading: CircleAvatar ( backgroundColor: Colors . lightGreenAccent , child: Text ( ' ${ index + 1 } ' ), ), title: Text ( ' ${ lst [ index ] } ' ), onTap: () { print ( links [ index ]); launch . launch ( links [ index ]); }, ); }, ); } @override Widget build ( BuildContext context ) { return MaterialApp ( title: 'Welcome to Flutter' , home: Scaffold ( appBar: AppBar ( title: const Text ( 'HN Front Page' ), ), body: _listBuild ( _titleLst , _linkLst ), floatingActionButton: new FloatingActionButton ( onPressed: _running ? _stop : _start , child: _running ? new Icon ( Icons . stop ) : new Icon ( Icons . play_arrow ), ), ), ); } }","title":"Flutter"},{"location":"Flutter/#flutter","text":"","title":"Flutter"},{"location":"Flutter/#dynamic-list","text":"import 'package:flutter/material.dart' ; void main () => runApp ( MyApp ()); class MyApp extends StatelessWidget { @override Widget build ( BuildContext context ) { return MaterialApp ( debugShowCheckedModeBanner: false , title: 'MyApp' , theme: new ThemeData ( primarySwatch: Colors . green , ), home: Scaffold ( appBar: new AppBar ( title: new Text ( 'MyApp' ), ), body: BodyLayout (), ), ); } } class BodyLayout extends StatefulWidget { @override BodyLayoutState createState () { return new BodyLayoutState (); } } class BodyLayoutState extends State < BodyLayout > { var lst = [ \"aaa - tap to copy\" , \"bbb - tap to copy\" ]; @override Widget build ( BuildContext context ) { return _listBuild ( lst ); } ListView _listBuild ( List lst ) { return ListView . builder ( itemCount: lst . length , itemBuilder: ( BuildContext context , int index ) { return ListTile ( leading: CircleAvatar ( backgroundColor: Colors . lightGreenAccent , child: Text ( ' ${ index + 1 } ' ), ), title: Text ( ' ${ lst [ index ] } ' ), subtitle: Text ( ' ${ lst [ index ] } ' ), onTap: () { setState (() { lst . add ( lst [ index ]); }); }, ); }, ); } }","title":"Dynamic List"},{"location":"Flutter/#page-navigation","text":"import 'package:flutter/material.dart' ; void main () => runApp ( MyApp ()); class MyApp extends StatelessWidget { @override Widget build ( BuildContext context ) { return MaterialApp ( debugShowCheckedModeBanner: false , title: 'MyApp' , theme: new ThemeData ( primarySwatch: Colors . green , ), home: Scaffold ( appBar: new AppBar ( title: new Text ( 'MyApp' ), ), body: bodyLayout (), ), ); } } Widget bodyLayout () { var lst = [ \"aaa\" , \"bbb\" ]; var pages = [ ClassPageAAA (), ClassPageBBB ()]; return ListView . builder ( itemCount: lst . length , itemBuilder: ( BuildContext context , int index ) { return ListTile ( leading: CircleAvatar ( backgroundColor: Colors . lightGreenAccent , child: Text ( ' ${ index + 1 } ' ), ), title: Text ( ' ${ lst [ index ] } ' ), subtitle: Text ( ' ${ lst [ index ] } ' ), trailing: IconButton ( icon: Icon ( Icons . keyboard_arrow_right ), onPressed: () { Navigator . push ( context , MaterialPageRoute ( builder: ( context ) => pages [ index ]), ); }), ); }); } MaterialApp _page ( BuildContext context , String text ) { return MaterialApp ( debugShowCheckedModeBanner: false , title: text , theme: new ThemeData ( primarySwatch: Colors . green , ), home: Scaffold ( appBar: new AppBar ( title: new Text ( text ), leading: IconButton ( icon: Icon ( Icons . arrow_back ), onPressed: () => Navigator . pop ( context , false ), )), body: Text ( 'Page $ text ' ), ), ); } class ClassPageAAA extends StatelessWidget { @override Widget build ( BuildContext context ) { return _page ( context , 'AAA' ); } } class ClassPageBBB extends StatelessWidget { @override Widget build ( BuildContext context ) { return _page ( context , 'BBB' ); } }","title":"Page Navigation"},{"location":"Flutter/#input-fields","text":"import 'package:flutter/material.dart' ; void main () => runApp ( MyApp ()); class MyApp extends StatelessWidget { @override Widget build ( BuildContext context ) { return MaterialApp ( debugShowCheckedModeBanner: false , title: 'MyApp' , theme: new ThemeData ( primarySwatch: Colors . green , ), home: Scaffold ( appBar: new AppBar ( title: new Text ( 'MyApp' ), ), body: BodyLayout (), ), ); } } class BodyLayout extends StatefulWidget { @override BodyLayoutState createState () { return new BodyLayoutState (); } } class DataToElab { String f1 , f2 ; DataToElab ([ this . f1 = '0' , this . f2 = '0' ]); } class BodyLayoutState extends State < BodyLayout > { final contr1 = TextEditingController ( text: '0' ); final contr2 = TextEditingController ( text: '0' ); final contr3 = TextEditingController ( text: '0' ); DataToElab _dElab = DataToElab (); String _elabFields ( DataToElab dElab ) { var add1 = double . parse ( dElab . f1 ); var add2 = double . parse ( dElab . f2 ); var res = add1 + add2 ; return ' $ res ' ; } @override Widget build ( BuildContext context ) { return Form ( child: ListView ( children: < Widget > [ TextFormField ( controller: contr1 , decoration: const InputDecoration ( icon: const Icon ( Icons . euro_symbol ), hintText: 'Enter number' , labelText: 'First' , ), onFieldSubmitted: ( text ) { setState (() { _dElab . f1 = text ; var res = _elabFields ( _dElab ); contr3 . text = res ; }); }, ), TextFormField ( controller: contr2 , decoration: const InputDecoration ( icon: const Icon ( Icons . euro_symbol ), hintText: 'Enter number' , labelText: 'Second' , ), onFieldSubmitted: ( text ) { setState (() { _dElab . f2 = text ; var res = _elabFields ( _dElab ); contr3 . text = res ; }); }, ), TextFormField ( controller: contr3 , decoration: const InputDecoration ( icon: const Icon ( Icons . add_circle ), labelText: 'Result' , ), ), Padding ( padding: const EdgeInsets . symmetric ( horizontal: 64.0 ), child: RaisedButton ( onPressed: () { _dElab . f1 = contr1 . text ; _dElab . f2 = contr2 . text ; var res = _elabFields ( _dElab ); contr3 . text = res ; }, child: Text ( 'Calculate' ), ), ), ], ), ); } }","title":"Input Fields"},{"location":"Flutter/#multiple-columns-form","text":"import 'package:flutter/material.dart' ; void main () => runApp ( MyApp ()); class MyApp extends StatelessWidget { @override Widget build ( BuildContext context ) { return MaterialApp ( debugShowCheckedModeBanner: false , title: 'MyApp' , theme: new ThemeData ( primarySwatch: Colors . green , ), home: Scaffold ( appBar: new AppBar ( title: new Text ( 'MyApp' ), ), body: BodyLayout (), ), ); } } class BodyLayout extends StatefulWidget { @override BodyLayoutState createState () { return new BodyLayoutState (); } } class DataToElab { String f1 , f2 ; DataToElab ([ this . f1 = '0' , this . f2 = '0' ]); } class BodyLayoutState extends State < BodyLayout > { final contr1 = TextEditingController ( text: '0' ); final contr2 = TextEditingController ( text: '0' ); Column _form1 () { return Column ( children: < Widget > [ Flexible ( child: TextFormField ( controller: contr1 , decoration: const InputDecoration ( icon: const Icon ( Icons . euro_symbol ), hintText: 'Enter number' , labelText: 'First' , ), ), ), Flexible ( child: TextFormField ( controller: contr2 , decoration: const InputDecoration ( icon: const Icon ( Icons . euro_symbol ), hintText: 'Enter number' , labelText: 'Second' , ), ), ), ], ); } @override Widget build ( BuildContext context ) { return Column ( children: [ Flexible ( child: Row ( children: [ Flexible ( child: _form1 (), ), Flexible ( child: _form1 (), ), ], ), ), Flexible ( child: TextFormField ( //controller: contr3, decoration: const InputDecoration ( icon: const Icon ( Icons . add_circle ), labelText: 'Result' , ), ), ), Flexible ( child: Padding ( padding: const EdgeInsets . symmetric ( horizontal: 64.0 ), child: RaisedButton ( onPressed: () {}, child: Text ( 'Calculate' ), ), ), ), ], ); } }","title":"Multiple Columns form"},{"location":"Flutter/#persistence-keyvalue","text":"//dependencies: // shared_preferences: ^0.5.6 import 'package:shared_preferences/shared_preferences.dart' ; import 'package:flutter/material.dart' ; void main () => runApp ( MyApp ()); class MyApp extends StatelessWidget { @override Widget build ( BuildContext context ) { return MaterialApp ( debugShowCheckedModeBanner: false , title: 'MyApp' , theme: new ThemeData ( primarySwatch: Colors . green , ), home: Scaffold ( appBar: new AppBar ( title: new Text ( 'MyApp' ), ), body: BodyLayout (), ), ); } } Future < SharedPreferences > _getPrefs () async { final prefs = await SharedPreferences . getInstance (); return prefs ; } void _setVal ( SharedPreferences prefs , String key , int value ) { prefs . setInt ( key , value ); } int _getVal ( SharedPreferences prefs , String key ) { final value = prefs . getInt ( key ) ?? 0 ; return value ; } class BodyLayout extends StatefulWidget { @override BodyLayoutState createState () { return new BodyLayoutState (); } } class BodyLayoutState extends State < BodyLayout > { final contr3 = TextEditingController (); SharedPreferences _prefs ; @override void initState () { _getPrefs (). then (( onValue ) { _prefs = onValue ; //Init Output field with current key value var tmp = _getVal ( _prefs , 'key1' ); contr3 . text = ' $ tmp ' ; }); } @override Widget build ( BuildContext context ) { return Form ( child: ListView ( children: < Widget > [ TextFormField ( controller: contr3 , decoration: const InputDecoration ( icon: const Icon ( Icons . add_circle ), labelText: 'Key Value' , ), ), Padding ( padding: const EdgeInsets . symmetric ( horizontal: 64.0 ), child: RaisedButton ( onPressed: () { var tmp = _getVal ( _prefs , 'key1' ); tmp = tmp + 1 ; _setVal ( _prefs , 'key1' , tmp ); contr3 . text = ' $ tmp ' ; }, child: Text ( 'Inc Key' ), ), ), ], ), ); } }","title":"Persistence, Key/Value"},{"location":"Flutter/#notification","text":"// <uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\"/> //dependencies: // rxdart: ^0.24.0 // flutter_local_notifications: ^2.0.1 import 'dart:async' ; import 'package:flutter/cupertino.dart' ; import 'package:flutter/material.dart' ; import 'package:flutter_local_notifications/flutter_local_notifications.dart' ; import 'package:rxdart/subjects.dart' ; final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin = FlutterLocalNotificationsPlugin (); /// Streams are created so that app can respond to notification-related events /// since the plugin is initialised in the `main` function final BehaviorSubject < ReceivedNotification > didReceiveLocalNotificationSubject = BehaviorSubject < ReceivedNotification > (); final BehaviorSubject < String > selectNotificationSubject = BehaviorSubject < String > (); class ReceivedNotification { ReceivedNotification ({ @required this . id , @required this . title , @required this . body , @required this . payload , }); final int id ; final String title ; final String body ; final String payload ; } Future < void > main () async { // needed if you intend to initialize in the `main` function WidgetsFlutterBinding . ensureInitialized (); const AndroidInitializationSettings initializationSettingsAndroid = AndroidInitializationSettings ( 'app_icon' ); /// Note: permissions aren't requested here just to demonstrate that can be /// done later final InitializationSettings initializationSettings = InitializationSettings ( android: initializationSettingsAndroid ); await flutterLocalNotificationsPlugin . initialize ( initializationSettings , onSelectNotification: ( String payload ) async { selectNotificationSubject . add ( payload ); }); runApp ( MaterialApp ( home: HomePage (), ), ); } class HomePage extends StatefulWidget { @override _HomePageState createState () => _HomePageState (); } class _HomePageState extends State < HomePage > { int _counter = 0 ; @override void initState () { super . initState (); _configureSelectNotificationSubject (); } void _configureSelectNotificationSubject () { selectNotificationSubject . stream . listen (( String payload ) async { setState (() { _counter = _counter + 1 ; }); }); } @override void dispose () { didReceiveLocalNotificationSubject . close (); selectNotificationSubject . close (); super . dispose (); } @override Widget build ( BuildContext context ) => MaterialApp ( home: Scaffold ( appBar: AppBar ( title: const Text ( 'Plugin example app' ), ), body: Center ( child: RaisedButton ( child: Text ( 'Notify $ _counter ' ), onPressed: () async { await _showNotification (); }, ), ), ), ); Future < void > _showNotification () async { const AndroidNotificationDetails androidPlatformChannelSpecifics = AndroidNotificationDetails ( 'your channel id' , 'your channel name' , 'your channel description' , importance: Importance . max , priority: Priority . high , ticker: 'ticker' ); const NotificationDetails platformChannelSpecifics = NotificationDetails ( android: androidPlatformChannelSpecifics ); await flutterLocalNotificationsPlugin . show ( 0 , 'plain title' , 'plain body' , platformChannelSpecifics , payload: 'item x' ); } }","title":"Notification"},{"location":"Flutter/#isolate-rss-feed-nullable-values","text":"//dependencies: // http: ^0.13.3 // webfeed: ^0.7.0 // url_launcher: ^6.0.9 //add in AndroidManifest.xml // <queries> // <!-- If your app opens https URLs --> // <intent> // <action android:name=\"android.intent.action.VIEW\" /> // <data android:scheme=\"https\" /> // </intent> // </queries> // <uses-permission android:name=\"android.permission.INTERNET\"/> import 'dart:async' ; import 'package:flutter/material.dart' ; import 'dart:isolate' ; import 'package:http/http.dart' as http ; import 'package:webfeed/webfeed.dart' ; import 'package:url_launcher/url_launcher.dart' as launch ; void main () { runApp ( MyApp ()); } class MyApp extends StatefulWidget { const MyApp ({ Key ? key }) : super ( key: key ); @override _MyAppState createState () => _MyAppState (); } class _MyAppState extends State < MyApp > { static const int MAX_LIST_LENGTH = 30 ; late ReceivePort _receivePort ; late Isolate _isolate ; List < String > _titleLst = []; List < String > _linkLst = []; static bool _running = false ; void _start () async { _receivePort = ReceivePort (); _isolate = await Isolate . spawn ( _checkTimer , _receivePort . sendPort ); _running = true ; _receivePort . listen ( _handleMessage , onDone: () {}); } void _handleMessage ( dynamic tuple ) { setState (() { _titleLst . add ( tuple [ 0 ]); _linkLst . add ( tuple [ 1 ]); if ( _titleLst . length > MAX_LIST_LENGTH ) { _titleLst . removeLast (); } }); } static void _checkTimer ( SendPort sendPort ) async { var period = 10 ; Timer . periodic ( new Duration ( seconds: period ), ( Timer t ) { var feedUrl = \"https://hnrss.org/frontpage\" ; http . read ( Uri . parse ( feedUrl )). then (( text ) { var channel = RssFeed . parse ( text ); //nullable values handling in Flutter 2.6.0 if ( channel . items != null ) { //force channel.itens non null with '!' for ( var item in channel . items ! ) { sendPort . send ([ item . title , item . link ]); } } }); }); } void _stop () { setState (() { _running = false ; }); _receivePort . close (); _isolate . kill ( priority: Isolate . immediate ); } @override void initState () { _start (); super . initState (); } @override void dispose () { try { _isolate . kill (); } catch ( e ) {} super . dispose (); } ListView _listBuild ( List lst , List links ) { return ListView . builder ( itemCount: lst . length , itemBuilder: ( BuildContext context , int index ) { return ListTile ( leading: CircleAvatar ( backgroundColor: Colors . lightGreenAccent , child: Text ( ' ${ index + 1 } ' ), ), title: Text ( ' ${ lst [ index ] } ' ), onTap: () { print ( links [ index ]); launch . launch ( links [ index ]); }, ); }, ); } @override Widget build ( BuildContext context ) { return MaterialApp ( title: 'Welcome to Flutter' , home: Scaffold ( appBar: AppBar ( title: const Text ( 'HN Front Page' ), ), body: _listBuild ( _titleLst , _linkLst ), floatingActionButton: new FloatingActionButton ( onPressed: _running ? _stop : _start , child: _running ? new Icon ( Icons . stop ) : new Icon ( Icons . play_arrow ), ), ), ); } }","title":"Isolate, RSS Feed, Nullable values"},{"location":"For%20Enumerate/","text":"For Enumerate C# using System ; using System.Linq ; using System.Collections.Generic ; public class Program { public static void Main ( string [] args ) { var lst = new List < int >{ 10 , 20 , 30 }; foreach ( var item in lst . Select (( value , index ) => new { index , value })) { Console . WriteLine ( \"Index {0}, value {1}\" , item . index , item . value ); } } } Dart main () async { var lst = [ 10 , 20 , 30 ]; var ilist = lst . asMap (); ilist . forEach (( index , value ) => print ( \"Index $ index , value $ value \" ) ); } Go package main import ( \"fmt\" ) func main () { lst := [] int { 10 , 20 , 30 } for index , value := range ( lst ) { fmt . Printf ( \"\\nIndex %d, value %d\" , index , value ) } } Nim import strformat let lst = [ 10 , 20 , 30 ] for index , value in lst : echo & \"index {index} value {value}\" Python lst = [ 10 , 20 , 30 ] for index , value in enumerate ( lst ): print ( f \"Index {index} , value {value} \" ) Rust fn main () { let lst = vec ! [ 10 , 20 , 30 ]; for ( index , value ) in lst . iter (). enumerate () { println ! ( \"Index {}, value {}\" , index , value ); } }","title":"For Enumerate"},{"location":"For%20Enumerate/#for-enumerate","text":"","title":"For Enumerate"},{"location":"For%20Enumerate/#c","text":"using System ; using System.Linq ; using System.Collections.Generic ; public class Program { public static void Main ( string [] args ) { var lst = new List < int >{ 10 , 20 , 30 }; foreach ( var item in lst . Select (( value , index ) => new { index , value })) { Console . WriteLine ( \"Index {0}, value {1}\" , item . index , item . value ); } } }","title":"C#"},{"location":"For%20Enumerate/#dart","text":"main () async { var lst = [ 10 , 20 , 30 ]; var ilist = lst . asMap (); ilist . forEach (( index , value ) => print ( \"Index $ index , value $ value \" ) ); }","title":"Dart"},{"location":"For%20Enumerate/#go","text":"package main import ( \"fmt\" ) func main () { lst := [] int { 10 , 20 , 30 } for index , value := range ( lst ) { fmt . Printf ( \"\\nIndex %d, value %d\" , index , value ) } }","title":"Go"},{"location":"For%20Enumerate/#nim","text":"import strformat let lst = [ 10 , 20 , 30 ] for index , value in lst : echo & \"index {index} value {value}\"","title":"Nim"},{"location":"For%20Enumerate/#python","text":"lst = [ 10 , 20 , 30 ] for index , value in enumerate ( lst ): print ( f \"Index {index} , value {value} \" )","title":"Python"},{"location":"For%20Enumerate/#rust","text":"fn main () { let lst = vec ! [ 10 , 20 , 30 ]; for ( index , value ) in lst . iter (). enumerate () { println ! ( \"Index {}, value {}\" , index , value ); } }","title":"Rust"},{"location":"For%20Range/","text":"For Range C# using System ; public class Program { public static void Main ( string [] args ) { for ( var idx = 0 ; idx < 10 ; idx ++) { Console . WriteLine ( \"Index {0}\" , idx ); } } } Dart main () async { for ( var idx = 0 ; idx < 10 ; idx ++ ) { print ( \"Index $ idx \" ); } } Go package main import ( \"fmt\" ) func main () { for idx := 0 ; idx < 10 ; idx ++ { fmt . Printf ( \"\\nIndex %d\" , idx ) } } Nim import strformat # last number included for idx in countup ( 0 , 9 , 1 ): echo & \"Index {idx}\" Python # last number excluded for idx in range ( 0 , 10 , 1 ): print ( f \"Index {idx} \" ) Rust fn main () { //last number excluded for idx in ( 0 .. 10 ). step_by ( 1 ) { println ! ( \"Index {}\" , idx ); } }","title":"For Range"},{"location":"For%20Range/#for-range","text":"","title":"For Range"},{"location":"For%20Range/#c","text":"using System ; public class Program { public static void Main ( string [] args ) { for ( var idx = 0 ; idx < 10 ; idx ++) { Console . WriteLine ( \"Index {0}\" , idx ); } } }","title":"C#"},{"location":"For%20Range/#dart","text":"main () async { for ( var idx = 0 ; idx < 10 ; idx ++ ) { print ( \"Index $ idx \" ); } }","title":"Dart"},{"location":"For%20Range/#go","text":"package main import ( \"fmt\" ) func main () { for idx := 0 ; idx < 10 ; idx ++ { fmt . Printf ( \"\\nIndex %d\" , idx ) } }","title":"Go"},{"location":"For%20Range/#nim","text":"import strformat # last number included for idx in countup ( 0 , 9 , 1 ): echo & \"Index {idx}\"","title":"Nim"},{"location":"For%20Range/#python","text":"# last number excluded for idx in range ( 0 , 10 , 1 ): print ( f \"Index {idx} \" )","title":"Python"},{"location":"For%20Range/#rust","text":"fn main () { //last number excluded for idx in ( 0 .. 10 ). step_by ( 1 ) { println ! ( \"Index {}\" , idx ); } }","title":"Rust"},{"location":"Fyne/","text":"Fyne Go //go.mod //require fyne.io/fyne/v2 v2.1.0 package main import ( . \"fmt\" \"fyne.io/fyne/v2\" \"fyne.io/fyne/v2/app\" \"fyne.io/fyne/v2/container\" \"fyne.io/fyne/v2/widget\" ) const WIN_WIDTH = 800 const WIN_HEIGHT = 600 func main () { app := app . New () wind := app . NewWindow ( \"Fyne test\" ) wind . Resize ( fyne . Size { Height : WIN_HEIGHT , Width : WIN_WIDTH }) count := 0 lb1 := widget . NewLabel ( \"Result below\" ) lb2 := widget . NewLabel ( \"\" ) var bt1 * widget . Button bt1 = widget . NewButton ( \"Press\" , func () { count = count + 1 lb2 . SetText ( Sprintf ( \"Count: %d\" , count )) bt1 . SetText ( \"Again\" ) }) wind . SetContent ( container . NewVBox ( container . NewCenter ( container . NewVBox ( lb1 , lb2 , ), ), container . NewCenter ( bt1 ), ), ) wind . ShowAndRun () }","title":"Fyne"},{"location":"Fyne/#fyne","text":"","title":"Fyne"},{"location":"Fyne/#go","text":"//go.mod //require fyne.io/fyne/v2 v2.1.0 package main import ( . \"fmt\" \"fyne.io/fyne/v2\" \"fyne.io/fyne/v2/app\" \"fyne.io/fyne/v2/container\" \"fyne.io/fyne/v2/widget\" ) const WIN_WIDTH = 800 const WIN_HEIGHT = 600 func main () { app := app . New () wind := app . NewWindow ( \"Fyne test\" ) wind . Resize ( fyne . Size { Height : WIN_HEIGHT , Width : WIN_WIDTH }) count := 0 lb1 := widget . NewLabel ( \"Result below\" ) lb2 := widget . NewLabel ( \"\" ) var bt1 * widget . Button bt1 = widget . NewButton ( \"Press\" , func () { count = count + 1 lb2 . SetText ( Sprintf ( \"Count: %d\" , count )) bt1 . SetText ( \"Again\" ) }) wind . SetContent ( container . NewVBox ( container . NewCenter ( container . NewVBox ( lb1 , lb2 , ), ), container . NewCenter ( bt1 ), ), ) wind . ShowAndRun () }","title":"Go"},{"location":"GTK/","text":"GTK Go package main import ( \"fmt\" \"os\" \"github.com/gotk3/gotk3/glib\" \"github.com/gotk3/gotk3/gtk\" ) func main () { app , _ := gtk . ApplicationNew ( \"org.gtk.example\" , glib . APPLICATION_FLAGS_NONE ) count := 0 app . Connect ( \"activate\" , func () { b , _ := gtk . BuilderNew () b . AddFromFile ( \"builder.ui\" ) obj , _ := b . GetObject ( \"window\" ) win := obj .( * gtk . ApplicationWindow ) obj , _ = b . GetObject ( \"button1\" ) button1 := obj .( * gtk . Button ) obj , _ = b . GetObject ( \"quit\" ) bQuit := obj .( * gtk . Button ) obj , _ = b . GetObject ( \"label1\" ) label := obj .( * gtk . Label ) cStr := fmt . Sprintf ( \" %d\" , count ) label . SetText ( cStr ) button1 . Connect ( \"clicked\" , func () { count += 1 cStr := fmt . Sprintf ( \" %d\" , count ) label . SetText ( cStr ) }) bQuit . Connect ( \"clicked\" , func () { fmt . Println ( \"Bye\" ) win . Destroy () }) win . ShowAll () app . AddWindow ( win ) }) app . Run ( os . Args ) } Nim # nimble install gintro import gintro /[ gtk , gobject , gio ] import strformat var count = 0 proc hello ( b : Button ; lbl : Label ) = count += 1 lbl . text = & \" {count} \" proc quitApp ( b : Button ; app : Application ) = echo \"Bye\" quit ( app ) proc appActivate ( app : Application ) = let builder = newBuilder () discard builder . addFromFile ( \"builder.ui\" ) let window = builder . getApplicationWindow ( \"window\" ) window . setApplication ( app ) var button = builder . getButton ( \"button1\" ) let label = builder . getLabel ( \"label1\" ) button . connect ( \"clicked\" , hello , label ) button = builder . getButton ( \"quit\" ) button . connect ( \"clicked\" , quitApp , app ) proc main = let app = newApplication ( \"org.gtk.example\" ) connect ( app , \"activate\" , appActivate ) discard run ( app ) main () Python # Tested in Ubuntu 18.04 import gi gi . require_version ( 'Gtk' , '3.0' ) from gi.repository import Gtk count = 0 def on_button_clicked ( widget ): global count label : Gtk . Label = builder . get_object ( \"label1\" ) count += 1 label . set_text ( f \" {count} \" ) def on_b_quit_clicked ( widget ): print ( \"Bye\" ) quit () builder = Gtk . Builder () builder . add_from_file ( \"builder.ui\" ) window = builder . get_object ( \"window\" ) button = builder . get_object ( \"button1\" ) label = builder . get_object ( \"label1\" ) b_quit = builder . get_object ( \"quit\" ) button . connect ( \"clicked\" , on_button_clicked ) b_quit . connect ( \"clicked\" , on_b_quit_clicked ) window . show_all () Gtk . main () Rust //[dependencies] //gio = \"0.7.0\" //gtk = \"0.7.0\" //rustup default stable-x86_64-pc-windows-gnu use gio :: prelude :: * ; use gtk :: prelude :: * ; use gtk :: * ; use std :: cell :: RefCell ; use std :: env :: args ; use std :: rc :: Rc ; //utility functions //get generic object from builder fn get_gen_obj < T : IsA < Object >> ( id : & str , builder : & Builder ) -> T { let gen_obj : T = builder . get_object ( id ) . expect ( & format ! ( \"Couldn't get {}\" , id )); gen_obj } fn get_num_label_val ( id : & str , builder : & Builder ) -> i32 { let lbl1 : Label = get_gen_obj ( id , builder ); let l1val = lbl1 . get_text () . and_then ( | s | s . trim (). parse :: < i32 > (). ok ()) . unwrap_or ( 0 ); l1val } fn set_num_label_val ( id : & str , builder : & Builder , val : i32 ) { let lbl1 : Label = get_gen_obj ( id , builder ); lbl1 . set_text ( & format ! ( \" {}\" , val )); } // utility end fn app_activate ( application : & Application ) { // First we get the file content. let glade_src = include_str ! ( \"builder.ui\" ); // Then we call the Builder call. let builder = Builder :: new_from_string ( glade_src ); let window : ApplicationWindow = get_gen_obj ( \"window\" , & builder ); window . set_application ( Some ( application )); let button : Button = get_gen_obj ( \"button1\" , & builder ); let label : Label = get_gen_obj ( \"label1\" , & builder ); label . set_text ( & format ! ( \" {} \" , 0 )); //to avoid moving builder so that it can be accessed later let builder_rc_1 = Rc :: new ( RefCell :: new ( builder . clone ())); button . connect_clicked ( move | _ | { let builder_ptr = & ( * builder_rc_1 . borrow ()); //increment counter in label1 text let mut count = get_num_label_val ( \"label1\" , builder_ptr ); count += 1 ; set_num_label_val ( \"label1\" , builder_ptr , count ); }); let q_button : Button = get_gen_obj ( \"quit\" , & builder ); //avoid ownership check to use \"window\" inside the closure let window_weak = window . downgrade (); q_button . connect_clicked ( move | _ | { println ! ( \"Bye\" ); let window = window_weak . upgrade (). unwrap (); window . destroy (); }); window . show_all (); } fn main () { let application = Application :: new ( Some ( \"org.gtk.example\" ), Default :: default ()) . expect ( \"Initialization failed...\" ); application . connect_activate ( move | app | { app_activate ( app ); }); application . run ( & args (). collect :: < Vec < _ >> ()); } builder.ui Generated with Glade <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!-- Generated with glade 3.22.1 --> <interface> <requires lib= \"gtk+\" version= \"3.0\" /> <object class= \"GtkApplicationWindow\" id= \"window\" > <property name= \"visible\" > True </property> <property name= \"can_focus\" > False </property> <property name= \"border_width\" > 10 </property> <property name= \"title\" > Grid </property> <child> <placeholder/> </child> <child> <object class= \"GtkGrid\" id= \"grid\" > <property name= \"visible\" > True </property> <property name= \"can_focus\" > False </property> <child> <object class= \"GtkButton\" id= \"button1\" > <property name= \"label\" > Button 1 </property> <property name= \"visible\" > True </property> <property name= \"can_focus\" > False </property> <property name= \"receives_default\" > False </property> </object> <packing> <property name= \"left_attach\" > 0 </property> <property name= \"top_attach\" > 0 </property> </packing> </child> <child> <object class= \"GtkButton\" id= \"quit\" > <property name= \"label\" > Quit </property> <property name= \"visible\" > True </property> <property name= \"can_focus\" > False </property> <property name= \"receives_default\" > False </property> </object> <packing> <property name= \"left_attach\" > 0 </property> <property name= \"top_attach\" > 1 </property> <property name= \"width\" > 2 </property> </packing> </child> <child> <object class= \"GtkLabel\" id= \"label1\" > <property name= \"visible\" > True </property> <property name= \"can_focus\" > False </property> <property name= \"label\" translatable= \"yes\" > label </property> </object> <packing> <property name= \"left_attach\" > 1 </property> <property name= \"top_attach\" > 0 </property> </packing> </child> </object> </child> </object> </interface>","title":"GTK"},{"location":"GTK/#gtk","text":"","title":"GTK"},{"location":"GTK/#go","text":"package main import ( \"fmt\" \"os\" \"github.com/gotk3/gotk3/glib\" \"github.com/gotk3/gotk3/gtk\" ) func main () { app , _ := gtk . ApplicationNew ( \"org.gtk.example\" , glib . APPLICATION_FLAGS_NONE ) count := 0 app . Connect ( \"activate\" , func () { b , _ := gtk . BuilderNew () b . AddFromFile ( \"builder.ui\" ) obj , _ := b . GetObject ( \"window\" ) win := obj .( * gtk . ApplicationWindow ) obj , _ = b . GetObject ( \"button1\" ) button1 := obj .( * gtk . Button ) obj , _ = b . GetObject ( \"quit\" ) bQuit := obj .( * gtk . Button ) obj , _ = b . GetObject ( \"label1\" ) label := obj .( * gtk . Label ) cStr := fmt . Sprintf ( \" %d\" , count ) label . SetText ( cStr ) button1 . Connect ( \"clicked\" , func () { count += 1 cStr := fmt . Sprintf ( \" %d\" , count ) label . SetText ( cStr ) }) bQuit . Connect ( \"clicked\" , func () { fmt . Println ( \"Bye\" ) win . Destroy () }) win . ShowAll () app . AddWindow ( win ) }) app . Run ( os . Args ) }","title":"Go"},{"location":"GTK/#nim","text":"# nimble install gintro import gintro /[ gtk , gobject , gio ] import strformat var count = 0 proc hello ( b : Button ; lbl : Label ) = count += 1 lbl . text = & \" {count} \" proc quitApp ( b : Button ; app : Application ) = echo \"Bye\" quit ( app ) proc appActivate ( app : Application ) = let builder = newBuilder () discard builder . addFromFile ( \"builder.ui\" ) let window = builder . getApplicationWindow ( \"window\" ) window . setApplication ( app ) var button = builder . getButton ( \"button1\" ) let label = builder . getLabel ( \"label1\" ) button . connect ( \"clicked\" , hello , label ) button = builder . getButton ( \"quit\" ) button . connect ( \"clicked\" , quitApp , app ) proc main = let app = newApplication ( \"org.gtk.example\" ) connect ( app , \"activate\" , appActivate ) discard run ( app ) main ()","title":"Nim"},{"location":"GTK/#python","text":"# Tested in Ubuntu 18.04 import gi gi . require_version ( 'Gtk' , '3.0' ) from gi.repository import Gtk count = 0 def on_button_clicked ( widget ): global count label : Gtk . Label = builder . get_object ( \"label1\" ) count += 1 label . set_text ( f \" {count} \" ) def on_b_quit_clicked ( widget ): print ( \"Bye\" ) quit () builder = Gtk . Builder () builder . add_from_file ( \"builder.ui\" ) window = builder . get_object ( \"window\" ) button = builder . get_object ( \"button1\" ) label = builder . get_object ( \"label1\" ) b_quit = builder . get_object ( \"quit\" ) button . connect ( \"clicked\" , on_button_clicked ) b_quit . connect ( \"clicked\" , on_b_quit_clicked ) window . show_all () Gtk . main ()","title":"Python"},{"location":"GTK/#rust","text":"//[dependencies] //gio = \"0.7.0\" //gtk = \"0.7.0\" //rustup default stable-x86_64-pc-windows-gnu use gio :: prelude :: * ; use gtk :: prelude :: * ; use gtk :: * ; use std :: cell :: RefCell ; use std :: env :: args ; use std :: rc :: Rc ; //utility functions //get generic object from builder fn get_gen_obj < T : IsA < Object >> ( id : & str , builder : & Builder ) -> T { let gen_obj : T = builder . get_object ( id ) . expect ( & format ! ( \"Couldn't get {}\" , id )); gen_obj } fn get_num_label_val ( id : & str , builder : & Builder ) -> i32 { let lbl1 : Label = get_gen_obj ( id , builder ); let l1val = lbl1 . get_text () . and_then ( | s | s . trim (). parse :: < i32 > (). ok ()) . unwrap_or ( 0 ); l1val } fn set_num_label_val ( id : & str , builder : & Builder , val : i32 ) { let lbl1 : Label = get_gen_obj ( id , builder ); lbl1 . set_text ( & format ! ( \" {}\" , val )); } // utility end fn app_activate ( application : & Application ) { // First we get the file content. let glade_src = include_str ! ( \"builder.ui\" ); // Then we call the Builder call. let builder = Builder :: new_from_string ( glade_src ); let window : ApplicationWindow = get_gen_obj ( \"window\" , & builder ); window . set_application ( Some ( application )); let button : Button = get_gen_obj ( \"button1\" , & builder ); let label : Label = get_gen_obj ( \"label1\" , & builder ); label . set_text ( & format ! ( \" {} \" , 0 )); //to avoid moving builder so that it can be accessed later let builder_rc_1 = Rc :: new ( RefCell :: new ( builder . clone ())); button . connect_clicked ( move | _ | { let builder_ptr = & ( * builder_rc_1 . borrow ()); //increment counter in label1 text let mut count = get_num_label_val ( \"label1\" , builder_ptr ); count += 1 ; set_num_label_val ( \"label1\" , builder_ptr , count ); }); let q_button : Button = get_gen_obj ( \"quit\" , & builder ); //avoid ownership check to use \"window\" inside the closure let window_weak = window . downgrade (); q_button . connect_clicked ( move | _ | { println ! ( \"Bye\" ); let window = window_weak . upgrade (). unwrap (); window . destroy (); }); window . show_all (); } fn main () { let application = Application :: new ( Some ( \"org.gtk.example\" ), Default :: default ()) . expect ( \"Initialization failed...\" ); application . connect_activate ( move | app | { app_activate ( app ); }); application . run ( & args (). collect :: < Vec < _ >> ()); }","title":"Rust"},{"location":"GTK/#builderui","text":"Generated with Glade <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!-- Generated with glade 3.22.1 --> <interface> <requires lib= \"gtk+\" version= \"3.0\" /> <object class= \"GtkApplicationWindow\" id= \"window\" > <property name= \"visible\" > True </property> <property name= \"can_focus\" > False </property> <property name= \"border_width\" > 10 </property> <property name= \"title\" > Grid </property> <child> <placeholder/> </child> <child> <object class= \"GtkGrid\" id= \"grid\" > <property name= \"visible\" > True </property> <property name= \"can_focus\" > False </property> <child> <object class= \"GtkButton\" id= \"button1\" > <property name= \"label\" > Button 1 </property> <property name= \"visible\" > True </property> <property name= \"can_focus\" > False </property> <property name= \"receives_default\" > False </property> </object> <packing> <property name= \"left_attach\" > 0 </property> <property name= \"top_attach\" > 0 </property> </packing> </child> <child> <object class= \"GtkButton\" id= \"quit\" > <property name= \"label\" > Quit </property> <property name= \"visible\" > True </property> <property name= \"can_focus\" > False </property> <property name= \"receives_default\" > False </property> </object> <packing> <property name= \"left_attach\" > 0 </property> <property name= \"top_attach\" > 1 </property> <property name= \"width\" > 2 </property> </packing> </child> <child> <object class= \"GtkLabel\" id= \"label1\" > <property name= \"visible\" > True </property> <property name= \"can_focus\" > False </property> <property name= \"label\" translatable= \"yes\" > label </property> </object> <packing> <property name= \"left_attach\" > 1 </property> <property name= \"top_attach\" > 0 </property> </packing> </child> </object> </child> </object> </interface>","title":"builder.ui"},{"location":"Globals/","text":"Globals Rust //[dependencies] //lazy_static = \"1.4.0\" use lazy_static :: lazy_static ; use std :: sync :: Mutex ; #[derive(Debug, Clone)] struct STRUCT1 { x : i32 , s : String , } lazy_static ! { // Global unmutable initialized safe static ref GLOBAL_S : STRUCT1 = STRUCT1 { x : 10 , s : String :: from ( \"GLOBAL_S\" ) }; // Global mutable initialized safe static ref GLOBAL_S_M : Mutex < STRUCT1 > = Mutex :: new ( STRUCT1 { x : 10 , s : String :: from ( \"GLOBAL_S_M\" ) }); } //Global mutable inizialized unsafe static mut GLOBAL_MUT : Vec < i32 > = vec ! []; //Global mutable uninizialized unsafe static mut GLOBAL_MUT_UNINIT : Option < STRUCT1 > = None ; fn main () { println ! ( \"{} {}\" , GLOBAL_S . x , GLOBAL_S . s ); let mut sm = GLOBAL_S_M . lock (). unwrap (); println ! ( \"{} {}\" , sm . x , sm . s ); sm . x = 11 ; println ! ( \"{} {}\" , sm . x , sm . s ); //unlock std :: mem :: drop ( sm ); unsafe { GLOBAL_MUT . push ( 20 ); } unsafe { GLOBAL_MUT_UNINIT = Some ( STRUCT1 { x : 30 , s : String :: from ( \"GLOBAL_MUT_UNINIT\" ), }); } unsafe { GLOBAL_MUT_UNINIT = Some ( STRUCT1 { x : 30 , s : String :: from ( \"GLOBAL_MUT_UNINIT\" ), }); } unsafe { match GLOBAL_MUT_UNINIT { None => (), Some ( ref mut st ) => { st . x = 40 ; } } } fn1 (); } fn fn1 () { unsafe { println ! ( \"Inside fn1 {}\" , GLOBAL_MUT [ 0 ]); } unsafe { let struct2 = match GLOBAL_MUT_UNINIT { None => panic ! ( \"error\" ), Some ( ref mut s ) => { s . x = 41 ; s } }; println ! ( \"{:?}\" , struct2 ); } }","title":"Globals"},{"location":"Globals/#globals","text":"","title":"Globals"},{"location":"Globals/#rust","text":"//[dependencies] //lazy_static = \"1.4.0\" use lazy_static :: lazy_static ; use std :: sync :: Mutex ; #[derive(Debug, Clone)] struct STRUCT1 { x : i32 , s : String , } lazy_static ! { // Global unmutable initialized safe static ref GLOBAL_S : STRUCT1 = STRUCT1 { x : 10 , s : String :: from ( \"GLOBAL_S\" ) }; // Global mutable initialized safe static ref GLOBAL_S_M : Mutex < STRUCT1 > = Mutex :: new ( STRUCT1 { x : 10 , s : String :: from ( \"GLOBAL_S_M\" ) }); } //Global mutable inizialized unsafe static mut GLOBAL_MUT : Vec < i32 > = vec ! []; //Global mutable uninizialized unsafe static mut GLOBAL_MUT_UNINIT : Option < STRUCT1 > = None ; fn main () { println ! ( \"{} {}\" , GLOBAL_S . x , GLOBAL_S . s ); let mut sm = GLOBAL_S_M . lock (). unwrap (); println ! ( \"{} {}\" , sm . x , sm . s ); sm . x = 11 ; println ! ( \"{} {}\" , sm . x , sm . s ); //unlock std :: mem :: drop ( sm ); unsafe { GLOBAL_MUT . push ( 20 ); } unsafe { GLOBAL_MUT_UNINIT = Some ( STRUCT1 { x : 30 , s : String :: from ( \"GLOBAL_MUT_UNINIT\" ), }); } unsafe { GLOBAL_MUT_UNINIT = Some ( STRUCT1 { x : 30 , s : String :: from ( \"GLOBAL_MUT_UNINIT\" ), }); } unsafe { match GLOBAL_MUT_UNINIT { None => (), Some ( ref mut st ) => { st . x = 40 ; } } } fn1 (); } fn fn1 () { unsafe { println ! ( \"Inside fn1 {}\" , GLOBAL_MUT [ 0 ]); } unsafe { let struct2 = match GLOBAL_MUT_UNINIT { None => panic ! ( \"error\" ), Some ( ref mut s ) => { s . x = 41 ; s } }; println ! ( \"{:?}\" , struct2 ); } }","title":"Rust"},{"location":"Installation%20hints/","text":"Installation hints Rust Offline Installation - Windows Download both installer and sources from here During installation, choose Advanced to select installing rls To work with vscode, copy rls.exe in C:\\Users\\ user \\.cargo\\bin and set the rls path in settings.json through \"rust-client.rlsPath\". Unpack the sources in Rust installation path \\lib\\rustlib\\src\\rust\\src To debug in vscode, adjust the path for stdlib sources with \"sourceFileMap\" in launch.json . Change default paths Set before running the rustup-init: CARGO_HOME RUSTUP_HOME Typescript npm install -g typescript npm install -g ts-node npm install -g browserify put in the project folder a tsconfig.json: { \"compilerOptions\": { \"target\": \"es5\", \"lib\": [\"es5\", \"es6\", \"dom\"] }, \"files\": [ \"hello.ts\" ] } run ts-node hello.ts or tsc node hello.js","title":"Installation hints"},{"location":"Installation%20hints/#installation-hints","text":"","title":"Installation hints"},{"location":"Installation%20hints/#rust","text":"","title":"Rust"},{"location":"Installation%20hints/#offline-installation-windows","text":"Download both installer and sources from here During installation, choose Advanced to select installing rls To work with vscode, copy rls.exe in C:\\Users\\ user \\.cargo\\bin and set the rls path in settings.json through \"rust-client.rlsPath\". Unpack the sources in Rust installation path \\lib\\rustlib\\src\\rust\\src To debug in vscode, adjust the path for stdlib sources with \"sourceFileMap\" in launch.json .","title":"Offline Installation - Windows"},{"location":"Installation%20hints/#change-default-paths","text":"Set before running the rustup-init: CARGO_HOME RUSTUP_HOME","title":"Change default paths"},{"location":"Installation%20hints/#typescript","text":"npm install -g typescript npm install -g ts-node npm install -g browserify put in the project folder a tsconfig.json: { \"compilerOptions\": { \"target\": \"es5\", \"lib\": [\"es5\", \"es6\", \"dom\"] }, \"files\": [ \"hello.ts\" ] } run ts-node hello.ts or tsc node hello.js","title":"Typescript"},{"location":"List/","text":"List C# using System ; using System.Collections.Generic ; using System.Linq ; public class Program { public static void Main ( string [] args ) { //new empty list var lst1 = new List < string >(); //new initialized list var lst2 = new List < string > { \"str20\" , \"str21\" }; //append element lst1 . Add ( \"str10\" ); //append list lst1 . AddRange ( lst2 ); //add head element lst1 . Insert ( 0 , \"str00\" ); //reverse lst1 . Reverse (); //access elem with out of bounds check var elem = lst1 . ElementAtOrDefault ( 100 ); Console . Write ( \"Elem *{0}* \" , elem ); //sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] //list length var lst3 = lst1 . GetRange ( 1 , lst1 . Count - 1 ); Console . WriteLine (); foreach ( var item in lst3 ) { Console . Write ( \"{0} \" , item ); } //map and filter var lst4 = lst1 . Select (( x ) => x . ToUpper ()); var lst5 = lst4 . Where (( x ) => x != \"STR00\" ); Console . WriteLine (); foreach ( var item in lst5 ) { Console . Write ( \"{0} \" , item ); } } } Dart main ( List < String > arguments ) { // new empty list var lst1 = List < String > (); //new initialized list var lst2 = [ \"str20\" , \"str21\" ]; // append element lst1 . add ( \"str10\" ); // append list lst1 = lst1 + lst2 ; // add head element lst1 = [ \"str00\" ] + lst1 ; //reverse lst1 = lst1 . reversed . toList (); //trap out of bounds access var elem = getElemAt ( lst1 , 100 ); print ( 'Elem * $ elem *' ); // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] // list length var lst3 = lst1 . sublist ( 1 , lst1 . length ); print ( ' $ lst3 ' ); // map and filter var lst4 = lst3 . map (( x ) => x . toUpperCase ()); var lst5 = lst4 . where (( x ) => x != \"STR00\" ); print ( ' $ lst5 ' ); } String getElemAt ( List < String > lst , int index ) { String elem ; try { elem = lst [ index ]; } catch ( e ) { elem = \"\" ; } return elem ; } Go package main import ( \"fmt\" \"sort\" \"strings\" ) func main () { //new empty list lst1 := stringList {} //new initialized list lst2 := stringList { \"str20\" , \"str21\" } //append element lst1 = append ( lst1 , \"str10\" ) //append list lst1 = append ( lst1 , lst2 ... ) //add head element lst1 = append ([] string { \"str00\" }, lst1 ... ) //reverse sort . Sort ( sort . Reverse ( lst1 )) //trap out of bounds access elem := getElemAt ( lst1 , 100 ) fmt . Printf ( \"\\nElem *%v*\" , elem ) //sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] //list length lst3 := lst1 [ 1 : len ( lst1 )] fmt . Printf ( \"\\n%v\" , lst3 ) //map and filter lst4 := stringList {} for _ , elem := range lst1 { lst4 = append ( lst4 , strings . ToUpper ( elem )) } lst5 := stringList {} for _ , elem := range lst4 { if elem != \"STR00\" { lst5 = append ( lst5 , elem ) } } fmt . Printf ( \"\\n%v\" , lst5 ) } type stringList [] string func ( p stringList ) Len () int { return len ( p ) } func ( p stringList ) Less ( i , j int ) bool { return p [ i ] < p [ j ] } func ( p stringList ) Swap ( i , j int ) { p [ i ], p [ j ] = p [ j ], p [ i ] } func getElemAt ( lst stringList , index int ) string { defer recoverList () elem := lst [ index ] return elem } func recoverList () { recover () } Kotlin fun main () { // new empty list var lst1 = mutableListOf < String >() //new initialized list var lst2 = mutableListOf ( \"str20\" , \"str21\" ) // append element lst1 . add ( \"str10\" ) // append list lst1 . addAll ( lst2 ) // add head element lst1 . add ( 0 , \"str00\" ) // reverse lst1 . reverse () //access elem with out of bounds check val elem = lst1 . elementAtOrNull ( 100 ) println ( \"Elem ${elem}\" ) // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] // list length val lst3 = lst1 . subList ( 1 , lst1 . size ) println ( lst3 ) //map and filter val lst4 = lst3 . map { it -> it . toUpperCase ()} val lst5 = lst4 . filter { it -> ! it . equals ( \"STR00\" )} println ( lst5 ) } Nim import sequtils as sq import algorithm as al import strutils as st import strformat proc getElemAt ( lst : seq [ string ] , index : int ): string = try : return lst [ index ] except : return \"\" # new empty list var lst1 : seq [ string ] = @[] # new initialized list var lst2 = @[ \"str20\" , \"str21\" ] # append element lst1 . add ( \"str10\" ) #append list lst1 = sq . concat ( lst1 , lst2 ) # add head element lst1 = sq . concat ( @[ \"str00\" ] , lst1 ) # reverse lst1 = al . reversed ( lst1 ) # trap out of bounds access let elem = getElemAt ( lst1 , 100 ) echo & \"Elem *{elem}*\" # sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] # list length var lst3 = lst1 [ 1 .. len ( lst1 ) - 1 ] echo lst3 # map and filter var lst4 = map ( lst3 , proc ( x : string ): string = st . toUpper ( x )) var lst5 = filter ( lst4 , proc ( x : string ): bool = x != \"STR00\" ) echo lst5 Python from typing import List # new empty list lst1 : List [ str ] = [] # new initialized list lst2 : List [ str ] = [ \"str20\" , \"str21\" ] # append element lst1 = lst1 + [ \"str10\" ] def elem_at_index ( lst : List [ str ], index : int ) -> str : try : return lst [ index ] except : return \"\" # append list lst1 = lst1 + lst2 # add head element lst1 = [ \"str00\" ] + lst1 # reverse lst1 . reverse () # trap outof bounds access elem = elem_at_index ( lst1 , 100 ) print ( f \"Elem * {elem} *\" ) # sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] # list length lst3 : List [ str ] = lst1 [ 1 : len ( lst1 )] print ( lst3 ) # map and filter lst4 : List [ str ] = [ elem for elem in map ( lambda x : x . upper (), lst1 )] lst5 = [ elem for elem in filter ( lambda x : x != \"STR00\" , lst4 )] print ( lst5 ) Rust fn main () { // new empty list let mut lst1 : Vec <& str > = vec ! []; //new initialized list let lst2 = vec ! [ \"str20\" , \"str21\" ]; // append element lst1 . push ( \"str10\" ); // append list lst1 . extend ( lst2 ); // add head element lst1 . insert ( 0 , \"str00\" ); //reverse lst1 . reverse (); //access elem with out of bounds check let elem = match lst1 . get ( 100 ) { None => \"not found\" , Some ( x ) => x }; println ! ( \"Elem {}\" , elem ); // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] // list length let lst3 : Vec <& str > = lst1 [ 1 .. lst1 . len ()]. to_vec (); println ! ( \"{:?}\" , & lst3 ); // map and filter let lst4 : Vec < _ > = lst3 . into_iter (). map ( | x | x . to_uppercase ()). collect (); let lst5 : Vec < _ > = lst4 . into_iter (). filter ( | x | * x != \"STR00\" ). collect (); println ! ( \"{:?}\" , & lst5 ); } Sing requires \"sio\" ; requires \"str\" ; public fn singmain ( argv [ * ] string ) i32 { // new empty list var lst1 [ * ] string ; // new initialize dlist var lst2 [ * ] string = { \"str20\" , \"str21\" }; // append element lst1 . push_back ( \"str10\" ); // append list lst1 . append ( lst2 ); // add head element lst1 . insert ( 0 , 1 , \"str00\" ); // reverse var rev [ * ] string ; let l_size = lst1 . size (); for ( i in 0 : l_size ) { rev . push_back ( lst1 [ l_size - i - 1 ]); } lst1 = rev ; //access elem out of bounds let elem = lst1 [ 100 ]; if ( str . len ( elem ) == 0 ) { sio . print ( \" \\n\\r Elem not found\" ); } else { sio . print ( \" \\n\\r \" + elem ); } // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] var lst3 = lst1 ; lst3 . erase ( 0 , 1 ); for ( elem2 in lst3 ) { sio . print ( \" \\n\\r \" + elem2 ); } //map and filter var lst4 [ * ] string ; for ( elem2 in lst1 ) { lst4 . push_back ( str . toupper ( elem2 )); } var lst5 [ * ] string ; for ( elem2 in lst4 ) { if ( elem2 != \"STR00\" ) { lst5 . push_back ( elem2 ); } } sio . print ( \" \\n\\r \" ); for ( elem2 in lst5 ) { sio . print ( \" \\n\\r \" + elem2 ); } return ( 0 ); } TypeScript // new empty list var lst1 = []; //new initialized list var lst2 = [ \"str20\" , \"str21\" ]; // append element lst1 . push ( \"str10\" ); // append list lst1 = lst1 . concat ( lst2 ); // add head element lst1 = [ \"str00\" ]. concat ( lst1 ); //reverse lst1 = lst1 . reverse (); // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] // list length var lst3 = lst1 . slice ( 1 , lst1 . length ); console . log ( ` ${ lst3 } ` ); // map and filter var lst4 = lst3 . map (( x ) => x . toUpperCase ()); var lst5 = lst4 . filter (( x ) => x != \"STR00\" ); console . log ( ` ${ lst5 } ` ); V (vlang) fn main () { //new empty list mut lst1 := [] string {} //new initialized list lst2 := [ \"str20\" , \"str21\" ] //append element lst1 << \"str10\" //append list lst1 << lst2 //add head element lst1 . insert ( 0 , \"str00\" ) //reverse lst1 . reverse_in_place () //access elem with out of bounds check elem := lst1 [ 100 ] or { \"elem not found\" } println ( '$ elem ' ) // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] lst3 := lst1 [ 1. .] println ( '$ lst3 ' ) //map and filter lst4 := lst3 . map ( it . to_upper ()) lst5 := lst4 . filter ( it != \"STR00\" ) println ( '$ lst5 ' ) }","title":"List"},{"location":"List/#list","text":"","title":"List"},{"location":"List/#c","text":"using System ; using System.Collections.Generic ; using System.Linq ; public class Program { public static void Main ( string [] args ) { //new empty list var lst1 = new List < string >(); //new initialized list var lst2 = new List < string > { \"str20\" , \"str21\" }; //append element lst1 . Add ( \"str10\" ); //append list lst1 . AddRange ( lst2 ); //add head element lst1 . Insert ( 0 , \"str00\" ); //reverse lst1 . Reverse (); //access elem with out of bounds check var elem = lst1 . ElementAtOrDefault ( 100 ); Console . Write ( \"Elem *{0}* \" , elem ); //sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] //list length var lst3 = lst1 . GetRange ( 1 , lst1 . Count - 1 ); Console . WriteLine (); foreach ( var item in lst3 ) { Console . Write ( \"{0} \" , item ); } //map and filter var lst4 = lst1 . Select (( x ) => x . ToUpper ()); var lst5 = lst4 . Where (( x ) => x != \"STR00\" ); Console . WriteLine (); foreach ( var item in lst5 ) { Console . Write ( \"{0} \" , item ); } } }","title":"C#"},{"location":"List/#dart","text":"main ( List < String > arguments ) { // new empty list var lst1 = List < String > (); //new initialized list var lst2 = [ \"str20\" , \"str21\" ]; // append element lst1 . add ( \"str10\" ); // append list lst1 = lst1 + lst2 ; // add head element lst1 = [ \"str00\" ] + lst1 ; //reverse lst1 = lst1 . reversed . toList (); //trap out of bounds access var elem = getElemAt ( lst1 , 100 ); print ( 'Elem * $ elem *' ); // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] // list length var lst3 = lst1 . sublist ( 1 , lst1 . length ); print ( ' $ lst3 ' ); // map and filter var lst4 = lst3 . map (( x ) => x . toUpperCase ()); var lst5 = lst4 . where (( x ) => x != \"STR00\" ); print ( ' $ lst5 ' ); } String getElemAt ( List < String > lst , int index ) { String elem ; try { elem = lst [ index ]; } catch ( e ) { elem = \"\" ; } return elem ; }","title":"Dart"},{"location":"List/#go","text":"package main import ( \"fmt\" \"sort\" \"strings\" ) func main () { //new empty list lst1 := stringList {} //new initialized list lst2 := stringList { \"str20\" , \"str21\" } //append element lst1 = append ( lst1 , \"str10\" ) //append list lst1 = append ( lst1 , lst2 ... ) //add head element lst1 = append ([] string { \"str00\" }, lst1 ... ) //reverse sort . Sort ( sort . Reverse ( lst1 )) //trap out of bounds access elem := getElemAt ( lst1 , 100 ) fmt . Printf ( \"\\nElem *%v*\" , elem ) //sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] //list length lst3 := lst1 [ 1 : len ( lst1 )] fmt . Printf ( \"\\n%v\" , lst3 ) //map and filter lst4 := stringList {} for _ , elem := range lst1 { lst4 = append ( lst4 , strings . ToUpper ( elem )) } lst5 := stringList {} for _ , elem := range lst4 { if elem != \"STR00\" { lst5 = append ( lst5 , elem ) } } fmt . Printf ( \"\\n%v\" , lst5 ) } type stringList [] string func ( p stringList ) Len () int { return len ( p ) } func ( p stringList ) Less ( i , j int ) bool { return p [ i ] < p [ j ] } func ( p stringList ) Swap ( i , j int ) { p [ i ], p [ j ] = p [ j ], p [ i ] } func getElemAt ( lst stringList , index int ) string { defer recoverList () elem := lst [ index ] return elem } func recoverList () { recover () }","title":"Go"},{"location":"List/#kotlin","text":"fun main () { // new empty list var lst1 = mutableListOf < String >() //new initialized list var lst2 = mutableListOf ( \"str20\" , \"str21\" ) // append element lst1 . add ( \"str10\" ) // append list lst1 . addAll ( lst2 ) // add head element lst1 . add ( 0 , \"str00\" ) // reverse lst1 . reverse () //access elem with out of bounds check val elem = lst1 . elementAtOrNull ( 100 ) println ( \"Elem ${elem}\" ) // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] // list length val lst3 = lst1 . subList ( 1 , lst1 . size ) println ( lst3 ) //map and filter val lst4 = lst3 . map { it -> it . toUpperCase ()} val lst5 = lst4 . filter { it -> ! it . equals ( \"STR00\" )} println ( lst5 ) }","title":"Kotlin"},{"location":"List/#nim","text":"import sequtils as sq import algorithm as al import strutils as st import strformat proc getElemAt ( lst : seq [ string ] , index : int ): string = try : return lst [ index ] except : return \"\" # new empty list var lst1 : seq [ string ] = @[] # new initialized list var lst2 = @[ \"str20\" , \"str21\" ] # append element lst1 . add ( \"str10\" ) #append list lst1 = sq . concat ( lst1 , lst2 ) # add head element lst1 = sq . concat ( @[ \"str00\" ] , lst1 ) # reverse lst1 = al . reversed ( lst1 ) # trap out of bounds access let elem = getElemAt ( lst1 , 100 ) echo & \"Elem *{elem}*\" # sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] # list length var lst3 = lst1 [ 1 .. len ( lst1 ) - 1 ] echo lst3 # map and filter var lst4 = map ( lst3 , proc ( x : string ): string = st . toUpper ( x )) var lst5 = filter ( lst4 , proc ( x : string ): bool = x != \"STR00\" ) echo lst5","title":"Nim"},{"location":"List/#python","text":"from typing import List # new empty list lst1 : List [ str ] = [] # new initialized list lst2 : List [ str ] = [ \"str20\" , \"str21\" ] # append element lst1 = lst1 + [ \"str10\" ] def elem_at_index ( lst : List [ str ], index : int ) -> str : try : return lst [ index ] except : return \"\" # append list lst1 = lst1 + lst2 # add head element lst1 = [ \"str00\" ] + lst1 # reverse lst1 . reverse () # trap outof bounds access elem = elem_at_index ( lst1 , 100 ) print ( f \"Elem * {elem} *\" ) # sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] # list length lst3 : List [ str ] = lst1 [ 1 : len ( lst1 )] print ( lst3 ) # map and filter lst4 : List [ str ] = [ elem for elem in map ( lambda x : x . upper (), lst1 )] lst5 = [ elem for elem in filter ( lambda x : x != \"STR00\" , lst4 )] print ( lst5 )","title":"Python"},{"location":"List/#rust","text":"fn main () { // new empty list let mut lst1 : Vec <& str > = vec ! []; //new initialized list let lst2 = vec ! [ \"str20\" , \"str21\" ]; // append element lst1 . push ( \"str10\" ); // append list lst1 . extend ( lst2 ); // add head element lst1 . insert ( 0 , \"str00\" ); //reverse lst1 . reverse (); //access elem with out of bounds check let elem = match lst1 . get ( 100 ) { None => \"not found\" , Some ( x ) => x }; println ! ( \"Elem {}\" , elem ); // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] // list length let lst3 : Vec <& str > = lst1 [ 1 .. lst1 . len ()]. to_vec (); println ! ( \"{:?}\" , & lst3 ); // map and filter let lst4 : Vec < _ > = lst3 . into_iter (). map ( | x | x . to_uppercase ()). collect (); let lst5 : Vec < _ > = lst4 . into_iter (). filter ( | x | * x != \"STR00\" ). collect (); println ! ( \"{:?}\" , & lst5 ); }","title":"Rust"},{"location":"List/#sing","text":"requires \"sio\" ; requires \"str\" ; public fn singmain ( argv [ * ] string ) i32 { // new empty list var lst1 [ * ] string ; // new initialize dlist var lst2 [ * ] string = { \"str20\" , \"str21\" }; // append element lst1 . push_back ( \"str10\" ); // append list lst1 . append ( lst2 ); // add head element lst1 . insert ( 0 , 1 , \"str00\" ); // reverse var rev [ * ] string ; let l_size = lst1 . size (); for ( i in 0 : l_size ) { rev . push_back ( lst1 [ l_size - i - 1 ]); } lst1 = rev ; //access elem out of bounds let elem = lst1 [ 100 ]; if ( str . len ( elem ) == 0 ) { sio . print ( \" \\n\\r Elem not found\" ); } else { sio . print ( \" \\n\\r \" + elem ); } // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] var lst3 = lst1 ; lst3 . erase ( 0 , 1 ); for ( elem2 in lst3 ) { sio . print ( \" \\n\\r \" + elem2 ); } //map and filter var lst4 [ * ] string ; for ( elem2 in lst1 ) { lst4 . push_back ( str . toupper ( elem2 )); } var lst5 [ * ] string ; for ( elem2 in lst4 ) { if ( elem2 != \"STR00\" ) { lst5 . push_back ( elem2 ); } } sio . print ( \" \\n\\r \" ); for ( elem2 in lst5 ) { sio . print ( \" \\n\\r \" + elem2 ); } return ( 0 ); }","title":"Sing"},{"location":"List/#typescript","text":"// new empty list var lst1 = []; //new initialized list var lst2 = [ \"str20\" , \"str21\" ]; // append element lst1 . push ( \"str10\" ); // append list lst1 = lst1 . concat ( lst2 ); // add head element lst1 = [ \"str00\" ]. concat ( lst1 ); //reverse lst1 = lst1 . reverse (); // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] // list length var lst3 = lst1 . slice ( 1 , lst1 . length ); console . log ( ` ${ lst3 } ` ); // map and filter var lst4 = lst3 . map (( x ) => x . toUpperCase ()); var lst5 = lst4 . filter (( x ) => x != \"STR00\" ); console . log ( ` ${ lst5 } ` );","title":"TypeScript"},{"location":"List/#v-vlang","text":"fn main () { //new empty list mut lst1 := [] string {} //new initialized list lst2 := [ \"str20\" , \"str21\" ] //append element lst1 << \"str10\" //append list lst1 << lst2 //add head element lst1 . insert ( 0 , \"str00\" ) //reverse lst1 . reverse_in_place () //access elem with out of bounds check elem := lst1 [ 100 ] or { \"elem not found\" } println ( '$ elem ' ) // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] lst3 := lst1 [ 1. .] println ( '$ lst3 ' ) //map and filter lst4 := lst3 . map ( it . to_upper ()) lst5 := lst4 . filter ( it != \"STR00\" ) println ( '$ lst5 ' ) }","title":"V (vlang)"},{"location":"Numeric/","text":"Numeric C# //dotnet add package MathNet.Numerics using System ; using System.Collections.Generic ; using MathNet.Numerics.Statistics ; using MathNet.Numerics.LinearAlgebra.Double ; using System.Diagnostics ; public class Program { public static void Main ( string [] args ) { var timer = Stopwatch . StartNew (); //START MEASURE double [,] x = { { 1.0 , 2.0 , 3.0 }, { 3.0 , 4.0 , 5.0 }, { 0.0 , 5.0 , 6.0 } }; var a = DenseMatrix . OfArray ( x ); var at = a . Transpose (); var i = a . Inverse (); var v = a . ToColumnArrays (); //columns mean var am0 = new List < double >(); //columns standard deviation var as0 = new List < double >(); //columns max var amax0 = new List < double >(); foreach ( var item in v ) { var stats = new DescriptiveStatistics ( item ); am0 . Add ( stats . Mean ); as0 . Add ( stats . StandardDeviation ); amax0 . Add ( stats . Maximum ); } var b = a * at ; var dt = a . Determinant (); timer . Stop (); //END MEASURE am0 . ForEach (( x ) => Console . Write ( \"{0} \" , x )); Console . WriteLine ( \"\" ); as0 . ForEach (( x ) => Console . Write ( \"{0} \" , x )); Console . WriteLine ( \"\" ); amax0 . ForEach (( x ) => Console . Write ( \"{0} \" , x )); Console . WriteLine ( \"\" ); Console . WriteLine ( \"{0} \" , at ); Console . WriteLine ( \"{0} \" , b ); Console . WriteLine ( \"{0} \" , dt ); Console . WriteLine ( \"{0} \" , i ); Console . WriteLine ( \"\\nElapsed: {0}ms\" , timer . ElapsedMilliseconds ); } } Go //go get -u -t gonum.org/v1/gonum/... package main import ( \"fmt\" \"time\" \"gonum.org/v1/gonum/mat\" \"gonum.org/v1/gonum/stat\" ) func main () { start := time . Now () //START MEASURE a := mat . NewDense ( 3 , 3 , [] float64 { 1.0 , 2.0 , 3.0 , 3.0 , 4.0 , 5.0 , 0.0 , 5.0 , 6.0 }) rNum , _ := a . Dims () //columns mean am0 := [] float64 {} //columns standard deviation as0 := [] float64 {} //columns max amax0 := [] float64 {} weights := [] float64 {} for index := 0 ; index < rNum ; index ++ { weights = append ( weights , 1.0 ) } for index := 0 ; index < rNum ; index ++ { var dst [] float64 col := mat . Col ( dst , index , a ) mean , std := stat . MeanStdDev ( col , weights ) am0 = append ( am0 , mean ) as0 = append ( as0 , std ) amax0 = append ( amax0 , f64Max ( col )) } at := a . T () var b mat . Dense // construct a new zero-value matrix b . Mul ( a , at ) dt := mat . Det ( a ) var i mat . Dense // construct a new zero-value matrix i . Inverse (( a )) duration := time . Since ( start ) //END MEASURE fmt . Printf ( \"\\n%v\" , am0 ) fmt . Printf ( \"\\n%v\" , as0 ) fmt . Printf ( \"\\n%v\" , amax0 ) fat := mat . Formatted ( at , mat . Prefix ( \"\" ), mat . Squeeze ()) fmt . Printf ( \"\\n%v\\n\" , fat ) fmt . Printf ( \"\\n%v\" , b ) fmt . Printf ( \"\\n%v\" , dt ) fmt . Printf ( \"\\n%v\" , i ) fmt . Printf ( \"\\nElapsed: %v\" , duration ) } func f64Max ( v [] float64 ) float64 { max := v [ 0 ] for index := 1 ; index < len ( v ); index ++ { if v [ index ] > max { max = v [ index ] } } return max } Python import time import numpy as np start_time : float = time . time () # START MEASURE a = np . array ([[ 1. , 2. , 3. ],[ 3. , 4. , 5. ],[ 0. , 5. , 6. ]]) am0 = np . mean ( a , axis = 0 ) as0 = np . std ( a , axis = 0 ) amax0 = np . max ( a , 0 ) at = np . transpose ( a ) b = np . dot ( a , at ) dt = np . linalg . det ( a ); i = np . linalg . inv ( a ) end_time : float = time . time () # END MEASURE print ( am0 ) print ( as0 ) print ( amax0 ) print ( at ) print ( b ) print ( dt ) print ( i ) print ( f \"Elapsed: {((end_time - start_time)*1000)} ms\" ) Python # pytorch import time import torch as pt start_time : float = time . time () # START MEASURE a = pt . Tensor ([[ 1. , 2. , 3. ],[ 3. , 4. , 5. ],[ 0. , 5. , 6. ]]) cols = a . size ()[ 1 ] am0 = pt . Tensor () as0 = pt . Tensor () amax0 = pt . Tensor () for ind in range ( 0 , cols ): ac = a [:, ind ] am = ac . mean ( dtype = pt . float ) . item () astd = ac . std () . item () amax = ac . max () . item () am0 = pt . cat (( am0 , pt . Tensor ([ am ]))) as0 = pt . cat (( as0 , pt . Tensor ([ astd ]))) amax0 = pt . cat (( amax0 , pt . Tensor ([ amax ]))) at = a . t () b = a . matmul ( at ) dt = a . det () . item () i = a . inverse () end_time : float = time . time () # END MEASURE print ( am0 ) print ( as0 ) print ( amax0 ) print ( at ) print ( b ) print ( dt ) print ( i ) print ( f \"Elapsed: {((end_time - start_time)*1000)} ms\" ) Rust //[dependencies] //peroxide = \"0.18.1\" extern crate peroxide ; use peroxide :: * ; use std :: time :: { Instant }; fn main () { let now = Instant :: now (); //START MEASURE let a = py_matrix ( vec ! [ vec ! [ 1. , 2. , 3. ], vec ! [ 3. , 4. , 5. ], vec ! [ 0. , 5. , 6. ]]); //columns mean let am0 = a . mean (); //columns standard deviation let as0 = a . sd (); //columns max let mut amax0 : Vec < f64 > = vec ! []; let cols = a . row ( 0 ). len (); for index in 0 .. cols { amax0 . push ( max ( a . col ( index ))) } let at = & a . transpose (); let b = & a * at ; let dt = & a . det (); let i = & a . inv (). expect ( \"inverse failed\" ); let new_now = Instant :: now (); //END MEASURE am0 . print (); as0 . print (); println ! ( \"{:?}\" , amax0 ); at . print (); b . print (); dt . print (); i . print (); println ! ( \"Elapsed: {:?}\" , new_now . duration_since ( now )); } Rust //[dependencies] //ndarray = \"0.13.0\" //ndarray-linalg = { version = \"0.12\", features = [\"intel-mkl\"] } use std :: time :: Instant ; extern crate ndarray ; extern crate ndarray_linalg ; use ndarray :: * ; //use ndarray::prelude::*; //use ndarray_linalg::cholesky::{DeterminantC, InverseC}; use ndarray_linalg :: * ; pub trait VecStats { fn max ( & self ) -> f64 ; } impl VecStats for Array1 < f64 > { fn max ( & self ) -> f64 { let mut max_el = self [ 0 ]; for elem in self { if * elem > max_el { max_el = * elem ; } } max_el } } fn main () { let now = Instant :: now (); //START MEASURE let a : Array2 < f64 > = array ! [[ 1. , 2. , 3. ], [ 3. , 4. , 5. ], [ 0. , 5. , 6. ]]; //let a = Array::from_shape_vec((3, 3), vec![1., 2., 3., 3., 4., 5., 0., 5., 6.]).unwrap(); let am0 = a . mean_axis ( Axis ( 0 )). expect ( \"Mean error\" ); let as0 = a . std_axis ( Axis ( 0 ), 1. ); let mut amax0 : Vec < f64 > = vec ! []; let cols = a . ncols (); for index in 0 .. cols { amax0 . push ( a . column ( index ). to_owned (). max ()) } let at = a . t (); let b = a . dot ( & at ); let i = a . inv (). expect ( \"Inversion error\" ); let dt = a . det (). expect ( \"Determinant error\" ); let new_now = Instant :: now (); //END MEASURE println ! ( \"{}\" , am0 ); println ! ( \"{}\" , as0 ); println ! ( \"{:?}\" , & amax0 ); println ! ( \"{}\" , at ); println ! ( \"{}\" , b ); println ! ( \"{}\" , dt ); println ! ( \"{}\" , i ); println ! ( \"Elapsed: {:?}\" , new_now . duration_since ( now )); } Rust //[dependencies] //tch = \"0.1.5\" use tch :: { Tensor , Kind , IndexOp }; use std :: time :: { Instant }; fn main () { let now = Instant :: now (); //START MEASURE let a = Tensor :: of_slice ( & [ 1. , 2. , 3. , 3. , 4. , 5. , 0. , 5. , 6. ]). view ([ 3 , 3 ]); let mut am0_v : Vec < f64 > = vec ! []; let mut as0_v : Vec < f64 > = vec ! []; let mut amax0_v : Vec < f64 > = vec ! []; let cols = a . size ()[ 1 ]; for ind in 0 .. cols { let ac = a . i ((.., ind )); let am = ac . mean ( Kind :: Double ); let astd = ac . std ( true ); let amax = ac . max (); am0_v . push ( Vec :: < f64 > :: from ( am )[ 0 ]); as0_v . push ( Vec :: < f64 > :: from ( astd )[ 0 ]); amax0_v . push ( Vec :: < f64 > :: from ( amax )[ 0 ]); //am0 = Tensor::cat(&am0, &am); } let at = a . transpose ( - 2 , 1 ); let b = a . matmul ( & at ); let dt = f64 :: from ( a . det ()); let i = a . inverse (); let new_now = Instant :: now (); //END MEASURE println ! ( \"{:?}\" , am0_v ); println ! ( \"{:?}\" , as0_v ); println ! ( \"{:?}\" , amax0_v ); at . print (); b . print (); println ! ( \"{}\" , dt ); i . print (); println ! ( \"Elapsed: {:?}\" , new_now . duration_since ( now )); }","title":"Numeric"},{"location":"Numeric/#numeric","text":"","title":"Numeric"},{"location":"Numeric/#c","text":"//dotnet add package MathNet.Numerics using System ; using System.Collections.Generic ; using MathNet.Numerics.Statistics ; using MathNet.Numerics.LinearAlgebra.Double ; using System.Diagnostics ; public class Program { public static void Main ( string [] args ) { var timer = Stopwatch . StartNew (); //START MEASURE double [,] x = { { 1.0 , 2.0 , 3.0 }, { 3.0 , 4.0 , 5.0 }, { 0.0 , 5.0 , 6.0 } }; var a = DenseMatrix . OfArray ( x ); var at = a . Transpose (); var i = a . Inverse (); var v = a . ToColumnArrays (); //columns mean var am0 = new List < double >(); //columns standard deviation var as0 = new List < double >(); //columns max var amax0 = new List < double >(); foreach ( var item in v ) { var stats = new DescriptiveStatistics ( item ); am0 . Add ( stats . Mean ); as0 . Add ( stats . StandardDeviation ); amax0 . Add ( stats . Maximum ); } var b = a * at ; var dt = a . Determinant (); timer . Stop (); //END MEASURE am0 . ForEach (( x ) => Console . Write ( \"{0} \" , x )); Console . WriteLine ( \"\" ); as0 . ForEach (( x ) => Console . Write ( \"{0} \" , x )); Console . WriteLine ( \"\" ); amax0 . ForEach (( x ) => Console . Write ( \"{0} \" , x )); Console . WriteLine ( \"\" ); Console . WriteLine ( \"{0} \" , at ); Console . WriteLine ( \"{0} \" , b ); Console . WriteLine ( \"{0} \" , dt ); Console . WriteLine ( \"{0} \" , i ); Console . WriteLine ( \"\\nElapsed: {0}ms\" , timer . ElapsedMilliseconds ); } }","title":"C#"},{"location":"Numeric/#go","text":"//go get -u -t gonum.org/v1/gonum/... package main import ( \"fmt\" \"time\" \"gonum.org/v1/gonum/mat\" \"gonum.org/v1/gonum/stat\" ) func main () { start := time . Now () //START MEASURE a := mat . NewDense ( 3 , 3 , [] float64 { 1.0 , 2.0 , 3.0 , 3.0 , 4.0 , 5.0 , 0.0 , 5.0 , 6.0 }) rNum , _ := a . Dims () //columns mean am0 := [] float64 {} //columns standard deviation as0 := [] float64 {} //columns max amax0 := [] float64 {} weights := [] float64 {} for index := 0 ; index < rNum ; index ++ { weights = append ( weights , 1.0 ) } for index := 0 ; index < rNum ; index ++ { var dst [] float64 col := mat . Col ( dst , index , a ) mean , std := stat . MeanStdDev ( col , weights ) am0 = append ( am0 , mean ) as0 = append ( as0 , std ) amax0 = append ( amax0 , f64Max ( col )) } at := a . T () var b mat . Dense // construct a new zero-value matrix b . Mul ( a , at ) dt := mat . Det ( a ) var i mat . Dense // construct a new zero-value matrix i . Inverse (( a )) duration := time . Since ( start ) //END MEASURE fmt . Printf ( \"\\n%v\" , am0 ) fmt . Printf ( \"\\n%v\" , as0 ) fmt . Printf ( \"\\n%v\" , amax0 ) fat := mat . Formatted ( at , mat . Prefix ( \"\" ), mat . Squeeze ()) fmt . Printf ( \"\\n%v\\n\" , fat ) fmt . Printf ( \"\\n%v\" , b ) fmt . Printf ( \"\\n%v\" , dt ) fmt . Printf ( \"\\n%v\" , i ) fmt . Printf ( \"\\nElapsed: %v\" , duration ) } func f64Max ( v [] float64 ) float64 { max := v [ 0 ] for index := 1 ; index < len ( v ); index ++ { if v [ index ] > max { max = v [ index ] } } return max }","title":"Go"},{"location":"Numeric/#python","text":"import time import numpy as np start_time : float = time . time () # START MEASURE a = np . array ([[ 1. , 2. , 3. ],[ 3. , 4. , 5. ],[ 0. , 5. , 6. ]]) am0 = np . mean ( a , axis = 0 ) as0 = np . std ( a , axis = 0 ) amax0 = np . max ( a , 0 ) at = np . transpose ( a ) b = np . dot ( a , at ) dt = np . linalg . det ( a ); i = np . linalg . inv ( a ) end_time : float = time . time () # END MEASURE print ( am0 ) print ( as0 ) print ( amax0 ) print ( at ) print ( b ) print ( dt ) print ( i ) print ( f \"Elapsed: {((end_time - start_time)*1000)} ms\" )","title":"Python"},{"location":"Numeric/#python_1","text":"# pytorch import time import torch as pt start_time : float = time . time () # START MEASURE a = pt . Tensor ([[ 1. , 2. , 3. ],[ 3. , 4. , 5. ],[ 0. , 5. , 6. ]]) cols = a . size ()[ 1 ] am0 = pt . Tensor () as0 = pt . Tensor () amax0 = pt . Tensor () for ind in range ( 0 , cols ): ac = a [:, ind ] am = ac . mean ( dtype = pt . float ) . item () astd = ac . std () . item () amax = ac . max () . item () am0 = pt . cat (( am0 , pt . Tensor ([ am ]))) as0 = pt . cat (( as0 , pt . Tensor ([ astd ]))) amax0 = pt . cat (( amax0 , pt . Tensor ([ amax ]))) at = a . t () b = a . matmul ( at ) dt = a . det () . item () i = a . inverse () end_time : float = time . time () # END MEASURE print ( am0 ) print ( as0 ) print ( amax0 ) print ( at ) print ( b ) print ( dt ) print ( i ) print ( f \"Elapsed: {((end_time - start_time)*1000)} ms\" )","title":"Python"},{"location":"Numeric/#rust","text":"//[dependencies] //peroxide = \"0.18.1\" extern crate peroxide ; use peroxide :: * ; use std :: time :: { Instant }; fn main () { let now = Instant :: now (); //START MEASURE let a = py_matrix ( vec ! [ vec ! [ 1. , 2. , 3. ], vec ! [ 3. , 4. , 5. ], vec ! [ 0. , 5. , 6. ]]); //columns mean let am0 = a . mean (); //columns standard deviation let as0 = a . sd (); //columns max let mut amax0 : Vec < f64 > = vec ! []; let cols = a . row ( 0 ). len (); for index in 0 .. cols { amax0 . push ( max ( a . col ( index ))) } let at = & a . transpose (); let b = & a * at ; let dt = & a . det (); let i = & a . inv (). expect ( \"inverse failed\" ); let new_now = Instant :: now (); //END MEASURE am0 . print (); as0 . print (); println ! ( \"{:?}\" , amax0 ); at . print (); b . print (); dt . print (); i . print (); println ! ( \"Elapsed: {:?}\" , new_now . duration_since ( now )); }","title":"Rust"},{"location":"Numeric/#rust_1","text":"//[dependencies] //ndarray = \"0.13.0\" //ndarray-linalg = { version = \"0.12\", features = [\"intel-mkl\"] } use std :: time :: Instant ; extern crate ndarray ; extern crate ndarray_linalg ; use ndarray :: * ; //use ndarray::prelude::*; //use ndarray_linalg::cholesky::{DeterminantC, InverseC}; use ndarray_linalg :: * ; pub trait VecStats { fn max ( & self ) -> f64 ; } impl VecStats for Array1 < f64 > { fn max ( & self ) -> f64 { let mut max_el = self [ 0 ]; for elem in self { if * elem > max_el { max_el = * elem ; } } max_el } } fn main () { let now = Instant :: now (); //START MEASURE let a : Array2 < f64 > = array ! [[ 1. , 2. , 3. ], [ 3. , 4. , 5. ], [ 0. , 5. , 6. ]]; //let a = Array::from_shape_vec((3, 3), vec![1., 2., 3., 3., 4., 5., 0., 5., 6.]).unwrap(); let am0 = a . mean_axis ( Axis ( 0 )). expect ( \"Mean error\" ); let as0 = a . std_axis ( Axis ( 0 ), 1. ); let mut amax0 : Vec < f64 > = vec ! []; let cols = a . ncols (); for index in 0 .. cols { amax0 . push ( a . column ( index ). to_owned (). max ()) } let at = a . t (); let b = a . dot ( & at ); let i = a . inv (). expect ( \"Inversion error\" ); let dt = a . det (). expect ( \"Determinant error\" ); let new_now = Instant :: now (); //END MEASURE println ! ( \"{}\" , am0 ); println ! ( \"{}\" , as0 ); println ! ( \"{:?}\" , & amax0 ); println ! ( \"{}\" , at ); println ! ( \"{}\" , b ); println ! ( \"{}\" , dt ); println ! ( \"{}\" , i ); println ! ( \"Elapsed: {:?}\" , new_now . duration_since ( now )); }","title":"Rust"},{"location":"Numeric/#rust_2","text":"//[dependencies] //tch = \"0.1.5\" use tch :: { Tensor , Kind , IndexOp }; use std :: time :: { Instant }; fn main () { let now = Instant :: now (); //START MEASURE let a = Tensor :: of_slice ( & [ 1. , 2. , 3. , 3. , 4. , 5. , 0. , 5. , 6. ]). view ([ 3 , 3 ]); let mut am0_v : Vec < f64 > = vec ! []; let mut as0_v : Vec < f64 > = vec ! []; let mut amax0_v : Vec < f64 > = vec ! []; let cols = a . size ()[ 1 ]; for ind in 0 .. cols { let ac = a . i ((.., ind )); let am = ac . mean ( Kind :: Double ); let astd = ac . std ( true ); let amax = ac . max (); am0_v . push ( Vec :: < f64 > :: from ( am )[ 0 ]); as0_v . push ( Vec :: < f64 > :: from ( astd )[ 0 ]); amax0_v . push ( Vec :: < f64 > :: from ( amax )[ 0 ]); //am0 = Tensor::cat(&am0, &am); } let at = a . transpose ( - 2 , 1 ); let b = a . matmul ( & at ); let dt = f64 :: from ( a . det ()); let i = a . inverse (); let new_now = Instant :: now (); //END MEASURE println ! ( \"{:?}\" , am0_v ); println ! ( \"{:?}\" , as0_v ); println ! ( \"{:?}\" , amax0_v ); at . print (); b . print (); println ! ( \"{}\" , dt ); i . print (); println ! ( \"Elapsed: {:?}\" , new_now . duration_since ( now )); }","title":"Rust"},{"location":"Packages/","text":"Packages C# Nuget Packages Dart & Flutter Dart Packages Go Go Packages Nim Nim Package Directory Python Python Package Index Rust Crates.io","title":"Packages"},{"location":"Packages/#packages","text":"","title":"Packages"},{"location":"Packages/#c","text":"Nuget Packages","title":"C#"},{"location":"Packages/#dart-flutter","text":"Dart Packages","title":"Dart &amp; Flutter"},{"location":"Packages/#go","text":"Go Packages","title":"Go"},{"location":"Packages/#nim","text":"Nim Package Directory","title":"Nim"},{"location":"Packages/#python","text":"Python Package Index","title":"Python"},{"location":"Packages/#rust","text":"Crates.io","title":"Rust"},{"location":"Playground%20links/","text":"Playground links C# .NET Fiddle Tio C# (.NET Core) Dart DartPad Tio Dart Flutter DartPad Kotlin Kotlin Playground Go Go Playground Tio Go Nim Nim Playground Tio Nim Python Tio Python3 Rust Rust Playground Tio Rust TypeScript Tio TypeScript","title":"Playground links"},{"location":"Playground%20links/#playground-links","text":"","title":"Playground links"},{"location":"Playground%20links/#c","text":".NET Fiddle Tio C# (.NET Core)","title":"C#"},{"location":"Playground%20links/#dart","text":"DartPad Tio Dart","title":"Dart"},{"location":"Playground%20links/#flutter","text":"DartPad","title":"Flutter"},{"location":"Playground%20links/#kotlin","text":"Kotlin Playground","title":"Kotlin"},{"location":"Playground%20links/#go","text":"Go Playground Tio Go","title":"Go"},{"location":"Playground%20links/#nim","text":"Nim Playground Tio Nim","title":"Nim"},{"location":"Playground%20links/#python","text":"Tio Python3","title":"Python"},{"location":"Playground%20links/#rust","text":"Rust Playground Tio Rust","title":"Rust"},{"location":"Playground%20links/#typescript","text":"Tio TypeScript","title":"TypeScript"},{"location":"Scaffold%20with%20CLI/","text":"Scaffold with CLI C# dotnet new console -o hello cd hello dotnet run Dart pub global activate stagehand mkdir hello cd hello stagehand console-full pub get dart bin/main.dart flutter mkdir hello cd hello flutter create . flutter pub get flutter run flutter run --release flutter build apk flutter install Rust cargo new hello -- bin cd hello cargo run","title":"Scaffold with CLI"},{"location":"Scaffold%20with%20CLI/#scaffold-with-cli","text":"","title":"Scaffold with CLI"},{"location":"Scaffold%20with%20CLI/#c","text":"dotnet new console -o hello cd hello dotnet run","title":"C#"},{"location":"Scaffold%20with%20CLI/#dart","text":"pub global activate stagehand mkdir hello cd hello stagehand console-full pub get dart bin/main.dart","title":"Dart"},{"location":"Scaffold%20with%20CLI/#flutter","text":"mkdir hello cd hello flutter create . flutter pub get flutter run flutter run --release flutter build apk flutter install","title":"flutter"},{"location":"Scaffold%20with%20CLI/#rust","text":"cargo new hello -- bin cd hello cargo run","title":"Rust"},{"location":"Serialization/","text":"Serialization Dart import 'dart:io' ; import 'dart:convert' ; void main () { var map = { \"first\" : [ 1 , 2 , 3 , 4 ], \"second\" : [ 10 , 20 , 30 , 40 ] }; print ( ' $ map ?' ); var fileName = \"tmp01.txt\" ; var f = File ( fileName ); var encodeMap = jsonEncode ( map ); f . writeAsString ( encodeMap ); var map2 = Map (); f . readAsString (). then (( str1 ) { map2 = jsonDecode ( str1 ); print ( ' $ map2 ' ); }); } Python import pickle PICKLE_FILE_PATH = \"tmp01\" map_dump = { \"first\" : [ 1 , 2 , 3 , 4 ], \"second\" : [ 10 , 20 , 30 , 40 ]} fd1 = open ( PICKLE_FILE_PATH , 'wb' ) # save map pickle . dump ( map_dump , fd1 ) fd1 . close () # recover map map_load = {} fd2 = open ( PICKLE_FILE_PATH , 'rb' ) map_load = pickle . load ( fd2 ) fd2 . close () print ( map_load ) Rust //[dependencies] //serde = \"1.0.105\" //serde_derive = \"1.0.105\" //bincode = \"1.2.1\" use std :: collections :: HashMap ; use bincode :: { deserialize , serialize }; use serde_derive :: { Deserialize , Serialize }; use std :: fs :: { File , OpenOptions }; use std :: io :: prelude :: * ; //read/write const FILE_SERIALIZE_PATH : & str = \"tmp01\" ; // struct enveloping the map #[derive(Clone, Debug, Deserialize, Serialize)] struct SMap { map : HashMap < String , Vec < i32 >> , } fn main () { let mut map : HashMap < String , Vec < i32 >> = HashMap :: new (); //initialize HashMap map . insert ( \"first\" . to_string (), vec ! [ 1 , 2 , 3 , 4 ]); map . insert ( \"second\" . to_string (), vec ! [ 10 , 20 , 30 , 40 ]); let s_map = SMap { map : map }; let mut fw_bin = match OpenOptions :: new (). write ( true ). open ( FILE_SERIALIZE_PATH ) { Ok ( file ) => file , Err ( _ ) => match File :: create ( FILE_SERIALIZE_PATH ) { Ok ( file ) => file , Err ( _ ) => panic ! ( \"Cannot create LOG file\" ), }, }; let s_map_dump : Vec < u8 > = serialize ( & s_map ). unwrap (); fw_bin . write ( & s_map_dump ). unwrap (); let mut fr_bin = match OpenOptions :: new (). read ( true ). open ( FILE_SERIALIZE_PATH ) { Ok ( file ) => file , Err ( _ ) => panic ! ( \"Cannot open file to read\" ), }; let mut s_map_load : Vec < u8 > = vec ! []; fr_bin . read_to_end ( & mut s_map_load ). unwrap (); let s_map_restored : SMap = deserialize ( & s_map_load ). unwrap (); println ! ( \"{:?}\" , s_map_restored . map ); }","title":"Serialization"},{"location":"Serialization/#serialization","text":"","title":"Serialization"},{"location":"Serialization/#dart","text":"import 'dart:io' ; import 'dart:convert' ; void main () { var map = { \"first\" : [ 1 , 2 , 3 , 4 ], \"second\" : [ 10 , 20 , 30 , 40 ] }; print ( ' $ map ?' ); var fileName = \"tmp01.txt\" ; var f = File ( fileName ); var encodeMap = jsonEncode ( map ); f . writeAsString ( encodeMap ); var map2 = Map (); f . readAsString (). then (( str1 ) { map2 = jsonDecode ( str1 ); print ( ' $ map2 ' ); }); }","title":"Dart"},{"location":"Serialization/#python","text":"import pickle PICKLE_FILE_PATH = \"tmp01\" map_dump = { \"first\" : [ 1 , 2 , 3 , 4 ], \"second\" : [ 10 , 20 , 30 , 40 ]} fd1 = open ( PICKLE_FILE_PATH , 'wb' ) # save map pickle . dump ( map_dump , fd1 ) fd1 . close () # recover map map_load = {} fd2 = open ( PICKLE_FILE_PATH , 'rb' ) map_load = pickle . load ( fd2 ) fd2 . close () print ( map_load )","title":"Python"},{"location":"Serialization/#rust","text":"//[dependencies] //serde = \"1.0.105\" //serde_derive = \"1.0.105\" //bincode = \"1.2.1\" use std :: collections :: HashMap ; use bincode :: { deserialize , serialize }; use serde_derive :: { Deserialize , Serialize }; use std :: fs :: { File , OpenOptions }; use std :: io :: prelude :: * ; //read/write const FILE_SERIALIZE_PATH : & str = \"tmp01\" ; // struct enveloping the map #[derive(Clone, Debug, Deserialize, Serialize)] struct SMap { map : HashMap < String , Vec < i32 >> , } fn main () { let mut map : HashMap < String , Vec < i32 >> = HashMap :: new (); //initialize HashMap map . insert ( \"first\" . to_string (), vec ! [ 1 , 2 , 3 , 4 ]); map . insert ( \"second\" . to_string (), vec ! [ 10 , 20 , 30 , 40 ]); let s_map = SMap { map : map }; let mut fw_bin = match OpenOptions :: new (). write ( true ). open ( FILE_SERIALIZE_PATH ) { Ok ( file ) => file , Err ( _ ) => match File :: create ( FILE_SERIALIZE_PATH ) { Ok ( file ) => file , Err ( _ ) => panic ! ( \"Cannot create LOG file\" ), }, }; let s_map_dump : Vec < u8 > = serialize ( & s_map ). unwrap (); fw_bin . write ( & s_map_dump ). unwrap (); let mut fr_bin = match OpenOptions :: new (). read ( true ). open ( FILE_SERIALIZE_PATH ) { Ok ( file ) => file , Err ( _ ) => panic ! ( \"Cannot open file to read\" ), }; let mut s_map_load : Vec < u8 > = vec ! []; fr_bin . read_to_end ( & mut s_map_load ). unwrap (); let s_map_restored : SMap = deserialize ( & s_map_load ). unwrap (); println ! ( \"{:?}\" , s_map_restored . map ); }","title":"Rust"},{"location":"Share/","text":"Share Rust use mod1 :: * ; use mod2 :: * ; use std :: sync :: { Arc , Mutex }; mod mod1 { use crate :: mod2 :: * ; use std :: thread ; use std :: { sync :: { Arc , Mutex }, thread :: JoinHandle , }; pub struct ST1 { pub count : i32 , pub name : String , } pub fn mod1_init () -> ST1 { ST1 { count : 0 , name : String :: from ( \"MOD1\" ), } } pub fn run_th1 ( st2 : Arc < Mutex < ST2 >> ) -> JoinHandle < () > { thread :: spawn ( move || { thread :: park (); println ! ( \"Thread 1 started\" ); let mut st2_a = st2 . lock (). unwrap (); st2_a . count = st2_a . count + 2 ; }) } } mod mod2 { use crate :: mod1 :: * ; use std :: thread ; use std :: { sync :: { Arc , Mutex }, thread :: JoinHandle , }; pub struct ST2 { pub count : i32 , pub name : String , } pub fn mod2_init () -> ST2 { ST2 { count : 0 , name : String :: from ( \"MOD2\" ), } } pub fn run_th2 ( st1 : Arc < Mutex < ST1 >> ) -> JoinHandle < () > { thread :: spawn ( move || { thread :: park (); println ! ( \"Thread 2 started\" ); let mut st1_a = st1 . lock (). unwrap (); st1_a . count = st1_a . count + 1 ; }) } } fn main () { let st1 = mod1_init (); let st1_a = Arc :: new ( Mutex :: new ( st1 )); let st1_a2 = st1_a . clone (); let st2 = mod2_init (); let st2_a = Arc :: new ( Mutex :: new ( st2 )); let st2_a2 = st2_a . clone (); let th1 = run_th1 ( st2_a2 ); let th2 = run_th2 ( st1_a2 ); th1 . thread (). unpark (); th2 . thread (). unpark (); th1 . join (). unwrap (); th2 . join (). unwrap (); println ! ( \"{}\" , st1_a . clone (). lock (). unwrap (). count ); println ! ( \"{}\" , st2_a . clone (). lock (). unwrap (). count ); }","title":"Share"},{"location":"Share/#share","text":"","title":"Share"},{"location":"Share/#rust","text":"use mod1 :: * ; use mod2 :: * ; use std :: sync :: { Arc , Mutex }; mod mod1 { use crate :: mod2 :: * ; use std :: thread ; use std :: { sync :: { Arc , Mutex }, thread :: JoinHandle , }; pub struct ST1 { pub count : i32 , pub name : String , } pub fn mod1_init () -> ST1 { ST1 { count : 0 , name : String :: from ( \"MOD1\" ), } } pub fn run_th1 ( st2 : Arc < Mutex < ST2 >> ) -> JoinHandle < () > { thread :: spawn ( move || { thread :: park (); println ! ( \"Thread 1 started\" ); let mut st2_a = st2 . lock (). unwrap (); st2_a . count = st2_a . count + 2 ; }) } } mod mod2 { use crate :: mod1 :: * ; use std :: thread ; use std :: { sync :: { Arc , Mutex }, thread :: JoinHandle , }; pub struct ST2 { pub count : i32 , pub name : String , } pub fn mod2_init () -> ST2 { ST2 { count : 0 , name : String :: from ( \"MOD2\" ), } } pub fn run_th2 ( st1 : Arc < Mutex < ST1 >> ) -> JoinHandle < () > { thread :: spawn ( move || { thread :: park (); println ! ( \"Thread 2 started\" ); let mut st1_a = st1 . lock (). unwrap (); st1_a . count = st1_a . count + 1 ; }) } } fn main () { let st1 = mod1_init (); let st1_a = Arc :: new ( Mutex :: new ( st1 )); let st1_a2 = st1_a . clone (); let st2 = mod2_init (); let st2_a = Arc :: new ( Mutex :: new ( st2 )); let st2_a2 = st2_a . clone (); let th1 = run_th1 ( st2_a2 ); let th2 = run_th2 ( st1_a2 ); th1 . thread (). unpark (); th2 . thread (). unpark (); th1 . join (). unwrap (); th2 . join (). unwrap (); println ! ( \"{}\" , st1_a . clone (). lock (). unwrap (). count ); println ! ( \"{}\" , st2_a . clone (). lock (). unwrap (). count ); }","title":"Rust"},{"location":"String/","text":"String C# using System ; class Program { static void Main ( string [] args ) { var name = \"John\" ; var age = 21 ; var date = DateTime . Now ; // String interpolation: var str1 = $ \"{name} age is {age}, today is {date.DayOfWeek}, {date:HH:mm} now.\" ; Console . WriteLine ( str1 ); // String formatting: Console . WriteLine ( \"{0} age is {1}, today is {2}, {3:HH:mm} now.\" , name , age , date . DayOfWeek , date ); // float, hexadecimal var str2 = String . Format ( \"four decimals: {0:0.0000}, hex for {1}: 0x{2:X}\" , 0.123456 , 16 , 16 ); Console . WriteLine ( str2 ); // Parse numbers in string var elems = str2 . Split ( \" \" ); char [] toTrim = { ':' , ',' }; foreach ( var item in elems ) { try { var num = Double . Parse ( item . Trim ( toTrim )); Console . WriteLine ( \"Found float {0} in \\\"{1}\\\"\" , num , item ); } catch ( FormatException e ) { } } } } Dart // dependencies: // sprintf: ^4.0.2 import 'package:sprintf/sprintf.dart' ; main ( List < String > arguments ) { var name = \"John\" ; var age = 21 ; var date = DateTime . now (); var day = date . weekday ; // String interpolation var str1 = \" $ name age is $ age , weekday is $ day , ${ date . hour } : ${ date . minute } \" ; print ( str1 ); // String formatting float hex var str2 = sprintf ( \" \\n four decimals: %.4f, hex for %d: 0x%x\" , [ 0.123456 , 16 , 16 ]); print ( str2 ); // Parse number in string // Eliminate ',', ':' str2 = str2 . replaceAll ( ',' , '' ); str2 = str2 . replaceAll ( ':' , '' ); var elems = str2 . split ( \" \" ); for ( var item in elems ) { try { var num = double . parse ( item ); print ( \" Found float $ num in \\\" $ item \\\" \" ); } catch ( e ) { } } } Go package main import ( \"fmt\" \"strings\" \"time\" ) func main () { name := \"John\" age := 21 date := time . Now () // String interpolation str1 := fmt . Sprintf ( \"%s age is %d, weekday is %s, %d:%d\\n\" , name , age , date . Weekday (), date . Hour (), date . Minute ()) fmt . Print ( str1 ) str2 := fmt . Sprintf ( \"four decimals %.4f, hex for %d: 0x%x \\n\" , 1.23456 , 16 , 16 ) fmt . Print ( str2 ) //extract nth character chn2 := str2 [ 2 ] fmt . Printf ( \"char: %c\\n\" , chn2 ) //substring subs := str2 [ 0 : 3 ] fmt . Println ( \"subs: \" , subs ) elems := strings . Split ( str2 , \" \" ) var num float64 for _ , item := range elems { item = strings . Trim ( item , \",:\" ) _ , err := fmt . Sscanf ( item , \"%f\" , & num ) if err == nil { fmt . Printf ( \"Found float %f in \\\"%s\\\"\\n\" , num , item ) } } } Nim import strformat import times import strutils import sequtils let name = \"John\" ; let age = 21 ; let date = now () # String interpolation let str1 = & \"{name} age is {age}, weekday is {date.weekday}, {date.hour}:{date.minute}\" echo str1 # String formatting let str2 = & \"four decimals: {0.123456:2.4f}, hex for {16}: 0x{16:X}\" echo str2 var elems = str2 . split ( \" \" ) # Eliminate ',', ':' elems = map ( elems , proc ( x : string ): string = x . replace ( \",\" , \"\" )) elems = map ( elems , proc ( x : string ): string = x . replace ( \":\" , \"\" )) # Parse string for numbers for item in elems : try : let num = parseFloat ( item ) echo & \"Found float {num} in \\\" {item} \\\" \" except : discard Python import datetime name = \"John\" age = 21 date = datetime . datetime . now () # String interpolation str1 = f \"{name } age is {age} , today is {date.day} , {date.hour} : {date.minute} \" print ( str1 ) # String formatting str1 = \" {} age is {} , today us {} , {} : {} \" . format ( name , age , date . day , date . hour , date . minute ) print ( str1 ) # float, hexadecimal str2 = \"four decimals: {:.4f} , hex for {} : 0x {:x} \" . format ( 0.123456 , 16 , 16 ) print ( str2 ) # parse string for numbers elems = str2 . split ( \" \" ) for item in elems : item = item . replace ( \",\" , \"\" ) item = item . replace ( \":\" , \"\" ) try : num = float ( item ) print ( f \"Found {num} in \\\" {item} \\\" \" ) except : pass Rust // [dependencies] // chrono = \"*\" use chrono :: { Datelike , Timelike , Utc }; fn main () { let name = \"John\" ; let age = 21 ; let date = Utc :: now (); // STring formatting: string, int, date let str1 = & format ! ( \"{} age is {} weekday is, {:?}, {:?}:{:?}\" , name , age , date . weekday (), date . hour (), date . minute () ); println ! ( \"{}\" , str1 ); //float, hex let str2 = & format ! ( \"four decimals: {:.4}, hex for {}: 0x{:X}\" , 0.123456 , 16 , 16 ); println ! ( \"{}\" , str2 ); //extract nth character let mut chn2 = str2 . chars (). nth ( 2 ). unwrap (); println ! ( \"char: {}\" , chn2 ); //alternative let chn2 = & str2 [ 2 .. 3 ]; println ! ( \"char: {}\" , chn2 ); //substring let subs = & str2 [ 0 .. 3 ]; println ! ( \"subs: {}\" , subs ); // Parse string for numbers let elems : Vec <& str > = str2 . split ( \" \" ). collect (); // Eliminate ',', ':' let mut elems1 : Vec < String > = elems . into_iter (). map ( | x | x . replace ( \",\" , \"\" )). collect (); elems1 = elems1 . into_iter (). map ( | x | x . replace ( \":\" , \"\" )). collect (); for item in elems1 { match item . parse :: < f64 > () { Ok ( num ) => println ! ( \" Found float {} in \\\" {} \\\" \" , num , item ), Err ( _ ) => {} } } } TypeScript let name1 = \"John\" ; let age = 21 ; let date = new Date (); // String interpolation (use backtick) let str1 = ` ${ name1 } age is ${ age } , today is ${ date . getDay () } , ${ date . getHours () } : ${ date . getMinutes () } ` ; console . log ( str1 ); let num = 16 let str2 = `four decimals: ${ 1.23456 . toFixed ( 4 ) } , hex for ${ num } is 0x ${ num . toString ( 16 ) } ` ; console . log ( str2 ); // Parse string for number let elems = str2 . split ( \" \" ); elems . forEach ( item => { let num = parseFloat ( item ); if ( ! isNaN ( num )) { console . log ( `Found float ${ num } in \\ \" ${ item } \\ \"` ); } });","title":"String"},{"location":"String/#string","text":"","title":"String"},{"location":"String/#c","text":"using System ; class Program { static void Main ( string [] args ) { var name = \"John\" ; var age = 21 ; var date = DateTime . Now ; // String interpolation: var str1 = $ \"{name} age is {age}, today is {date.DayOfWeek}, {date:HH:mm} now.\" ; Console . WriteLine ( str1 ); // String formatting: Console . WriteLine ( \"{0} age is {1}, today is {2}, {3:HH:mm} now.\" , name , age , date . DayOfWeek , date ); // float, hexadecimal var str2 = String . Format ( \"four decimals: {0:0.0000}, hex for {1}: 0x{2:X}\" , 0.123456 , 16 , 16 ); Console . WriteLine ( str2 ); // Parse numbers in string var elems = str2 . Split ( \" \" ); char [] toTrim = { ':' , ',' }; foreach ( var item in elems ) { try { var num = Double . Parse ( item . Trim ( toTrim )); Console . WriteLine ( \"Found float {0} in \\\"{1}\\\"\" , num , item ); } catch ( FormatException e ) { } } } }","title":"C#"},{"location":"String/#dart","text":"// dependencies: // sprintf: ^4.0.2 import 'package:sprintf/sprintf.dart' ; main ( List < String > arguments ) { var name = \"John\" ; var age = 21 ; var date = DateTime . now (); var day = date . weekday ; // String interpolation var str1 = \" $ name age is $ age , weekday is $ day , ${ date . hour } : ${ date . minute } \" ; print ( str1 ); // String formatting float hex var str2 = sprintf ( \" \\n four decimals: %.4f, hex for %d: 0x%x\" , [ 0.123456 , 16 , 16 ]); print ( str2 ); // Parse number in string // Eliminate ',', ':' str2 = str2 . replaceAll ( ',' , '' ); str2 = str2 . replaceAll ( ':' , '' ); var elems = str2 . split ( \" \" ); for ( var item in elems ) { try { var num = double . parse ( item ); print ( \" Found float $ num in \\\" $ item \\\" \" ); } catch ( e ) { } } }","title":"Dart"},{"location":"String/#go","text":"package main import ( \"fmt\" \"strings\" \"time\" ) func main () { name := \"John\" age := 21 date := time . Now () // String interpolation str1 := fmt . Sprintf ( \"%s age is %d, weekday is %s, %d:%d\\n\" , name , age , date . Weekday (), date . Hour (), date . Minute ()) fmt . Print ( str1 ) str2 := fmt . Sprintf ( \"four decimals %.4f, hex for %d: 0x%x \\n\" , 1.23456 , 16 , 16 ) fmt . Print ( str2 ) //extract nth character chn2 := str2 [ 2 ] fmt . Printf ( \"char: %c\\n\" , chn2 ) //substring subs := str2 [ 0 : 3 ] fmt . Println ( \"subs: \" , subs ) elems := strings . Split ( str2 , \" \" ) var num float64 for _ , item := range elems { item = strings . Trim ( item , \",:\" ) _ , err := fmt . Sscanf ( item , \"%f\" , & num ) if err == nil { fmt . Printf ( \"Found float %f in \\\"%s\\\"\\n\" , num , item ) } } }","title":"Go"},{"location":"String/#nim","text":"import strformat import times import strutils import sequtils let name = \"John\" ; let age = 21 ; let date = now () # String interpolation let str1 = & \"{name} age is {age}, weekday is {date.weekday}, {date.hour}:{date.minute}\" echo str1 # String formatting let str2 = & \"four decimals: {0.123456:2.4f}, hex for {16}: 0x{16:X}\" echo str2 var elems = str2 . split ( \" \" ) # Eliminate ',', ':' elems = map ( elems , proc ( x : string ): string = x . replace ( \",\" , \"\" )) elems = map ( elems , proc ( x : string ): string = x . replace ( \":\" , \"\" )) # Parse string for numbers for item in elems : try : let num = parseFloat ( item ) echo & \"Found float {num} in \\\" {item} \\\" \" except : discard","title":"Nim"},{"location":"String/#python","text":"import datetime name = \"John\" age = 21 date = datetime . datetime . now () # String interpolation str1 = f \"{name } age is {age} , today is {date.day} , {date.hour} : {date.minute} \" print ( str1 ) # String formatting str1 = \" {} age is {} , today us {} , {} : {} \" . format ( name , age , date . day , date . hour , date . minute ) print ( str1 ) # float, hexadecimal str2 = \"four decimals: {:.4f} , hex for {} : 0x {:x} \" . format ( 0.123456 , 16 , 16 ) print ( str2 ) # parse string for numbers elems = str2 . split ( \" \" ) for item in elems : item = item . replace ( \",\" , \"\" ) item = item . replace ( \":\" , \"\" ) try : num = float ( item ) print ( f \"Found {num} in \\\" {item} \\\" \" ) except : pass","title":"Python"},{"location":"String/#rust","text":"// [dependencies] // chrono = \"*\" use chrono :: { Datelike , Timelike , Utc }; fn main () { let name = \"John\" ; let age = 21 ; let date = Utc :: now (); // STring formatting: string, int, date let str1 = & format ! ( \"{} age is {} weekday is, {:?}, {:?}:{:?}\" , name , age , date . weekday (), date . hour (), date . minute () ); println ! ( \"{}\" , str1 ); //float, hex let str2 = & format ! ( \"four decimals: {:.4}, hex for {}: 0x{:X}\" , 0.123456 , 16 , 16 ); println ! ( \"{}\" , str2 ); //extract nth character let mut chn2 = str2 . chars (). nth ( 2 ). unwrap (); println ! ( \"char: {}\" , chn2 ); //alternative let chn2 = & str2 [ 2 .. 3 ]; println ! ( \"char: {}\" , chn2 ); //substring let subs = & str2 [ 0 .. 3 ]; println ! ( \"subs: {}\" , subs ); // Parse string for numbers let elems : Vec <& str > = str2 . split ( \" \" ). collect (); // Eliminate ',', ':' let mut elems1 : Vec < String > = elems . into_iter (). map ( | x | x . replace ( \",\" , \"\" )). collect (); elems1 = elems1 . into_iter (). map ( | x | x . replace ( \":\" , \"\" )). collect (); for item in elems1 { match item . parse :: < f64 > () { Ok ( num ) => println ! ( \" Found float {} in \\\" {} \\\" \" , num , item ), Err ( _ ) => {} } } }","title":"Rust"},{"location":"String/#typescript","text":"let name1 = \"John\" ; let age = 21 ; let date = new Date (); // String interpolation (use backtick) let str1 = ` ${ name1 } age is ${ age } , today is ${ date . getDay () } , ${ date . getHours () } : ${ date . getMinutes () } ` ; console . log ( str1 ); let num = 16 let str2 = `four decimals: ${ 1.23456 . toFixed ( 4 ) } , hex for ${ num } is 0x ${ num . toString ( 16 ) } ` ; console . log ( str2 ); // Parse string for number let elems = str2 . split ( \" \" ); elems . forEach ( item => { let num = parseFloat ( item ); if ( ! isNaN ( num )) { console . log ( `Found float ${ num } in \\ \" ${ item } \\ \"` ); } });","title":"TypeScript"},{"location":"Structure%20or%20Class/","text":"Structure or Class C# using System ; class Person { public string firstName ; public string secondName ; //constructor with default arguments public Person ( string fname = \"John\" , string sname = \"Doe\" ) { firstName = fname ; secondName = sname ; } } class Customer { public Person person ; //keep balance private double balance = 0.0 ; public Customer ( Person p ) { person = p ; } //methods public void AddToBalance ( double sum ) { balance += sum ; } public double GetBalance () { return balance ; } } class Program { static void Main ( string [] args ) { var p1 = new Person ( \"Mark\" ); var c1 = new Customer ( p1 ); //methos c1 . AddToBalance ( 100.0 ); c1 . AddToBalance ( 10.0 ); //property Console . WriteLine ( \"New {0} balance: {1}\" , c1 . person . firstName , c1 . GetBalance ()); } } Dart //file moda.dart -> package moda class Person { String firstName ; String secondName ; //Default/Optional parameters between [] Person ([ this . firstName = \"John\" , this . secondName = \"Doe\" ]) ; } class Customer { Person person ; //starting underscore: not visible outside package double _balance ; Customer ( this . person , [ this . _balance = 0.0 ]); void addToBalance ( double sum ) { this . _balance += sum ; } double getBalance () { return this . _balance ; } } import 'moda.dart' ; main ( List < String > args ) { var p1 = Person ( \"Mark\" ); var c1 = Customer ( p1 ); c1 . person = p1 ; //Method c1 . addToBalance ( 100.0 ); c1 . addToBalance ( 10.0 ); //Property var name = c1 . person . firstName ; var balance = c1 . getBalance (); print ( \"New $ name balance: $ balance \" ); } Go //file src/moda/go.mod //generated by \"go mod init moda\" module moda go 1.17 //file src/moda/moda.go -> package moda package moda // all public identifier must start with Uppercase type Person struct { FirstName string SecondName string } type Customer struct { Person Person balance float64 //lowercase because private } // struct creation with optional parameters func NewPerson ( args ... string ) Person { firstName := \"John\" secondName := \"Doe\" if len ( args ) > 0 { firstName = args [ 0 ] } if len ( args ) > 1 { secondName = args [ 1 ] } return Person { FirstName : firstName , SecondName : secondName } } // struct creation func NewCustomer ( person Person ) Customer { return Customer { Person : person , balance : 0.0 } } // public methods for Customer func ( customer * Customer ) AddToBalance ( sum float64 ) { customer . balance += sum } func ( customer * Customer ) GetBalance () float64 { return customer . balance } //file src/go.mod //generated by \"go mod init main\" //then manually modified module main require moda v1 .0.0 replace moda => . / moda go 1.17 //file src/main.go package main import ( \"fmt\" \"moda\" ) func main () { p1 := moda . NewPerson ( \"Mark\" ) c1 := moda . NewCustomer ( p1 ) //method c1 . AddToBalance ( 100.0 ) c1 . AddToBalance ( 10.0 ) balance := c1 . GetBalance () //property fmt . Printf ( \"\\nNew %v balance: %v\" , c1 . Person . FirstName , balance ) } Nim # file moda.nim -> module moda type Person * = ref object # asterisk for public firstName : string secondName : string # getter proc firstName * ( person : Person ): string = person . firstName proc newPerson * ( fName : string = \"John\" , sName : string = \"Doe\" ): Person = Person ( firstName : fName , secondName : sName ) type Customer * = ref object person : Person balance : float64 # getter proc person * ( customer : Customer ): Person = customer . person # getter proc balance * ( customer : Customer ): float64 = customer . balance proc newCustomer * ( p : Person , b : float64 = 0.0 ): Customer = Customer ( person : p , balance : b ) # method proc addToBalance * ( c : Customer , sum : float64 ) = c . balance = c . balance + sum import moda import strformat as sf let p1 : Person = moda . newPerson ( \"Mark\" ) #use default for secondName var c1 = moda . newCustomer ( p1 ) #use default for balance # method c1 . addToBalance ( 100.0 ) c1 . addToBalance ( 10.0 ) # property, reading only through getter echo sf . fmt\"New {c1.person.first_name} balance: {c1.balance}\" Python from dataclasses import dataclass @dataclass class Person : first_name : str = \"John\" second_name : str = \"Doe\" @dataclass class Customer : person : Person # double initial underscore for private __balance : float = 0.0 def add_to_balance ( self , num : float ): self . __balance += num def get_balance ( self ) -> float : return self . __balance p1 = Person ( \"Mark\" ) # use default for second_name c1 = Customer ( p1 ) #use default for balance # method c1 . add_to_balance ( 100.0 ) c1 . add_to_balance ( 10.0 ) new_balance = c1 . get_balance () # property print ( f \" New {c1.person.firstName} balance: {new_balance} \" ) Rust //private fields/methods are not visible outside the module mod mod1 { #[derive(Debug)] pub struct Person { pub first_name : String , pub second_name : String , } #[derive(Debug)] pub struct Customer { pub person : Person , balance : f64 , } //default accessible outside only if fields are all public impl Default for Person { fn default () -> Self { Person { first_name : \"John\" . to_string (), second_name : \"Doe\" . to_string (), } } } impl Customer { pub fn new () -> Self { Customer { person : Person {.. Person :: default ()}, balance : 0.0 } } pub fn add_to_balance ( & mut self , sum : f64 ) { self . balance += sum ; } pub fn get_balance ( & self ) -> f64 { self . balance } } } use mod1 :: * ; fn main () { let mut c1 = Customer :: new (); //use person and balance default c1 . person . first_name = \"Mark\" . to_string (); //change first_name println ! ( \"{:?}\" , & c1 ); //Method c1 . add_to_balance ( 100.0 ); c1 . add_to_balance ( 10.0 ); //Property println ! ( \"New {} balance: {} \" , & c1 . person . first_name , c1 . get_balance ()); } Sing requires \"sio\" ; requires \"mod1\" ; public fn singmain ( argv [ * ] string ) i32 { var c1 mod1 . Customer ; c1 . person . first_name = \"Mark\" ; sio . print ( \" \\n\\r \" + c1 . person . first_name + \", \" + c1 . person . second_name ); c1 . add_to_balance ( 100.0 ); c1 . add_to_balance ( 10.0 ); sio . print ( \" \\n\\r New Balance: \" + string ( c1 . get_balance ())); return ( 0 ); } //in a different file named mod1.sing: public class Person { public : //members with default var first_name string = \"John\" ; var second_name string = \"Doe\" ; } public class Customer { public : var person Person ; fn mut add_to_balance ( sum f64 ) void ; fn get_balance () f64 ; private : var balance f64 ; } public fn Customer . add_to_balance ( sum f64 ) void { this . balance = this . balance + sum ; } public fn Customer . get_balance () f64 { return ( this . balance ); } TypeScript class Person { firstName : string ; secondName : string ; //Default/Optional parameters constructor ( fname : string = \"John\" , sname : string = \"Doe\" ) { this . firstName = fname ; this . secondName = sname ; } } class Customer { person : Person ; private _balance : number = 0.0 ; constructor ( p : Person ) { this . person = p ; } addToBalance ( sum : number ) { this . _balance += sum ; } getBalance() { return this . _balance ; } } var p1 = new Person ( \"Mark\" ); var c1 = new Customer ( p1 ); c1 . person = p1 ; //Method c1 . addToBalance ( 100.0 ); c1 . addToBalance ( 10.0 ); //Property var pname = c1 . person . firstName ; var balance = c1 . getBalance (); console . log ( `New ${ pname } balance: ${ balance } ` ); V (vlang) // src/moda/moda.v module moda pub struct Person { pub mut : first_name string second_name string } pub struct Customer { mut : balance f64 pub mut : person Person } pub fn ( mut customer Customer ) add_to_balance ( sum f64 ) { customer . balance += sum } pub fn ( customer Customer ) get_balance () f64 { return customer . balance } // src/ import moda as md fn main () { p1 := md . Person { \"Mark\" , \"Smith\" } mut c1 := md . Customer { 0 , p1 } c1 . add_to_balance ( 100.0 ) c1 . add_to_balance ( 10.0 ) balance := c1 . get_balance () println ( \"$p1.first_name balance: $balance\" ) }","title":"Structure or Class"},{"location":"Structure%20or%20Class/#structure-or-class","text":"","title":"Structure or Class"},{"location":"Structure%20or%20Class/#c","text":"using System ; class Person { public string firstName ; public string secondName ; //constructor with default arguments public Person ( string fname = \"John\" , string sname = \"Doe\" ) { firstName = fname ; secondName = sname ; } } class Customer { public Person person ; //keep balance private double balance = 0.0 ; public Customer ( Person p ) { person = p ; } //methods public void AddToBalance ( double sum ) { balance += sum ; } public double GetBalance () { return balance ; } } class Program { static void Main ( string [] args ) { var p1 = new Person ( \"Mark\" ); var c1 = new Customer ( p1 ); //methos c1 . AddToBalance ( 100.0 ); c1 . AddToBalance ( 10.0 ); //property Console . WriteLine ( \"New {0} balance: {1}\" , c1 . person . firstName , c1 . GetBalance ()); } }","title":"C#"},{"location":"Structure%20or%20Class/#dart","text":"//file moda.dart -> package moda class Person { String firstName ; String secondName ; //Default/Optional parameters between [] Person ([ this . firstName = \"John\" , this . secondName = \"Doe\" ]) ; } class Customer { Person person ; //starting underscore: not visible outside package double _balance ; Customer ( this . person , [ this . _balance = 0.0 ]); void addToBalance ( double sum ) { this . _balance += sum ; } double getBalance () { return this . _balance ; } } import 'moda.dart' ; main ( List < String > args ) { var p1 = Person ( \"Mark\" ); var c1 = Customer ( p1 ); c1 . person = p1 ; //Method c1 . addToBalance ( 100.0 ); c1 . addToBalance ( 10.0 ); //Property var name = c1 . person . firstName ; var balance = c1 . getBalance (); print ( \"New $ name balance: $ balance \" ); }","title":"Dart"},{"location":"Structure%20or%20Class/#go","text":"//file src/moda/go.mod //generated by \"go mod init moda\" module moda go 1.17 //file src/moda/moda.go -> package moda package moda // all public identifier must start with Uppercase type Person struct { FirstName string SecondName string } type Customer struct { Person Person balance float64 //lowercase because private } // struct creation with optional parameters func NewPerson ( args ... string ) Person { firstName := \"John\" secondName := \"Doe\" if len ( args ) > 0 { firstName = args [ 0 ] } if len ( args ) > 1 { secondName = args [ 1 ] } return Person { FirstName : firstName , SecondName : secondName } } // struct creation func NewCustomer ( person Person ) Customer { return Customer { Person : person , balance : 0.0 } } // public methods for Customer func ( customer * Customer ) AddToBalance ( sum float64 ) { customer . balance += sum } func ( customer * Customer ) GetBalance () float64 { return customer . balance } //file src/go.mod //generated by \"go mod init main\" //then manually modified module main require moda v1 .0.0 replace moda => . / moda go 1.17 //file src/main.go package main import ( \"fmt\" \"moda\" ) func main () { p1 := moda . NewPerson ( \"Mark\" ) c1 := moda . NewCustomer ( p1 ) //method c1 . AddToBalance ( 100.0 ) c1 . AddToBalance ( 10.0 ) balance := c1 . GetBalance () //property fmt . Printf ( \"\\nNew %v balance: %v\" , c1 . Person . FirstName , balance ) }","title":"Go"},{"location":"Structure%20or%20Class/#nim","text":"# file moda.nim -> module moda type Person * = ref object # asterisk for public firstName : string secondName : string # getter proc firstName * ( person : Person ): string = person . firstName proc newPerson * ( fName : string = \"John\" , sName : string = \"Doe\" ): Person = Person ( firstName : fName , secondName : sName ) type Customer * = ref object person : Person balance : float64 # getter proc person * ( customer : Customer ): Person = customer . person # getter proc balance * ( customer : Customer ): float64 = customer . balance proc newCustomer * ( p : Person , b : float64 = 0.0 ): Customer = Customer ( person : p , balance : b ) # method proc addToBalance * ( c : Customer , sum : float64 ) = c . balance = c . balance + sum import moda import strformat as sf let p1 : Person = moda . newPerson ( \"Mark\" ) #use default for secondName var c1 = moda . newCustomer ( p1 ) #use default for balance # method c1 . addToBalance ( 100.0 ) c1 . addToBalance ( 10.0 ) # property, reading only through getter echo sf . fmt\"New {c1.person.first_name} balance: {c1.balance}\"","title":"Nim"},{"location":"Structure%20or%20Class/#python","text":"from dataclasses import dataclass @dataclass class Person : first_name : str = \"John\" second_name : str = \"Doe\" @dataclass class Customer : person : Person # double initial underscore for private __balance : float = 0.0 def add_to_balance ( self , num : float ): self . __balance += num def get_balance ( self ) -> float : return self . __balance p1 = Person ( \"Mark\" ) # use default for second_name c1 = Customer ( p1 ) #use default for balance # method c1 . add_to_balance ( 100.0 ) c1 . add_to_balance ( 10.0 ) new_balance = c1 . get_balance () # property print ( f \" New {c1.person.firstName} balance: {new_balance} \" )","title":"Python"},{"location":"Structure%20or%20Class/#rust","text":"//private fields/methods are not visible outside the module mod mod1 { #[derive(Debug)] pub struct Person { pub first_name : String , pub second_name : String , } #[derive(Debug)] pub struct Customer { pub person : Person , balance : f64 , } //default accessible outside only if fields are all public impl Default for Person { fn default () -> Self { Person { first_name : \"John\" . to_string (), second_name : \"Doe\" . to_string (), } } } impl Customer { pub fn new () -> Self { Customer { person : Person {.. Person :: default ()}, balance : 0.0 } } pub fn add_to_balance ( & mut self , sum : f64 ) { self . balance += sum ; } pub fn get_balance ( & self ) -> f64 { self . balance } } } use mod1 :: * ; fn main () { let mut c1 = Customer :: new (); //use person and balance default c1 . person . first_name = \"Mark\" . to_string (); //change first_name println ! ( \"{:?}\" , & c1 ); //Method c1 . add_to_balance ( 100.0 ); c1 . add_to_balance ( 10.0 ); //Property println ! ( \"New {} balance: {} \" , & c1 . person . first_name , c1 . get_balance ()); }","title":"Rust"},{"location":"Structure%20or%20Class/#sing","text":"requires \"sio\" ; requires \"mod1\" ; public fn singmain ( argv [ * ] string ) i32 { var c1 mod1 . Customer ; c1 . person . first_name = \"Mark\" ; sio . print ( \" \\n\\r \" + c1 . person . first_name + \", \" + c1 . person . second_name ); c1 . add_to_balance ( 100.0 ); c1 . add_to_balance ( 10.0 ); sio . print ( \" \\n\\r New Balance: \" + string ( c1 . get_balance ())); return ( 0 ); } //in a different file named mod1.sing: public class Person { public : //members with default var first_name string = \"John\" ; var second_name string = \"Doe\" ; } public class Customer { public : var person Person ; fn mut add_to_balance ( sum f64 ) void ; fn get_balance () f64 ; private : var balance f64 ; } public fn Customer . add_to_balance ( sum f64 ) void { this . balance = this . balance + sum ; } public fn Customer . get_balance () f64 { return ( this . balance ); }","title":"Sing"},{"location":"Structure%20or%20Class/#typescript","text":"class Person { firstName : string ; secondName : string ; //Default/Optional parameters constructor ( fname : string = \"John\" , sname : string = \"Doe\" ) { this . firstName = fname ; this . secondName = sname ; } } class Customer { person : Person ; private _balance : number = 0.0 ; constructor ( p : Person ) { this . person = p ; } addToBalance ( sum : number ) { this . _balance += sum ; } getBalance() { return this . _balance ; } } var p1 = new Person ( \"Mark\" ); var c1 = new Customer ( p1 ); c1 . person = p1 ; //Method c1 . addToBalance ( 100.0 ); c1 . addToBalance ( 10.0 ); //Property var pname = c1 . person . firstName ; var balance = c1 . getBalance (); console . log ( `New ${ pname } balance: ${ balance } ` );","title":"TypeScript"},{"location":"Structure%20or%20Class/#v-vlang","text":"// src/moda/moda.v module moda pub struct Person { pub mut : first_name string second_name string } pub struct Customer { mut : balance f64 pub mut : person Person } pub fn ( mut customer Customer ) add_to_balance ( sum f64 ) { customer . balance += sum } pub fn ( customer Customer ) get_balance () f64 { return customer . balance } // src/ import moda as md fn main () { p1 := md . Person { \"Mark\" , \"Smith\" } mut c1 := md . Customer { 0 , p1 } c1 . add_to_balance ( 100.0 ) c1 . add_to_balance ( 10.0 ) balance := c1 . get_balance () println ( \"$p1.first_name balance: $balance\" ) }","title":"V (vlang)"},{"location":"System%20command/","text":"System command C# using System ; using System.Diagnostics ; public class Program { public static void Main ( string [] args ) { var psi = new ProcessStartInfo (); var process = new Process (); //(\"cargo\", \"version\"); psi . Arguments = \"--version\" ; psi . FileName = \"dotnet\" ; psi . RedirectStandardOutput = true ; psi . UseShellExecute = false ; process . StartInfo = psi ; process . Start (); while (! process . StandardOutput . EndOfStream ) { var line = process . StandardOutput . ReadLine (); Console . WriteLine ( line ); } } } Dart import \"dart:io\" ; main ( List < String > arguments ) { Process . run ( 'cargo' , [ 'version' ]). then (( ProcessResult result ) { print ( result . stdout ); }); } Go package main import ( . \"fmt\" \"os/exec\" \"runtime\" ) func main () { if runtime . GOOS == \"linux\" { out , _ := exec . Command ( \"/bin/sh\" , \"-c\" , \"ls\" ). Output () output := string ( out ) Printf ( \"\\n%s\" , output ) } else { //windows out , _ := exec . Command ( \"cmd\" , \"/C\" , \"dir\" ). Output () output := string ( out ) Printf ( \"\\n%s\" , output ) } } Python import subprocess outp = subprocess . run ([ \"pip\" , \"--version\" ], capture_output = True , text = True ) print ( outp . stdout ) Rust use std :: process :: Command ; fn main () { let output = Command :: new ( \"cargo\" ) . args ( & [ \"version\" ]) . output () . expect ( \"failed to execute process\" ); println ! ( \"stdout: {}\" , String :: from_utf8_lossy ( & output . stdout )); //windows only let output2 = Command :: new ( \"cmd\" ) . args ( & [ \"/C\" , \"dir\" ]) . output () . expect ( \"failed to execute process\" ); println ! ( \"stdout: {}\" , String :: from_utf8_lossy ( & output2 . stdout )); }","title":"System command"},{"location":"System%20command/#system-command","text":"","title":"System command"},{"location":"System%20command/#c","text":"using System ; using System.Diagnostics ; public class Program { public static void Main ( string [] args ) { var psi = new ProcessStartInfo (); var process = new Process (); //(\"cargo\", \"version\"); psi . Arguments = \"--version\" ; psi . FileName = \"dotnet\" ; psi . RedirectStandardOutput = true ; psi . UseShellExecute = false ; process . StartInfo = psi ; process . Start (); while (! process . StandardOutput . EndOfStream ) { var line = process . StandardOutput . ReadLine (); Console . WriteLine ( line ); } } }","title":"C#"},{"location":"System%20command/#dart","text":"import \"dart:io\" ; main ( List < String > arguments ) { Process . run ( 'cargo' , [ 'version' ]). then (( ProcessResult result ) { print ( result . stdout ); }); }","title":"Dart"},{"location":"System%20command/#go","text":"package main import ( . \"fmt\" \"os/exec\" \"runtime\" ) func main () { if runtime . GOOS == \"linux\" { out , _ := exec . Command ( \"/bin/sh\" , \"-c\" , \"ls\" ). Output () output := string ( out ) Printf ( \"\\n%s\" , output ) } else { //windows out , _ := exec . Command ( \"cmd\" , \"/C\" , \"dir\" ). Output () output := string ( out ) Printf ( \"\\n%s\" , output ) } }","title":"Go"},{"location":"System%20command/#python","text":"import subprocess outp = subprocess . run ([ \"pip\" , \"--version\" ], capture_output = True , text = True ) print ( outp . stdout )","title":"Python"},{"location":"System%20command/#rust","text":"use std :: process :: Command ; fn main () { let output = Command :: new ( \"cargo\" ) . args ( & [ \"version\" ]) . output () . expect ( \"failed to execute process\" ); println ! ( \"stdout: {}\" , String :: from_utf8_lossy ( & output . stdout )); //windows only let output2 = Command :: new ( \"cmd\" ) . args ( & [ \"/C\" , \"dir\" ]) . output () . expect ( \"failed to execute process\" ); println ! ( \"stdout: {}\" , String :: from_utf8_lossy ( & output2 . stdout )); }","title":"Rust"},{"location":"TOML/","text":"TOML Go //go.mod //require github.com/pelletier/go-toml v1.9.4 package main import ( . \"fmt\" \"os\" toml \"github.com/pelletier/go-toml\" ) // all fields must be Public (Capitalized)! type Person struct { Name string `toml:\"name\"` Val int `toml:\"val\"` } type TomlConfig struct { Person Person `toml:\"person\"` } const CONF_TOML_PATH = \"conf.toml\" func main () { cfg := TomlConfig { Person { Name : \"Joe\" , Val : 10 }} Println ( cfg ) b , err := toml . Marshal ( cfg ) if err != nil { panic ( err ) } Println ( string ( b )) file , err := os . Create ( CONF_TOML_PATH ) if err != nil { panic ( err ) } file . Write ( b ) file . Close () var cfg2 TomlConfig b2 , err := os . ReadFile ( CONF_TOML_PATH ) err = toml . Unmarshal ( b2 , & cfg2 ) if err != nil { panic ( err ) } Println ( cfg2 ) } Rust //[dependencies] //toml = \"0.5.8\" //serde = \"1.0.125\" //serde_derive = \"1.0.125\" use serde_derive :: { Deserialize , Serialize }; use std :: fs :: File ; use std :: io :: prelude :: * ; //without this, no file write const CONF_TOML_PATH : & str = \"conf.toml\" ; #[derive(Clone, Debug, Deserialize, Serialize)] struct TomlConfig { name : String , val : i32 , } fn init_conf () -> TomlConfig { let file_found = match File :: open ( CONF_TOML_PATH ) { Ok ( _ ) => true , Err ( _ ) => false , }; if ! file_found { return TomlConfig { name : String :: from ( \"Joe\" ), val : 10 }; } let mut fs_conf = File :: open ( CONF_TOML_PATH ). unwrap (); let mut str1 = String :: new (); fs_conf . read_to_string ( & mut str1 ). unwrap (); let tconf : TomlConfig = toml :: from_str ( & str1 ). unwrap (); tconf } fn main () { let mut conf = init_conf (); conf . val = 20 ; let conf_str = toml :: to_string ( & conf ). unwrap (); let mut fs_conf = File :: create ( CONF_TOML_PATH ). unwrap (); fs_conf . write ( & conf_str . as_bytes ()). unwrap (); }","title":"TOML"},{"location":"TOML/#toml","text":"","title":"TOML"},{"location":"TOML/#go","text":"//go.mod //require github.com/pelletier/go-toml v1.9.4 package main import ( . \"fmt\" \"os\" toml \"github.com/pelletier/go-toml\" ) // all fields must be Public (Capitalized)! type Person struct { Name string `toml:\"name\"` Val int `toml:\"val\"` } type TomlConfig struct { Person Person `toml:\"person\"` } const CONF_TOML_PATH = \"conf.toml\" func main () { cfg := TomlConfig { Person { Name : \"Joe\" , Val : 10 }} Println ( cfg ) b , err := toml . Marshal ( cfg ) if err != nil { panic ( err ) } Println ( string ( b )) file , err := os . Create ( CONF_TOML_PATH ) if err != nil { panic ( err ) } file . Write ( b ) file . Close () var cfg2 TomlConfig b2 , err := os . ReadFile ( CONF_TOML_PATH ) err = toml . Unmarshal ( b2 , & cfg2 ) if err != nil { panic ( err ) } Println ( cfg2 ) }","title":"Go"},{"location":"TOML/#rust","text":"//[dependencies] //toml = \"0.5.8\" //serde = \"1.0.125\" //serde_derive = \"1.0.125\" use serde_derive :: { Deserialize , Serialize }; use std :: fs :: File ; use std :: io :: prelude :: * ; //without this, no file write const CONF_TOML_PATH : & str = \"conf.toml\" ; #[derive(Clone, Debug, Deserialize, Serialize)] struct TomlConfig { name : String , val : i32 , } fn init_conf () -> TomlConfig { let file_found = match File :: open ( CONF_TOML_PATH ) { Ok ( _ ) => true , Err ( _ ) => false , }; if ! file_found { return TomlConfig { name : String :: from ( \"Joe\" ), val : 10 }; } let mut fs_conf = File :: open ( CONF_TOML_PATH ). unwrap (); let mut str1 = String :: new (); fs_conf . read_to_string ( & mut str1 ). unwrap (); let tconf : TomlConfig = toml :: from_str ( & str1 ). unwrap (); tconf } fn main () { let mut conf = init_conf (); conf . val = 20 ; let conf_str = toml :: to_string ( & conf ). unwrap (); let mut fs_conf = File :: create ( CONF_TOML_PATH ). unwrap (); fs_conf . write ( & conf_str . as_bytes ()). unwrap (); }","title":"Rust"},{"location":"Tuples/","text":"Tuples Python t1 = ( 1 , 10 , \"hello\" ) print ( f '{t1[0], t1[1], t1[2]}' ) # delete an element a , b , c = t1 t2 = ( a , c ) print ( f ' {t2} ' ) # add an element t3 = ( a , 2 , b , c ) print ( f ' {t3} ' ) # add tuples t4 = t2 + t2 print ( f ' {t4} ' ) # tuple to list lst = list (( 1 , 2 , 3 )) print ( f ' {lst} ' ) Rust fn main () { let t1 = ( 1 , 10 , \"hello\" ); println ! ( \"{} {} {}\" , t1 . 0 , t1 . 1 , t1 . 2 ); //delete an element let ( a , b , c ) = t1 ; let t2 = ( a , c ); println ! ( \"{:?}\" , t2 ); //add an element let t3 = ( a , 2 , b , c ); println ! ( \"{:?}\" , t3 ); }","title":"Tuples"},{"location":"Tuples/#tuples","text":"","title":"Tuples"},{"location":"Tuples/#python","text":"t1 = ( 1 , 10 , \"hello\" ) print ( f '{t1[0], t1[1], t1[2]}' ) # delete an element a , b , c = t1 t2 = ( a , c ) print ( f ' {t2} ' ) # add an element t3 = ( a , 2 , b , c ) print ( f ' {t3} ' ) # add tuples t4 = t2 + t2 print ( f ' {t4} ' ) # tuple to list lst = list (( 1 , 2 , 3 )) print ( f ' {lst} ' )","title":"Python"},{"location":"Tuples/#rust","text":"fn main () { let t1 = ( 1 , 10 , \"hello\" ); println ! ( \"{} {} {}\" , t1 . 0 , t1 . 1 , t1 . 2 ); //delete an element let ( a , b , c ) = t1 ; let t2 = ( a , c ); println ! ( \"{:?}\" , t2 ); //add an element let t3 = ( a , 2 , b , c ); println ! ( \"{:?}\" , t3 ); }","title":"Rust"},{"location":"Union/","text":"Union C# using System ; using System.Collections.Generic ; public interface IComposite { bool isComposite (); } class Person : IComposite { public string firstName ; public string secondName ; //constructor with default arguments public Person ( string fname = \"John\" , string sname = \"Doe\" ) { firstName = fname ; secondName = sname ; } bool IComposite . isComposite () { return true ; } } public class CInt : IComposite { bool IComposite . isComposite () { return true ; } public int value ; public CInt ( int num ) { value = num ; } } public class Program { public static void Main ( string [] args ) { var p1 = new Person (); var c1 = new CInt ( 12 ); cType ( p1 ); cType ( c1 ); //int needs to be enveloped in CInt } public static void cType ( IComposite c ) { if ( c is Person cp ) { Console . Write ( \"Person {0}\\n\" , cp . firstName ); } else if ( c is CInt ci ) { Console . Write ( \"Number {0}\\n\" , ci . value ); } } } Dart // interface to represent union class IComposite { bool isComposite () { return true ;} } class Person implements IComposite { String firstName ; String secondName ; Person ([ this . firstName = \"John\" , this . secondName = \"Doe\" ]); bool isComposite () { return true ; } } class CInt implements IComposite { int value ; CInt ( this . value ); bool isComposite () { return true ; } } main ( List < String > args ) { var p1 = Person (); cType ( p1 ); cType ( CInt ( 12 )); //int needs to be enveloped in CInt } cType ( IComposite c ) { if ( c is CInt ) { //cast to the actual type var c1 = c as CInt ; var value = c1 . value ; print ( \"Number $ value \" ); } else if ( c is Person ) { //cast to the actual type var p1 = c as Person ; var name = p1 . firstName ; print ( \"Person $ name \" ); } } Go package main import ( \"fmt\" ) type CompositeType interface { isComposite () bool } type Person struct { FirstName string SecondName string } // struct creation func NewPerson ( firstName string , secondName string ) Person { return Person { FirstName : firstName , SecondName : secondName } } type CInt struct { value int } // struct creation func NewCInt ( num int ) CInt { return CInt { value : num } } //link Person and CInt to CompositeType func ( p Person ) isComposite () bool { return true } func ( c CInt ) isComposite () bool { return true } func cType ( c CompositeType ) { switch c .( type ) { case Person : //cast to actual tyupe fmt . Printf ( \"\\nPerson %v\" , c .( Person ). FirstName ) case CInt : //cast to actual tyupe fmt . Printf ( \"\\nNumber %v\" , c .( CInt ). value ) } } func main () { p1 := NewPerson ( \"John\" , \"Doe\" ) c1 := NewCInt ( 12 ) //int needs to be enveloped in CInt cType ( p1 ) cType ( c1 ) } Nim import strformat type Person = ref object firstName : string secondName : string type CompositeKind = enum cPerson , cInt Composite = ref object case kind : CompositeKind of cInt : value : int of cPerson : person : Person proc cType ( c : Composite ) = if c . kind == cPerson : echo & \"Person {c.person.firstName}\" if c . kind == cInt : echo & \"Number {c.value}\" let p1 = Person ( firstName : \"John\" , secondName : \"Doe\" ) let cp1 = Composite ( kind : cPerson , person : p1 ) let cnum = Composite ( kind : cInt , value : 12 ) cType ( cp1 ) cType ( cnum ) Python from dataclasses import dataclass from typing import Union @dataclass class Person : first_name : str = \"John\" second_name : str = \"Doe\" Composite = Union [ Person , int ] def c_type ( c : Composite ): if type ( c ) == int : print ( f \"Number {c} \" ) elif isinstance ( c , Person ): print ( f \"Person {c.first_name} \" ) p1 = Person () c_type ( p1 ) c_type ( 12 ) Rust pub enum Composite { Person ( Person ), CInt ( i32 ) } pub struct Person { pub first_name : String , pub second_name : String , } pub fn c_type ( c : Composite ) { match c { Composite :: Person ( p ) => println ! ( \"Person {}\" , p . first_name ) , Composite :: CInt ( c ) => println ! ( \"Number {}\" , c ), } } fn main () { let p1 = Person { first_name : \"John\" . to_string (), second_name : \"Doe\" . to_string (), }; //all types must be enveloped in the containing enum c_type ( Composite :: Person ( p1 )); c_type ( Composite :: CInt ( 12 )); } Sing requires \"sio\" ; interface IComposite { fn isComposite () bool ; } class Person : IComposite { public : var firstName string ; var secondName string ; } public fn Person . isComposite () bool { return ( true ); } class CInt : IComposite { public : var value i32 ; } public fn CInt . isComposite () bool { return ( true ); } public fn singmain ( argv [ * ] string ) i32 { var p1 Person ; var c1 CInt ; p1 . firstName = \"John\" ; c1 . value = 12 ; c_type ( p1 ); c_type ( c1 ); return ( 0 ); } fn c_type ( item IComposite ) void { typeswitch ( ref = item ) { case Person : { sio . print ( \" \\n\\r Person \" + ref . firstName ); } case CInt : { sio . print ( \" \\n\\r CInt \" + string ( ref . value )); } default : { sio . print ( \" \\n\\r Unrecognized type\" ); } } } TypeScript class Person { firstName : string ; secondName : string ; constructor ( fname : string = \"John\" , sname : string = \"Doe\" ) { this . firstName = fname ; this . secondName = sname ; } } type Composite = number | Person ; function cType ( c : Composite ) { if ( c instanceof Person ) { // non primitive type, needs casting var person = ( c as Person ); //tsc gives error here but generated js works console . log ( `Person ${ person . firstName } ` ); } else if ( typeof ( c ) == \"number\" ) { console . log ( `Number ${ c } ` ); } } let p1 = new Person (); cType ( p1 ); cType ( 12 ); V (vlang) struct Person { first_name string second_name string } struct CInt { value int } type CompositeType = Person | CInt fn main () { p1 := Person { \"John\" , \"Doe\" } c1 := CInt { 12 } c_type ( p1 ) c_type ( c1 ) } fn c_type ( c CompositeType ) { match c { Person { println ( \"Person: $c.first_name\" ) } CInt { println ( \"Number: $c.value\" ) } } }","title":"Union"},{"location":"Union/#union","text":"","title":"Union"},{"location":"Union/#c","text":"using System ; using System.Collections.Generic ; public interface IComposite { bool isComposite (); } class Person : IComposite { public string firstName ; public string secondName ; //constructor with default arguments public Person ( string fname = \"John\" , string sname = \"Doe\" ) { firstName = fname ; secondName = sname ; } bool IComposite . isComposite () { return true ; } } public class CInt : IComposite { bool IComposite . isComposite () { return true ; } public int value ; public CInt ( int num ) { value = num ; } } public class Program { public static void Main ( string [] args ) { var p1 = new Person (); var c1 = new CInt ( 12 ); cType ( p1 ); cType ( c1 ); //int needs to be enveloped in CInt } public static void cType ( IComposite c ) { if ( c is Person cp ) { Console . Write ( \"Person {0}\\n\" , cp . firstName ); } else if ( c is CInt ci ) { Console . Write ( \"Number {0}\\n\" , ci . value ); } } }","title":"C#"},{"location":"Union/#dart","text":"// interface to represent union class IComposite { bool isComposite () { return true ;} } class Person implements IComposite { String firstName ; String secondName ; Person ([ this . firstName = \"John\" , this . secondName = \"Doe\" ]); bool isComposite () { return true ; } } class CInt implements IComposite { int value ; CInt ( this . value ); bool isComposite () { return true ; } } main ( List < String > args ) { var p1 = Person (); cType ( p1 ); cType ( CInt ( 12 )); //int needs to be enveloped in CInt } cType ( IComposite c ) { if ( c is CInt ) { //cast to the actual type var c1 = c as CInt ; var value = c1 . value ; print ( \"Number $ value \" ); } else if ( c is Person ) { //cast to the actual type var p1 = c as Person ; var name = p1 . firstName ; print ( \"Person $ name \" ); } }","title":"Dart"},{"location":"Union/#go","text":"package main import ( \"fmt\" ) type CompositeType interface { isComposite () bool } type Person struct { FirstName string SecondName string } // struct creation func NewPerson ( firstName string , secondName string ) Person { return Person { FirstName : firstName , SecondName : secondName } } type CInt struct { value int } // struct creation func NewCInt ( num int ) CInt { return CInt { value : num } } //link Person and CInt to CompositeType func ( p Person ) isComposite () bool { return true } func ( c CInt ) isComposite () bool { return true } func cType ( c CompositeType ) { switch c .( type ) { case Person : //cast to actual tyupe fmt . Printf ( \"\\nPerson %v\" , c .( Person ). FirstName ) case CInt : //cast to actual tyupe fmt . Printf ( \"\\nNumber %v\" , c .( CInt ). value ) } } func main () { p1 := NewPerson ( \"John\" , \"Doe\" ) c1 := NewCInt ( 12 ) //int needs to be enveloped in CInt cType ( p1 ) cType ( c1 ) }","title":"Go"},{"location":"Union/#nim","text":"import strformat type Person = ref object firstName : string secondName : string type CompositeKind = enum cPerson , cInt Composite = ref object case kind : CompositeKind of cInt : value : int of cPerson : person : Person proc cType ( c : Composite ) = if c . kind == cPerson : echo & \"Person {c.person.firstName}\" if c . kind == cInt : echo & \"Number {c.value}\" let p1 = Person ( firstName : \"John\" , secondName : \"Doe\" ) let cp1 = Composite ( kind : cPerson , person : p1 ) let cnum = Composite ( kind : cInt , value : 12 ) cType ( cp1 ) cType ( cnum )","title":"Nim"},{"location":"Union/#python","text":"from dataclasses import dataclass from typing import Union @dataclass class Person : first_name : str = \"John\" second_name : str = \"Doe\" Composite = Union [ Person , int ] def c_type ( c : Composite ): if type ( c ) == int : print ( f \"Number {c} \" ) elif isinstance ( c , Person ): print ( f \"Person {c.first_name} \" ) p1 = Person () c_type ( p1 ) c_type ( 12 )","title":"Python"},{"location":"Union/#rust","text":"pub enum Composite { Person ( Person ), CInt ( i32 ) } pub struct Person { pub first_name : String , pub second_name : String , } pub fn c_type ( c : Composite ) { match c { Composite :: Person ( p ) => println ! ( \"Person {}\" , p . first_name ) , Composite :: CInt ( c ) => println ! ( \"Number {}\" , c ), } } fn main () { let p1 = Person { first_name : \"John\" . to_string (), second_name : \"Doe\" . to_string (), }; //all types must be enveloped in the containing enum c_type ( Composite :: Person ( p1 )); c_type ( Composite :: CInt ( 12 )); }","title":"Rust"},{"location":"Union/#sing","text":"requires \"sio\" ; interface IComposite { fn isComposite () bool ; } class Person : IComposite { public : var firstName string ; var secondName string ; } public fn Person . isComposite () bool { return ( true ); } class CInt : IComposite { public : var value i32 ; } public fn CInt . isComposite () bool { return ( true ); } public fn singmain ( argv [ * ] string ) i32 { var p1 Person ; var c1 CInt ; p1 . firstName = \"John\" ; c1 . value = 12 ; c_type ( p1 ); c_type ( c1 ); return ( 0 ); } fn c_type ( item IComposite ) void { typeswitch ( ref = item ) { case Person : { sio . print ( \" \\n\\r Person \" + ref . firstName ); } case CInt : { sio . print ( \" \\n\\r CInt \" + string ( ref . value )); } default : { sio . print ( \" \\n\\r Unrecognized type\" ); } } }","title":"Sing"},{"location":"Union/#typescript","text":"class Person { firstName : string ; secondName : string ; constructor ( fname : string = \"John\" , sname : string = \"Doe\" ) { this . firstName = fname ; this . secondName = sname ; } } type Composite = number | Person ; function cType ( c : Composite ) { if ( c instanceof Person ) { // non primitive type, needs casting var person = ( c as Person ); //tsc gives error here but generated js works console . log ( `Person ${ person . firstName } ` ); } else if ( typeof ( c ) == \"number\" ) { console . log ( `Number ${ c } ` ); } } let p1 = new Person (); cType ( p1 ); cType ( 12 );","title":"TypeScript"},{"location":"Union/#v-vlang","text":"struct Person { first_name string second_name string } struct CInt { value int } type CompositeType = Person | CInt fn main () { p1 := Person { \"John\" , \"Doe\" } c1 := CInt { 12 } c_type ( p1 ) c_type ( c1 ) } fn c_type ( c CompositeType ) { match c { Person { println ( \"Person: $c.first_name\" ) } CInt { println ( \"Number: $c.value\" ) } } }","title":"V (vlang)"},{"location":"VideoCapture/","text":"Video Capture Flutter //dependencies: // camera: ^0.5.7+3 import 'package:flutter/material.dart' ; import 'package:camera/camera.dart' ; import 'dart:async' ; List < CameraDescription > cameras ; double sbHeight = 0 ; //status bar heigth Future < void > main () async { // Ensure that plugin services are initialized so that `availableCameras()` // can be called before `runApp()` WidgetsFlutterBinding . ensureInitialized (); cameras = await availableCameras (); runApp ( MyApp ()); } class MyApp extends StatefulWidget { @override _CameraAppState createState () => _CameraAppState (); } class _CameraAppState extends State < MyApp > { CameraController _controller ; Future < void > _initializeControllerFuture ; //var _imageBytes; static const double WIDTH = 224 ; static const double HEIGHT = 224 ; static const double SB_HEIGHT = 10 ; //? MediaQuery seems to return 0 @override void initState () { super . initState (); // To display the current output from the camera, // create a CameraController. _controller = CameraController ( // Get a specific camera from the list of available cameras. cameras [ 0 ], // Define the resolution to use. ResolutionPreset . medium , ); // Next, initialize the controller. This returns a Future. _initializeControllerFuture = _controller . initialize (); } @override void dispose () { _controller ? . dispose (); super . dispose (); } @override Widget build ( BuildContext context ) { var appBar = AppBar ( title: Text ( 'Cam - draw' ) ); return MaterialApp ( debugShowCheckedModeBanner: false , home: Scaffold ( appBar: appBar , body: FutureBuilder < void > ( future: _initializeControllerFuture , builder: ( context , snapshot ) { if ( snapshot . connectionState == ConnectionState . done ) { // If the Future is complete, display the preview. _controller . startImageStream (( CameraImage img ) { //_imageBytes = img.planes[0].bytes; }); var _abHeight = appBar . preferredSize . height ; var _height = MediaQuery . of ( context ). size . height ; var _width = MediaQuery . of ( context ). size . width ; return Container ( margin: EdgeInsets . only ( top: 10 ), child: Stack ( alignment: Alignment . centerRight , children: < Widget > [ OverflowBox ( maxHeight: WIDTH , maxWidth: HEIGHT , child: CameraPreview ( _controller ), ), //Draw a box at 0, 0 relative to the image Positioned ( left: ( _width - WIDTH ) / 2 + 0 , top: ( _height - HEIGHT ) / 2 - ( _abHeight - SB_HEIGHT ) + 0 , width: 20 , height: 30 , child: Container ( padding: EdgeInsets . only ( top: 5.0 , left: 5.0 ), decoration: BoxDecoration ( border: Border . all ( color: Color . fromRGBO ( 255 , 0 , 0 , 1.0 ), width: 3.0 , ), ), ), ), ], )); } else { // Otherwise, display a loading indicator. return Center ( child: CircularProgressIndicator ()); } }, ), ), ); } } Python #pip install opencv-python import cv2 WINDOW_NAME = 'image' WIDTH = 200 HEIGHT = 200 def on_click ( event , x , y , flags , param ): global click_exit if event == cv2 . EVENT_LBUTTONDOWN : click_exit = True cap = cv2 . VideoCapture ( 0 ) cv2 . namedWindow ( WINDOW_NAME , cv2 . WINDOW_NORMAL ) cv2 . resizeWindow ( WINDOW_NAME , WIDTH , HEIGHT ) cv2 . setMouseCallback ( WINDOW_NAME , on_click ) while True : global click_exit click_exit = False ret , frame = cap . read () cv2 . imshow ( WINDOW_NAME , frame ) ch = cv2 . waitKey ( 10 ) if ch != - 1 or click_exit : break ; cap . release () cv2 . destroyAllWindows () Rust //compile in release for good performance //stream video with simple shapes overlay //[dependencies] //camera_capture = \"0.5.0\" //minifb = \"0.15.3\" //image = \"0.22.4\" //imageproc = \"0.19.2\" use image :: { imageops , DynamicImage , ImageBuffer , Rgb , RgbImage }; use minifb :: { Key , Window , WindowOptions }; use imageproc :: drawing :: { draw_line_segment_mut , draw_hollow_rect_mut }; use imageproc :: rect :: { Rect }; const WIDTH : usize = 200 ; const HEIGHT : usize = 200 ; fn main () { let cam = camera_capture :: create ( 0 ). expect ( \"Camera create error\" ); //let mut cam_iter = cam.fps(0.5).unwrap().start().unwrap(); let mut cam_iter = cam . start (). unwrap (); let mut window = Window :: new ( \"image, click or press ESC to exit\" , WIDTH , HEIGHT , WindowOptions { .. WindowOptions :: default () }, ) . expect ( \"Error opening window\" ); while window . is_open () && ! window . is_key_down ( Key :: Escape ) { let img = cam_iter . next (). unwrap (); let ( width , height ) = img . dimensions (); //Resize to WIDTH, HEIGHT -> a DynamicImage is needed let img_r = RgbImage :: from_vec ( width , height , img . to_vec ()). unwrap (); let img_d = DynamicImage :: ImageRgb8 ( img_r ); let img_d_resized = img_d . resize_exact ( WIDTH as u32 , HEIGHT as u32 , imageops :: Nearest ); //To draw pixels, an ImageBuffer is needed back let mut img_g_resized = ImageBuffer :: from_raw ( WIDTH as u32 , HEIGHT as u32 , img_d_resized . raw_pixels ()). unwrap (); draw_line_segment_mut ( & mut img_g_resized , ( 10.0 , 10.0 ), ( 50.0 , 50.0 ), Rgb ([ 0 , 255 , 0 ])); draw_hollow_rect_mut ( & mut img_g_resized , Rect :: at ( 100 , 100 ). of_size ( 20 , 30 ), Rgb ([ 255 , 0 , 0 ])); // let u32_buffer : Vec < u32 > = img_g_resized . chunks ( 3 ) . map ( | v | (( v [ 0 ] as u32 ) << 16 ) | (( v [ 1 ] as u32 ) << 8 ) | v [ 2 ] as u32 ) . collect (); window . update_with_buffer ( & u32_buffer , WIDTH , HEIGHT ) . expect ( \"Error on update\" ); } }","title":"Video Capture"},{"location":"VideoCapture/#video-capture","text":"","title":"Video Capture"},{"location":"VideoCapture/#flutter","text":"//dependencies: // camera: ^0.5.7+3 import 'package:flutter/material.dart' ; import 'package:camera/camera.dart' ; import 'dart:async' ; List < CameraDescription > cameras ; double sbHeight = 0 ; //status bar heigth Future < void > main () async { // Ensure that plugin services are initialized so that `availableCameras()` // can be called before `runApp()` WidgetsFlutterBinding . ensureInitialized (); cameras = await availableCameras (); runApp ( MyApp ()); } class MyApp extends StatefulWidget { @override _CameraAppState createState () => _CameraAppState (); } class _CameraAppState extends State < MyApp > { CameraController _controller ; Future < void > _initializeControllerFuture ; //var _imageBytes; static const double WIDTH = 224 ; static const double HEIGHT = 224 ; static const double SB_HEIGHT = 10 ; //? MediaQuery seems to return 0 @override void initState () { super . initState (); // To display the current output from the camera, // create a CameraController. _controller = CameraController ( // Get a specific camera from the list of available cameras. cameras [ 0 ], // Define the resolution to use. ResolutionPreset . medium , ); // Next, initialize the controller. This returns a Future. _initializeControllerFuture = _controller . initialize (); } @override void dispose () { _controller ? . dispose (); super . dispose (); } @override Widget build ( BuildContext context ) { var appBar = AppBar ( title: Text ( 'Cam - draw' ) ); return MaterialApp ( debugShowCheckedModeBanner: false , home: Scaffold ( appBar: appBar , body: FutureBuilder < void > ( future: _initializeControllerFuture , builder: ( context , snapshot ) { if ( snapshot . connectionState == ConnectionState . done ) { // If the Future is complete, display the preview. _controller . startImageStream (( CameraImage img ) { //_imageBytes = img.planes[0].bytes; }); var _abHeight = appBar . preferredSize . height ; var _height = MediaQuery . of ( context ). size . height ; var _width = MediaQuery . of ( context ). size . width ; return Container ( margin: EdgeInsets . only ( top: 10 ), child: Stack ( alignment: Alignment . centerRight , children: < Widget > [ OverflowBox ( maxHeight: WIDTH , maxWidth: HEIGHT , child: CameraPreview ( _controller ), ), //Draw a box at 0, 0 relative to the image Positioned ( left: ( _width - WIDTH ) / 2 + 0 , top: ( _height - HEIGHT ) / 2 - ( _abHeight - SB_HEIGHT ) + 0 , width: 20 , height: 30 , child: Container ( padding: EdgeInsets . only ( top: 5.0 , left: 5.0 ), decoration: BoxDecoration ( border: Border . all ( color: Color . fromRGBO ( 255 , 0 , 0 , 1.0 ), width: 3.0 , ), ), ), ), ], )); } else { // Otherwise, display a loading indicator. return Center ( child: CircularProgressIndicator ()); } }, ), ), ); } }","title":"Flutter"},{"location":"VideoCapture/#python","text":"#pip install opencv-python import cv2 WINDOW_NAME = 'image' WIDTH = 200 HEIGHT = 200 def on_click ( event , x , y , flags , param ): global click_exit if event == cv2 . EVENT_LBUTTONDOWN : click_exit = True cap = cv2 . VideoCapture ( 0 ) cv2 . namedWindow ( WINDOW_NAME , cv2 . WINDOW_NORMAL ) cv2 . resizeWindow ( WINDOW_NAME , WIDTH , HEIGHT ) cv2 . setMouseCallback ( WINDOW_NAME , on_click ) while True : global click_exit click_exit = False ret , frame = cap . read () cv2 . imshow ( WINDOW_NAME , frame ) ch = cv2 . waitKey ( 10 ) if ch != - 1 or click_exit : break ; cap . release () cv2 . destroyAllWindows ()","title":"Python"},{"location":"VideoCapture/#rust","text":"//compile in release for good performance //stream video with simple shapes overlay //[dependencies] //camera_capture = \"0.5.0\" //minifb = \"0.15.3\" //image = \"0.22.4\" //imageproc = \"0.19.2\" use image :: { imageops , DynamicImage , ImageBuffer , Rgb , RgbImage }; use minifb :: { Key , Window , WindowOptions }; use imageproc :: drawing :: { draw_line_segment_mut , draw_hollow_rect_mut }; use imageproc :: rect :: { Rect }; const WIDTH : usize = 200 ; const HEIGHT : usize = 200 ; fn main () { let cam = camera_capture :: create ( 0 ). expect ( \"Camera create error\" ); //let mut cam_iter = cam.fps(0.5).unwrap().start().unwrap(); let mut cam_iter = cam . start (). unwrap (); let mut window = Window :: new ( \"image, click or press ESC to exit\" , WIDTH , HEIGHT , WindowOptions { .. WindowOptions :: default () }, ) . expect ( \"Error opening window\" ); while window . is_open () && ! window . is_key_down ( Key :: Escape ) { let img = cam_iter . next (). unwrap (); let ( width , height ) = img . dimensions (); //Resize to WIDTH, HEIGHT -> a DynamicImage is needed let img_r = RgbImage :: from_vec ( width , height , img . to_vec ()). unwrap (); let img_d = DynamicImage :: ImageRgb8 ( img_r ); let img_d_resized = img_d . resize_exact ( WIDTH as u32 , HEIGHT as u32 , imageops :: Nearest ); //To draw pixels, an ImageBuffer is needed back let mut img_g_resized = ImageBuffer :: from_raw ( WIDTH as u32 , HEIGHT as u32 , img_d_resized . raw_pixels ()). unwrap (); draw_line_segment_mut ( & mut img_g_resized , ( 10.0 , 10.0 ), ( 50.0 , 50.0 ), Rgb ([ 0 , 255 , 0 ])); draw_hollow_rect_mut ( & mut img_g_resized , Rect :: at ( 100 , 100 ). of_size ( 20 , 30 ), Rgb ([ 255 , 0 , 0 ])); // let u32_buffer : Vec < u32 > = img_g_resized . chunks ( 3 ) . map ( | v | (( v [ 0 ] as u32 ) << 16 ) | (( v [ 1 ] as u32 ) << 8 ) | v [ 2 ] as u32 ) . collect (); window . update_with_buffer ( & u32_buffer , WIDTH , HEIGHT ) . expect ( \"Error on update\" ); } }","title":"Rust"},{"location":"Write%20%26%20Read%20lines/","text":"Write & Read Lines C# using System ; using System.IO ; public class Program { public static void Main ( string [] args ) { var fileName = \"tmp01.txt\" ; using ( var f = File . CreateText ( fileName )) { f . WriteLine ( \"This is\\n\\na text\\nfile\" ); } try { using ( var f = File . OpenText ( fileName )) { string s ; while (( s = f . ReadLine ()) != null ) { Console . WriteLine ( s ); } } } catch { Console . WriteLine ( \"Could not find {0}\" , fileName ); } } } Dart import 'dart:io' ; import 'dart:convert' ; main () async { var fileName = \"tmp01.txt\" ; var f = File ( fileName ); var sink = f . openWrite (); sink . write ( \"This is \\n\\n a text \\n file\" ); sink . close (); var fRead = File ( fileName ); Stream < List < int >> inputStream = fRead . openRead (); var lines = utf8 . decoder . bind ( inputStream ). transform ( LineSplitter ()); try { await for ( var line in lines ) { print ( ' $ line ' ); } } catch ( e ) { print ( \"Cannot find $ fileName \" ); } } Go package main import ( \"bufio\" \"fmt\" \"os\" ) func main () { fileName := \"tmp01.txt\" file , err := os . Create ( fileName ) if err != nil { fmt . Printf ( \"Can't create %s\\n\" , fileName ) os . Exit ( 0 ) } toWrite := [] byte ( \"This is\\n\\na text\\nfile\" ) file . Write ( toWrite ) file . Close () file , err = os . Open ( fileName ) if err != nil { fmt . Printf ( \"Can't open %s\\n\" , fileName ) os . Exit ( 0 ) } defer file . Close () scanner := bufio . NewScanner ( file ) for scanner . Scan () { fmt . Println ( scanner . Text ()) } if err := scanner . Err (); err != nil { fmt . Println ( \"Reading error: \" , err ) } } Nim import streams let fileName = \"tmp01.txt\" var strm = newFileStream ( fileName , fmWrite ) strm . write ( \"This is \\n\\n a text \\n file\" ) strm . close () let strmRead = newFileStream ( fileName , fmRead ) var line = \"\" if not isNil ( strmRead ): while strmRead . readLine ( line ): echo line strmRead . close () Python import os import sys file_name = \"tmp01.txt\" try : with open ( file_name , \"w\" ) as file : file . write ( \"This is \\n\\n a text \\n file\" ) except : print ( f \"Error writing {file_name} \" ) try : with open ( file_name , \"r\" ) as file : for line in file : print ( line , end = '' ) except : print ( f \"Error reading {file_name} \" ) Rust use std :: fs :: File ; use std :: io :: prelude :: * ; //without this, no write use std :: io :: BufRead ; use std :: io :: BufReader ; fn main () { let file_name = \"tmp01.txt\" ; let mut f = File :: create ( file_name ) . expect ( & format ! ( \"Cannot create {}\" , file_name )); f . write ( \"This is \\n\\n a text \\n file\" . as_bytes ()) . expect ( & format ! ( \"Cannot write to {}\" , file_name )); let f = File :: open ( file_name ) . expect ( & format ! ( \"File {} not found\" , file_name )); let file = BufReader :: new ( & f ); for line in file . lines () { let str1 : String = match line { Ok ( str1 ) => str1 . to_ascii_lowercase (), Err ( _ ) => { String :: new () //return empty string } }; println ! ( \"{}\" , & str1 ); } } V (vlang) import os fn main () { file_name := \"tmp0.txt\" mut f1 := os . create ( file_name ) or { panic ( \"cannot create $file_name\" )} to_write := ( \"This is\\n\\na text\\nfile\" ). bytes () f1 . write ( to_write ) or { panic ( \"cannot write $file_name\" )} f1 . close () lines := os . read_lines ( file_name ) or { panic ( \"cannot read $file_name\" )} println ( '$ lines ' ) }","title":"Write & Read Lines"},{"location":"Write%20%26%20Read%20lines/#write-read-lines","text":"","title":"Write &amp; Read Lines"},{"location":"Write%20%26%20Read%20lines/#c","text":"using System ; using System.IO ; public class Program { public static void Main ( string [] args ) { var fileName = \"tmp01.txt\" ; using ( var f = File . CreateText ( fileName )) { f . WriteLine ( \"This is\\n\\na text\\nfile\" ); } try { using ( var f = File . OpenText ( fileName )) { string s ; while (( s = f . ReadLine ()) != null ) { Console . WriteLine ( s ); } } } catch { Console . WriteLine ( \"Could not find {0}\" , fileName ); } } }","title":"C#"},{"location":"Write%20%26%20Read%20lines/#dart","text":"import 'dart:io' ; import 'dart:convert' ; main () async { var fileName = \"tmp01.txt\" ; var f = File ( fileName ); var sink = f . openWrite (); sink . write ( \"This is \\n\\n a text \\n file\" ); sink . close (); var fRead = File ( fileName ); Stream < List < int >> inputStream = fRead . openRead (); var lines = utf8 . decoder . bind ( inputStream ). transform ( LineSplitter ()); try { await for ( var line in lines ) { print ( ' $ line ' ); } } catch ( e ) { print ( \"Cannot find $ fileName \" ); } }","title":"Dart"},{"location":"Write%20%26%20Read%20lines/#go","text":"package main import ( \"bufio\" \"fmt\" \"os\" ) func main () { fileName := \"tmp01.txt\" file , err := os . Create ( fileName ) if err != nil { fmt . Printf ( \"Can't create %s\\n\" , fileName ) os . Exit ( 0 ) } toWrite := [] byte ( \"This is\\n\\na text\\nfile\" ) file . Write ( toWrite ) file . Close () file , err = os . Open ( fileName ) if err != nil { fmt . Printf ( \"Can't open %s\\n\" , fileName ) os . Exit ( 0 ) } defer file . Close () scanner := bufio . NewScanner ( file ) for scanner . Scan () { fmt . Println ( scanner . Text ()) } if err := scanner . Err (); err != nil { fmt . Println ( \"Reading error: \" , err ) } }","title":"Go"},{"location":"Write%20%26%20Read%20lines/#nim","text":"import streams let fileName = \"tmp01.txt\" var strm = newFileStream ( fileName , fmWrite ) strm . write ( \"This is \\n\\n a text \\n file\" ) strm . close () let strmRead = newFileStream ( fileName , fmRead ) var line = \"\" if not isNil ( strmRead ): while strmRead . readLine ( line ): echo line strmRead . close ()","title":"Nim"},{"location":"Write%20%26%20Read%20lines/#python","text":"import os import sys file_name = \"tmp01.txt\" try : with open ( file_name , \"w\" ) as file : file . write ( \"This is \\n\\n a text \\n file\" ) except : print ( f \"Error writing {file_name} \" ) try : with open ( file_name , \"r\" ) as file : for line in file : print ( line , end = '' ) except : print ( f \"Error reading {file_name} \" )","title":"Python"},{"location":"Write%20%26%20Read%20lines/#rust","text":"use std :: fs :: File ; use std :: io :: prelude :: * ; //without this, no write use std :: io :: BufRead ; use std :: io :: BufReader ; fn main () { let file_name = \"tmp01.txt\" ; let mut f = File :: create ( file_name ) . expect ( & format ! ( \"Cannot create {}\" , file_name )); f . write ( \"This is \\n\\n a text \\n file\" . as_bytes ()) . expect ( & format ! ( \"Cannot write to {}\" , file_name )); let f = File :: open ( file_name ) . expect ( & format ! ( \"File {} not found\" , file_name )); let file = BufReader :: new ( & f ); for line in file . lines () { let str1 : String = match line { Ok ( str1 ) => str1 . to_ascii_lowercase (), Err ( _ ) => { String :: new () //return empty string } }; println ! ( \"{}\" , & str1 ); } }","title":"Rust"},{"location":"Write%20%26%20Read%20lines/#v-vlang","text":"import os fn main () { file_name := \"tmp0.txt\" mut f1 := os . create ( file_name ) or { panic ( \"cannot create $file_name\" )} to_write := ( \"This is\\n\\na text\\nfile\" ). bytes () f1 . write ( to_write ) or { panic ( \"cannot write $file_name\" )} f1 . close () lines := os . read_lines ( file_name ) or { panic ( \"cannot read $file_name\" )} println ( '$ lines ' ) }","title":"V (vlang)"}]}