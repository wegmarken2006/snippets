{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Runnable Snippets Tested on 64-bit Windows","title":"Home"},{"location":"#runnable-snippets","text":"Tested on 64-bit Windows","title":"Runnable Snippets"},{"location":"Dict/","text":"Dictionary C# using System ; using System.Collections.Generic ; using System.Linq ; public class Program { public static void Main ( string [] args ) { //count words var wordList = new List < string > { \"glass\" , \"table\" , \"chair\" , \"chair\" }; var words = new Dictionary < string , int >(); foreach ( var item in wordList ) { if ( words . ContainsKey ( item )) { words [ item ] = ( int ) words [ item ] + 1 ; } else { words . Add ( item , 1 ); } } Console . WriteLine (); foreach ( var item in words ) { Console . Write ( \"{0}:{1} \" , item . Key , item . Value ); } Console . WriteLine (); var sorted = words . OrderBy ( x => - x . Value ); foreach ( var item in sorted ) { Console . Write ( \"{0}:{1} \" , item . Key , item . Value ); } } } Dart import 'dart:collection' ; main ( List < String > arguments ) { //count words var wordList = [ \"glass\" , \"table\" , \"chair\" , \"chair\" ]; var words = Map (); for ( var item in wordList ) { if ( words . containsKey ( item )) { words [ item ] += 1 ; } else { words [ item ] = 1 ; } } print ( ' $ words ' ); //sort values descending order var sorted = sortMap ( words ); print ( ' $ sorted ' ); } LinkedHashMap sortMap ( Map map ) { var mapk = map . keys . toList (); //sort keys according to values descending order mapk . sort (( k1 , k2 ) => map [ k2 ]. compareTo ( map [ k1 ])); var outMap = LinkedHashMap . fromIterable ( mapk , key: ( k ) => k , value: ( k ) => map [ k ]); return ( outMap ); } Go package main import ( \"fmt\" \"sort\" ) func main () { //count words wordList := [] string { \"glass\" , \"table\" , \"chair\" , \"chair\" } words := make ( map [ string ] int ) for _ , item := range wordList { words [ item ] ++ } fmt . Printf ( \"\\n%v\" , words ) //sort by descending value fmt . Printf ( \"\\n%v\" , mapSort ( words )) } func mapSort ( mapIn map [ string ] int ) keyValList { //dict to slice mapS := keyValList {} for k , v := range mapIn { mapS = append ( mapS , keyVal { k , v }) } sort . Sort ( sort . Reverse ( mapS )) return mapS } type keyVal struct { key string val int } type keyValList [] keyVal func ( p keyValList ) Len () int { return len ( p ) } func ( p keyValList ) Less ( i , j int ) bool { return p [ i ]. val < p [ j ]. val } func ( p keyValList ) Swap ( i , j int ){ p [ i ], p [ j ] = p [ j ], p [ i ] } Nim import tables import algorithm as al # count words var wordList = @[ \"glass\" , \"table\" , \"chair\" , \"chair\" ] var words = initOrderedTable [ string , int ] () for item in wordList : if words . hasKey ( item ): words [ item ] += 1 else : words . add ( item , 1 ) echo words # sort by descending value words . sort ( proc ( x , y : ( string , int )): int = x [ 1 ] - y [ 1 ] , order = al . SortOrder . Descending ) echo words Python from typing import Dict , List , Tuple from operator import itemgetter # count words word_list : List [ str ] = [ \"glass\" , \"table\" , \"chair\" , \"chair\" ] words : Dict [ str , int ] = {} for item in word_list : try : words [ item ] += 1 except : words [ item ] = 1 print ( words ) # sort by descending value words_l : List [ Tuple [ str , int ]] = list ( words . items ()) words_l = sorted ( words_l , reverse = True , key = itemgetter ( 1 )) print ( words_l ) Rust use std :: collections :: HashMap ; use std :: cmp :: Reverse ; fn main () { //count words let word_list = vec ! [ \"glass\" , \"table\" , \"chair\" , \"chair\" ]; let mut words : HashMap < String , usize > = HashMap :: new (); for item in word_list { let count = words . entry (( * item ). to_string ()). or_insert ( 0 ); * count += 1 ; } //get specific key value let value = words . get ( \"chair\" ). expect ( \"no key\" ); println ! ( \"{:?} {:?}\" , & words , value ); //sort by descending value let mut words_v : Vec < _ > = words . iter (). collect (); words_v . sort_by_key ( |& ( word , count ) | ( Reverse ( count ), word )); println ! ( \"{:?}\" , & words_v ); }","title":"Dictionary"},{"location":"Dict/#dictionary","text":"","title":"Dictionary"},{"location":"Dict/#c35","text":"using System ; using System.Collections.Generic ; using System.Linq ; public class Program { public static void Main ( string [] args ) { //count words var wordList = new List < string > { \"glass\" , \"table\" , \"chair\" , \"chair\" }; var words = new Dictionary < string , int >(); foreach ( var item in wordList ) { if ( words . ContainsKey ( item )) { words [ item ] = ( int ) words [ item ] + 1 ; } else { words . Add ( item , 1 ); } } Console . WriteLine (); foreach ( var item in words ) { Console . Write ( \"{0}:{1} \" , item . Key , item . Value ); } Console . WriteLine (); var sorted = words . OrderBy ( x => - x . Value ); foreach ( var item in sorted ) { Console . Write ( \"{0}:{1} \" , item . Key , item . Value ); } } }","title":"C#"},{"location":"Dict/#dart","text":"import 'dart:collection' ; main ( List < String > arguments ) { //count words var wordList = [ \"glass\" , \"table\" , \"chair\" , \"chair\" ]; var words = Map (); for ( var item in wordList ) { if ( words . containsKey ( item )) { words [ item ] += 1 ; } else { words [ item ] = 1 ; } } print ( ' $ words ' ); //sort values descending order var sorted = sortMap ( words ); print ( ' $ sorted ' ); } LinkedHashMap sortMap ( Map map ) { var mapk = map . keys . toList (); //sort keys according to values descending order mapk . sort (( k1 , k2 ) => map [ k2 ]. compareTo ( map [ k1 ])); var outMap = LinkedHashMap . fromIterable ( mapk , key: ( k ) => k , value: ( k ) => map [ k ]); return ( outMap ); }","title":"Dart"},{"location":"Dict/#go","text":"package main import ( \"fmt\" \"sort\" ) func main () { //count words wordList := [] string { \"glass\" , \"table\" , \"chair\" , \"chair\" } words := make ( map [ string ] int ) for _ , item := range wordList { words [ item ] ++ } fmt . Printf ( \"\\n%v\" , words ) //sort by descending value fmt . Printf ( \"\\n%v\" , mapSort ( words )) } func mapSort ( mapIn map [ string ] int ) keyValList { //dict to slice mapS := keyValList {} for k , v := range mapIn { mapS = append ( mapS , keyVal { k , v }) } sort . Sort ( sort . Reverse ( mapS )) return mapS } type keyVal struct { key string val int } type keyValList [] keyVal func ( p keyValList ) Len () int { return len ( p ) } func ( p keyValList ) Less ( i , j int ) bool { return p [ i ]. val < p [ j ]. val } func ( p keyValList ) Swap ( i , j int ){ p [ i ], p [ j ] = p [ j ], p [ i ] }","title":"Go"},{"location":"Dict/#nim","text":"import tables import algorithm as al # count words var wordList = @[ \"glass\" , \"table\" , \"chair\" , \"chair\" ] var words = initOrderedTable [ string , int ] () for item in wordList : if words . hasKey ( item ): words [ item ] += 1 else : words . add ( item , 1 ) echo words # sort by descending value words . sort ( proc ( x , y : ( string , int )): int = x [ 1 ] - y [ 1 ] , order = al . SortOrder . Descending ) echo words","title":"Nim"},{"location":"Dict/#python","text":"from typing import Dict , List , Tuple from operator import itemgetter # count words word_list : List [ str ] = [ \"glass\" , \"table\" , \"chair\" , \"chair\" ] words : Dict [ str , int ] = {} for item in word_list : try : words [ item ] += 1 except : words [ item ] = 1 print ( words ) # sort by descending value words_l : List [ Tuple [ str , int ]] = list ( words . items ()) words_l = sorted ( words_l , reverse = True , key = itemgetter ( 1 )) print ( words_l )","title":"Python"},{"location":"Dict/#rust","text":"use std :: collections :: HashMap ; use std :: cmp :: Reverse ; fn main () { //count words let word_list = vec ! [ \"glass\" , \"table\" , \"chair\" , \"chair\" ]; let mut words : HashMap < String , usize > = HashMap :: new (); for item in word_list { let count = words . entry (( * item ). to_string ()). or_insert ( 0 ); * count += 1 ; } //get specific key value let value = words . get ( \"chair\" ). expect ( \"no key\" ); println ! ( \"{:?} {:?}\" , & words , value ); //sort by descending value let mut words_v : Vec < _ > = words . iter (). collect (); words_v . sort_by_key ( |& ( word , count ) | ( Reverse ( count ), word )); println ! ( \"{:?}\" , & words_v ); }","title":"Rust"},{"location":"Execution time/","text":"Execution time C# using System ; using System.Collections.Generic ; using System.Diagnostics ; using System.Linq ; public class Program { public static void Main ( string [] args ) { var timer = Stopwatch . StartNew (); //START MEASURE var perfects = classifyPerfects ( 20001 ); timer . Stop (); //END MEASURE Console . WriteLine ( \"Perfects: {0}\" , perfects . Count ); foreach ( var item in perfects ) { Console . Write ( \"{0} \" , item ); } Console . WriteLine ( \"\\nElapsed: {0}ms\" , timer . ElapsedMilliseconds ); } public static List < int > classifyPerfects ( int num ) { var perfects = new List < int >(); for ( int n = 1 ; n < num ; n ++) { var divisors = findProperDivisor ( n ); var sum = divisors . Sum (); if ( sum == n ) { perfects . Add ( n ); } } return perfects ; } public static List < int > findProperDivisor ( int n ) { var divisors = new List < int >(); for ( int i = 1 ; i < ( n / 2 ) + 1 ; i ++) { if ( n % i == 0 ) { divisors . Add ( i ); } } return divisors ; } } Dart main ( List < String > arguments ) { var stopwatch = Stopwatch (); stopwatch . start (); //START MEASURE var perfects = classifyPerfect ( 20001 ); stopwatch . stop (); //END MEASURE var elapsed = stopwatch . elapsedMilliseconds ; print ( ' $ perfects ' ); print ( 'Elapsed: $ elapsed ms' ); } List < int > classifyPerfect ( int nnum ) { var perfects = List < int > (); for ( var n = 1 ; n < nnum ; n ++ ) { var divisors = findProperDivisor ( n ); var sum = 0 ; if ( divisors . isNotEmpty ) { sum = divisors . fold ( 0 , ( a , b ) => a + b ); } if ( sum == n ) { perfects . add ( n ); } } return perfects ; } List < int > findProperDivisor ( int n ) { var divisors = List < int > (); var endloop = n ~/ 2 + 1 ; for ( var i = 1 ; i < endloop ; i ++ ) { if ( n % i == 0 ) { divisors . add ( i ); } } return divisors ; } Go package main import ( \"fmt\" \"time\" ) func main () { start := time . Now () //START MEASURE perfects := classifyPerfect ( 20001 ) duration := time . Since ( start ) //END MEASURE fmt . Printf ( \"\\n%v\" , perfects ) fmt . Printf ( \"\\nElapsed: %v\" , duration ) } func classifyPerfect ( nnum int ) [] int { perfects := [] int {} for n := 1 ; n < nnum ; n ++ { divisors := findProperDivisor ( n ) sum := 0 for i := 0 ; i < len ( divisors ); i ++ { sum += divisors [ i ] } if sum == n { perfects = append ( perfects , n ) } } return perfects } func findProperDivisor ( n int ) [] int { divisors := [] int {} endloop := int ( n / 2 ) + 1 for i := 1 ; i < endloop ; i ++ { if n % i == 0 { divisors = append ( divisors , i ) } } return divisors } Nim # compile with: nim c -d:release <filename> import times as ts import sequtils as sq proc findProperDivisors ( n : int32 ): seq [ int32 ] = var divisors : seq [ int32 ] let endloop : int32 = int32 ( n / 2 ) for i in 1 .. endloop : if ( n mod i ) == 0 : divisors . add ( i ) divisors proc classifyPerfects ( num : int32 ): seq [ int32 ] = var perfects : seq [ int32 ] for n in 1 .. num : let divisors = findProperDivisors ( n ) var sumd = 0 if divisors . len > 0 : sumd = divisors . foldl ( a + b ) if sumd == n : perfects . add ( n ) perfects var start = ts . getTime () # START MEASURE var perfects = classifyPerfects ( 20001 ) var endt = ts . getTime () # END MEASURE echo perfects . len echo perfects echo endt - start Python import time from typing import List def find_proper_divisors ( n : int ) -> List [ int ]: divisors : List [ int ] = [] for i in range ( 1 , int (( n / 2 ) + 1 )): if n % i == 0 : divisors += [ i ] return divisors def classify_perfects ( num : int ) -> List [ int ]: perfects : List [ int ] = [] for n in range ( 1 , num ): divisors = find_proper_divisors ( n ) sumd = sum ( divisors ) if sumd == n : perfects += [ n ] return perfects start_time : float = time . time () # START MEASURE perfects = classify_perfects ( 20001 ) end_time : float = time . time () # END MEASURE print ( f \"Perfects: {len(perfects)}\" ) for item in perfects : print ( f \"{item}\" ) print ( f \"Elapsed: {((end_time - start_time)*1000)} ms\" ) Rust use std :: time :: { Instant }; fn main () { let now = Instant :: now (); //START MEASURE let perfects = classify_perfect ( 20001 ); let new_now = Instant :: now (); //END MEASURE //Output println ! ( \"Perfects: {:?}\" , perfects . len ()); println ! ( \"{:?}\" , perfects ); println ! ( \"Elapsed: {:?}\" , new_now . duration_since ( now )); } fn classify_perfect ( num : i32 ) -> Vec < i32 > { let mut perfects = vec ! []; for n in 1 .. num { let divisors = find_proper_divisors ( n ); let sum : i32 = divisors . iter (). sum (); if sum == n { perfects . push ( n ); } } perfects } fn find_proper_divisors ( n : i32 ) -> Vec < i32 > { let mut divisors = vec ! []; for i in 1 ..(( n / 2 ) + 1 ) { if n % i == 0 { divisors . push ( i ); } } return divisors ; }","title":"Execution time"},{"location":"Execution time/#execution-time","text":"","title":"Execution time"},{"location":"Execution time/#c35","text":"using System ; using System.Collections.Generic ; using System.Diagnostics ; using System.Linq ; public class Program { public static void Main ( string [] args ) { var timer = Stopwatch . StartNew (); //START MEASURE var perfects = classifyPerfects ( 20001 ); timer . Stop (); //END MEASURE Console . WriteLine ( \"Perfects: {0}\" , perfects . Count ); foreach ( var item in perfects ) { Console . Write ( \"{0} \" , item ); } Console . WriteLine ( \"\\nElapsed: {0}ms\" , timer . ElapsedMilliseconds ); } public static List < int > classifyPerfects ( int num ) { var perfects = new List < int >(); for ( int n = 1 ; n < num ; n ++) { var divisors = findProperDivisor ( n ); var sum = divisors . Sum (); if ( sum == n ) { perfects . Add ( n ); } } return perfects ; } public static List < int > findProperDivisor ( int n ) { var divisors = new List < int >(); for ( int i = 1 ; i < ( n / 2 ) + 1 ; i ++) { if ( n % i == 0 ) { divisors . Add ( i ); } } return divisors ; } }","title":"C#"},{"location":"Execution time/#dart","text":"main ( List < String > arguments ) { var stopwatch = Stopwatch (); stopwatch . start (); //START MEASURE var perfects = classifyPerfect ( 20001 ); stopwatch . stop (); //END MEASURE var elapsed = stopwatch . elapsedMilliseconds ; print ( ' $ perfects ' ); print ( 'Elapsed: $ elapsed ms' ); } List < int > classifyPerfect ( int nnum ) { var perfects = List < int > (); for ( var n = 1 ; n < nnum ; n ++ ) { var divisors = findProperDivisor ( n ); var sum = 0 ; if ( divisors . isNotEmpty ) { sum = divisors . fold ( 0 , ( a , b ) => a + b ); } if ( sum == n ) { perfects . add ( n ); } } return perfects ; } List < int > findProperDivisor ( int n ) { var divisors = List < int > (); var endloop = n ~/ 2 + 1 ; for ( var i = 1 ; i < endloop ; i ++ ) { if ( n % i == 0 ) { divisors . add ( i ); } } return divisors ; }","title":"Dart"},{"location":"Execution time/#go","text":"package main import ( \"fmt\" \"time\" ) func main () { start := time . Now () //START MEASURE perfects := classifyPerfect ( 20001 ) duration := time . Since ( start ) //END MEASURE fmt . Printf ( \"\\n%v\" , perfects ) fmt . Printf ( \"\\nElapsed: %v\" , duration ) } func classifyPerfect ( nnum int ) [] int { perfects := [] int {} for n := 1 ; n < nnum ; n ++ { divisors := findProperDivisor ( n ) sum := 0 for i := 0 ; i < len ( divisors ); i ++ { sum += divisors [ i ] } if sum == n { perfects = append ( perfects , n ) } } return perfects } func findProperDivisor ( n int ) [] int { divisors := [] int {} endloop := int ( n / 2 ) + 1 for i := 1 ; i < endloop ; i ++ { if n % i == 0 { divisors = append ( divisors , i ) } } return divisors }","title":"Go"},{"location":"Execution time/#nim","text":"# compile with: nim c -d:release <filename> import times as ts import sequtils as sq proc findProperDivisors ( n : int32 ): seq [ int32 ] = var divisors : seq [ int32 ] let endloop : int32 = int32 ( n / 2 ) for i in 1 .. endloop : if ( n mod i ) == 0 : divisors . add ( i ) divisors proc classifyPerfects ( num : int32 ): seq [ int32 ] = var perfects : seq [ int32 ] for n in 1 .. num : let divisors = findProperDivisors ( n ) var sumd = 0 if divisors . len > 0 : sumd = divisors . foldl ( a + b ) if sumd == n : perfects . add ( n ) perfects var start = ts . getTime () # START MEASURE var perfects = classifyPerfects ( 20001 ) var endt = ts . getTime () # END MEASURE echo perfects . len echo perfects echo endt - start","title":"Nim"},{"location":"Execution time/#python","text":"import time from typing import List def find_proper_divisors ( n : int ) -> List [ int ]: divisors : List [ int ] = [] for i in range ( 1 , int (( n / 2 ) + 1 )): if n % i == 0 : divisors += [ i ] return divisors def classify_perfects ( num : int ) -> List [ int ]: perfects : List [ int ] = [] for n in range ( 1 , num ): divisors = find_proper_divisors ( n ) sumd = sum ( divisors ) if sumd == n : perfects += [ n ] return perfects start_time : float = time . time () # START MEASURE perfects = classify_perfects ( 20001 ) end_time : float = time . time () # END MEASURE print ( f \"Perfects: {len(perfects)}\" ) for item in perfects : print ( f \"{item}\" ) print ( f \"Elapsed: {((end_time - start_time)*1000)} ms\" )","title":"Python"},{"location":"Execution time/#rust","text":"use std :: time :: { Instant }; fn main () { let now = Instant :: now (); //START MEASURE let perfects = classify_perfect ( 20001 ); let new_now = Instant :: now (); //END MEASURE //Output println ! ( \"Perfects: {:?}\" , perfects . len ()); println ! ( \"{:?}\" , perfects ); println ! ( \"Elapsed: {:?}\" , new_now . duration_since ( now )); } fn classify_perfect ( num : i32 ) -> Vec < i32 > { let mut perfects = vec ! []; for n in 1 .. num { let divisors = find_proper_divisors ( n ); let sum : i32 = divisors . iter (). sum (); if sum == n { perfects . push ( n ); } } perfects } fn find_proper_divisors ( n : i32 ) -> Vec < i32 > { let mut divisors = vec ! []; for i in 1 ..(( n / 2 ) + 1 ) { if n % i == 0 { divisors . push ( i ); } } return divisors ; }","title":"Rust"},{"location":"List/","text":"List C# using System ; using System.Collections.Generic ; public class Program { public static void Main ( string [] args ) { //new empty list var lst1 = new List < string >(); //new initialized list var lst2 = new List < string > { \"str20\" , \"str21\" }; //append element lst1 . Add ( \"str10\" ); //append list lst1 . AddRange ( lst2 ); //add head element lst1 . Insert ( 0 , \"str00\" ); //reverse lst1 . Reverse (); //sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] //list length var lst3 = lst1 . GetRange ( 1 , lst1 . Count - 1 ); Console . WriteLine (); foreach ( var item in lst3 ) { Console . Write ( \"{0} \" , item ); } //map and filter var lst4 = lst1 . Select (( x ) => x . ToUpper ()); var lst5 = lst4 . Where (( x ) => x != \"STR00\" ); Console . WriteLine (); foreach ( var item in lst5 ) { Console . Write ( \"{0} \" , item ); } } } Dart main ( List < String > arguments ) { // new empty list var lst1 = List < String > (); //new initialized list var lst2 = [ \"str20\" , \"str21\" ]; // append element lst1 . add ( \"str10\" ); // append list lst1 = lst1 + lst2 ; // add head element lst1 = [ \"str00\" ] + lst1 ; //reverse lst1 = lst1 . reversed . toList (); // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] // list length var lst3 = lst1 . sublist ( 1 , lst1 . length ); print ( ' $ lst3 ' ); // map and filter var lst4 = lst3 . map (( x ) => x . toUpperCase ()); var lst5 = lst4 . where (( x ) => x != \"STR00\" ); print ( ' $ lst5 ' ); } Go package main import ( \"fmt\" \"sort\" \"strings\" ) func main () { //new empty list lst1 := stringList {} //new initialized list lst2 := stringList { \"str20\" , \"str21\" } //append element lst1 = append ( lst1 , \"str10\" ) //append list lst1 = append ( lst1 , lst2 ... ) //add head element lst1 = append ([] string { \"str00\" }, lst1 ... ) //reverse sort . Sort ( sort . Reverse ( lst1 )) //sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] //list length lst3 := lst1 [ 1 : len ( lst1 )] fmt . Printf ( \"\\n%v\" , lst3 ) //map and filter lst4 := stringList {} for _ , elem := range lst1 { lst4 = append ( lst4 , strings . ToUpper ( elem )) } lst5 := stringList {} for _ , elem := range lst4 { if elem != \"STR00\" { lst5 = append ( lst5 , elem ) } } fmt . Printf ( \"\\n%v\" , lst5 ) } type stringList [] string func ( p stringList ) Len () int { return len ( p ) } func ( p stringList ) Less ( i , j int ) bool { return p [ i ] < p [ j ] } func ( p stringList ) Swap ( i , j int ) { p [ i ], p [ j ] = p [ j ], p [ i ] } Nim import sequtils as sq import algorithm as al import strutils as st # new empty list var lst1 : seq [ string ] = @[] # new initialized list var lst2 = @[ \"str20\" , \"str21\" ] # append element lst1 . add ( \"str10\" ) #append list lst1 = sq . concat ( lst1 , lst2 ) # add head element lst1 = sq . concat ( @[ \"str00\" ] , lst1 ) # reverse lst1 = al . reversed ( lst1 ) # sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] # list length var lst3 = lst1 [ 1 .. len ( lst1 ) - 1 ] echo lst3 # map and filter var lst4 = map ( lst3 , proc ( x : string ): string = st . toUpper ( x )) var lst5 = filter ( lst4 , proc ( x : string ): bool = x != \"STR00\" ) echo lst5 Python from typing import List # new empty list lst1 : List [ str ] = [] # new initialized list lst2 : List [ str ] = [ \"str20\" , \"str21\" ] # append element lst1 = lst1 + [ \"str10\" ] # append list lst1 = lst1 + lst2 # add head element lst1 = [ \"str00\" ] + lst1 # reverse lst1 . reverse () # sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] # list length lst3 : List [ str ] = lst1 [ 1 : len ( lst1 )] print ( lst3 ) # map and filter lst4 : List [ str ] = [ elem for elem in map ( lambda x : x . upper (), lst1 )] lst5 = [ elem for elem in filter ( lambda x : x != \"STR00\" , lst4 )] print ( lst5 ) Rust fn main () { // new empty list let mut lst1 : Vec <& str > = vec ! []; //new initialized list let lst2 = vec ! [ \"str20\" , \"str21\" ]; // append element lst1 . push ( \"str10\" ); // append list lst1 . extend ( lst2 ); // add head element lst1 . insert ( 0 , \"str00\" ); //reverse lst1 . reverse (); // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] // list length let lst3 : Vec <& str > = lst1 [ 1 .. lst1 . len ()]. to_vec (); println ! ( \"{:?}\" , & lst3 ); // map and filter let lst4 : Vec < _ > = lst3 . into_iter (). map ( | x | x . to_uppercase ()). collect (); let lst5 : Vec < _ > = lst4 . into_iter (). filter ( | x | * x != \"STR00\" ). collect (); println ! ( \"{:?}\" , & lst5 ); }","title":"List"},{"location":"List/#list","text":"","title":"List"},{"location":"List/#c35","text":"using System ; using System.Collections.Generic ; public class Program { public static void Main ( string [] args ) { //new empty list var lst1 = new List < string >(); //new initialized list var lst2 = new List < string > { \"str20\" , \"str21\" }; //append element lst1 . Add ( \"str10\" ); //append list lst1 . AddRange ( lst2 ); //add head element lst1 . Insert ( 0 , \"str00\" ); //reverse lst1 . Reverse (); //sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] //list length var lst3 = lst1 . GetRange ( 1 , lst1 . Count - 1 ); Console . WriteLine (); foreach ( var item in lst3 ) { Console . Write ( \"{0} \" , item ); } //map and filter var lst4 = lst1 . Select (( x ) => x . ToUpper ()); var lst5 = lst4 . Where (( x ) => x != \"STR00\" ); Console . WriteLine (); foreach ( var item in lst5 ) { Console . Write ( \"{0} \" , item ); } } }","title":"C#"},{"location":"List/#dart","text":"main ( List < String > arguments ) { // new empty list var lst1 = List < String > (); //new initialized list var lst2 = [ \"str20\" , \"str21\" ]; // append element lst1 . add ( \"str10\" ); // append list lst1 = lst1 + lst2 ; // add head element lst1 = [ \"str00\" ] + lst1 ; //reverse lst1 = lst1 . reversed . toList (); // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] // list length var lst3 = lst1 . sublist ( 1 , lst1 . length ); print ( ' $ lst3 ' ); // map and filter var lst4 = lst3 . map (( x ) => x . toUpperCase ()); var lst5 = lst4 . where (( x ) => x != \"STR00\" ); print ( ' $ lst5 ' ); }","title":"Dart"},{"location":"List/#go","text":"package main import ( \"fmt\" \"sort\" \"strings\" ) func main () { //new empty list lst1 := stringList {} //new initialized list lst2 := stringList { \"str20\" , \"str21\" } //append element lst1 = append ( lst1 , \"str10\" ) //append list lst1 = append ( lst1 , lst2 ... ) //add head element lst1 = append ([] string { \"str00\" }, lst1 ... ) //reverse sort . Sort ( sort . Reverse ( lst1 )) //sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] //list length lst3 := lst1 [ 1 : len ( lst1 )] fmt . Printf ( \"\\n%v\" , lst3 ) //map and filter lst4 := stringList {} for _ , elem := range lst1 { lst4 = append ( lst4 , strings . ToUpper ( elem )) } lst5 := stringList {} for _ , elem := range lst4 { if elem != \"STR00\" { lst5 = append ( lst5 , elem ) } } fmt . Printf ( \"\\n%v\" , lst5 ) } type stringList [] string func ( p stringList ) Len () int { return len ( p ) } func ( p stringList ) Less ( i , j int ) bool { return p [ i ] < p [ j ] } func ( p stringList ) Swap ( i , j int ) { p [ i ], p [ j ] = p [ j ], p [ i ] }","title":"Go"},{"location":"List/#nim","text":"import sequtils as sq import algorithm as al import strutils as st # new empty list var lst1 : seq [ string ] = @[] # new initialized list var lst2 = @[ \"str20\" , \"str21\" ] # append element lst1 . add ( \"str10\" ) #append list lst1 = sq . concat ( lst1 , lst2 ) # add head element lst1 = sq . concat ( @[ \"str00\" ] , lst1 ) # reverse lst1 = al . reversed ( lst1 ) # sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] # list length var lst3 = lst1 [ 1 .. len ( lst1 ) - 1 ] echo lst3 # map and filter var lst4 = map ( lst3 , proc ( x : string ): string = st . toUpper ( x )) var lst5 = filter ( lst4 , proc ( x : string ): bool = x != \"STR00\" ) echo lst5","title":"Nim"},{"location":"List/#python","text":"from typing import List # new empty list lst1 : List [ str ] = [] # new initialized list lst2 : List [ str ] = [ \"str20\" , \"str21\" ] # append element lst1 = lst1 + [ \"str10\" ] # append list lst1 = lst1 + lst2 # add head element lst1 = [ \"str00\" ] + lst1 # reverse lst1 . reverse () # sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] # list length lst3 : List [ str ] = lst1 [ 1 : len ( lst1 )] print ( lst3 ) # map and filter lst4 : List [ str ] = [ elem for elem in map ( lambda x : x . upper (), lst1 )] lst5 = [ elem for elem in filter ( lambda x : x != \"STR00\" , lst4 )] print ( lst5 )","title":"Python"},{"location":"List/#rust","text":"fn main () { // new empty list let mut lst1 : Vec <& str > = vec ! []; //new initialized list let lst2 = vec ! [ \"str20\" , \"str21\" ]; // append element lst1 . push ( \"str10\" ); // append list lst1 . extend ( lst2 ); // add head element lst1 . insert ( 0 , \"str00\" ); //reverse lst1 . reverse (); // sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] // list length let lst3 : Vec <& str > = lst1 [ 1 .. lst1 . len ()]. to_vec (); println ! ( \"{:?}\" , & lst3 ); // map and filter let lst4 : Vec < _ > = lst3 . into_iter (). map ( | x | x . to_uppercase ()). collect (); let lst5 : Vec < _ > = lst4 . into_iter (). filter ( | x | * x != \"STR00\" ). collect (); println ! ( \"{:?}\" , & lst5 ); }","title":"Rust"},{"location":"Playground links/","text":"Playground links C# .NET Fiddle Tio C# (.NET Core) Dart DatPad Tio Dart Go Go Playground Tio Go Nim Nim Playground Tio Nim Python Tio Python3 Rust Rust Playground Tio Rust","title":"Playground links"},{"location":"Playground links/#playground-links","text":"","title":"Playground links"},{"location":"Playground links/#c35","text":".NET Fiddle Tio C# (.NET Core)","title":"C#"},{"location":"Playground links/#dart","text":"DatPad Tio Dart","title":"Dart"},{"location":"Playground links/#go","text":"Go Playground Tio Go","title":"Go"},{"location":"Playground links/#nim","text":"Nim Playground Tio Nim","title":"Nim"},{"location":"Playground links/#python","text":"Tio Python3","title":"Python"},{"location":"Playground links/#rust","text":"Rust Playground Tio Rust","title":"Rust"},{"location":"Scaffold with CLI/","text":"Scaffold with CLI C# dotnet new console -o hello cd hello dotnet run Dart pub global activate stagehand mkdir hello cd hello stagehand console-full pub get dart bin/main.dart Rust cargo new hello -- bin cd hello cargo run","title":"Scaffold with CLI"},{"location":"Scaffold with CLI/#scaffold-with-cli","text":"","title":"Scaffold with CLI"},{"location":"Scaffold with CLI/#c35","text":"dotnet new console -o hello cd hello dotnet run","title":"C#"},{"location":"Scaffold with CLI/#dart","text":"pub global activate stagehand mkdir hello cd hello stagehand console-full pub get dart bin/main.dart","title":"Dart"},{"location":"Scaffold with CLI/#rust","text":"cargo new hello -- bin cd hello cargo run","title":"Rust"},{"location":"Structure or Class/","text":"Structure or Class Dart //file moda.dart -> package moda class Person { String firstName ; String secondName ; //Default/Optional parameters between [] Person ([ this . firstName = \"John\" , this . secondName = \"Doe\" ]) ; } class Customer { Person person ; //starting underscore: not visible outside package double _balance ; Customer ( this . person , [ this . _balance = 0.0 ]); void addToBalance ( double sum ) { this . _balance += sum ; } double getBalance () { return this . _balance ; } } import 'moda.dart' ; main ( List < String > args ) { var p1 = Person ( \"Mark\" ); var c1 = Customer ( p1 ); c1 . person = p1 ; //Method c1 . addToBalance ( 100.0 ); c1 . addToBalance ( 10.0 ); //Property var name = c1 . person . firstName ; var balance = c1 . getBalance (); print ( \"New $ name balance: $ balance \" ); } Go //file src/moda/moda.go -> package moda package moda // all public identifier must start with Uppercase type Person struct { FirstName string SecondName string } type Customer struct { Person Person balance float64 //lowercase because private } // struct creation with optional parameters func NewPerson ( args ... string ) Person { firstName := \"John\" secondName := \"Doe\" if len ( args ) > 0 { firstName = args [ 0 ] } if len ( args ) > 1 { secondName = args [ 1 ] } return Person { FirstName : firstName , SecondName : secondName } } // struct creation func NewCustomer ( person Person ) Customer { return Customer { Person : person , balance : 0.0 } } // public methods for Customer func ( customer * Customer ) AddToBalance ( sum float64 ) { customer . balance += sum } func ( customer * Customer ) GetBalance () float64 { return customer . balance } package main import ( \"fmt\" \"moda\" ) func main () { p1 := moda . NewPerson ( \"Mark\" ) c1 := moda . NewCustomer ( p1 ) //method c1 . AddToBalance ( 100.0 ) c1 . AddToBalance ( 10.0 ) balance := c1 . GetBalance () //property fmt . Printf ( \"\\nNew %v balance: %v\" , c1 . Person . FirstName , balance ) } Nim # file moda.nim -> module moda type Person * = ref object # asterisk for public firstName : string secondName : string # getter proc firstName * ( person : Person ): string = person . firstName proc newPerson * ( fName : string = \"John\" , sName : string = \"Doe\" ): Person = Person ( firstName : fName , secondName : sName ) type Customer * = ref object person : Person balance : float64 # getter proc person * ( customer : Customer ): Person = customer . person # getter proc balance * ( customer : Customer ): float64 = customer . balance proc newCustomer * ( p : Person , b : float64 = 0.0 ): Customer = Customer ( person : p , balance : b ) # method proc addToBalance * ( c : Customer , sum : float64 ) = c . balance = c . balance + sum import moda import strformat as sf let p1 : Person = moda . newPerson ( \"Mark\" ) #use default for secondName var c1 = moda . newCustomer ( p1 ) #use default for balance # method c1 . addToBalance ( 100.0 ) c1 . addToBalance ( 10.0 ) # property, reading only through getter echo sf . fmt\"New {c1.person.first_name} balance: {c1.balance}\" Python from dataclasses import dataclass @dataclass class Person : first_name : str = \"John\" second_name : str = \"Doe\" @dataclass class Customer : person : Person # double initial underscore for private __balance : float = 0.0 def add_to_balance ( self , num : float ): self . __balance += num def get_balance ( self ) -> float : return self . __balance p1 = Person ( \"Mark\" ) # use default for second_name c1 = Customer ( p1 ) #use default for balance # method c1 . add_to_balance ( 100.0 ) c1 . add_to_balance ( 10.0 ) new_balance = c1 . get_balance () # property print ( f \" New {c1.person.first_name} balance: {new_balance}\" ) Rust //private fields/methods are not visible outside the module mod mod1 { #[derive(Debug)] pub struct Person { pub first_name : String , pub second_name : String , } #[derive(Debug)] pub struct Customer { pub person : Person , balance : f64 , } //default accessible outside only if fields are all public impl Default for Person { fn default () -> Self { Person { first_name : \"John\" . to_string (), second_name : \"Doe\" . to_string (), } } } impl Customer { pub fn new () -> Self { Customer { person : Person {.. Person :: default ()}, balance : 0.0 } } pub fn add_to_balance ( & mut self , sum : f64 ) { self . balance += sum ; } pub fn get_balance ( & self ) -> f64 { self . balance } } } use mod1 :: * ; fn main () { let mut c1 = Customer :: new (); //use person and balance default c1 . person . first_name = \"Mark\" . to_string (); //change first_name println ! ( \"{:?}\" , & c1 ); //Method c1 . add_to_balance ( 100.0 ); c1 . add_to_balance ( 10.0 ); //Property println ! ( \"New {} balance: {} \" , & c1 . person . first_name , c1 . get_balance ()); }","title":"Structure or Class"},{"location":"Structure or Class/#structure-or-class","text":"","title":"Structure or Class"},{"location":"Structure or Class/#dart","text":"//file moda.dart -> package moda class Person { String firstName ; String secondName ; //Default/Optional parameters between [] Person ([ this . firstName = \"John\" , this . secondName = \"Doe\" ]) ; } class Customer { Person person ; //starting underscore: not visible outside package double _balance ; Customer ( this . person , [ this . _balance = 0.0 ]); void addToBalance ( double sum ) { this . _balance += sum ; } double getBalance () { return this . _balance ; } } import 'moda.dart' ; main ( List < String > args ) { var p1 = Person ( \"Mark\" ); var c1 = Customer ( p1 ); c1 . person = p1 ; //Method c1 . addToBalance ( 100.0 ); c1 . addToBalance ( 10.0 ); //Property var name = c1 . person . firstName ; var balance = c1 . getBalance (); print ( \"New $ name balance: $ balance \" ); }","title":"Dart"},{"location":"Structure or Class/#go","text":"//file src/moda/moda.go -> package moda package moda // all public identifier must start with Uppercase type Person struct { FirstName string SecondName string } type Customer struct { Person Person balance float64 //lowercase because private } // struct creation with optional parameters func NewPerson ( args ... string ) Person { firstName := \"John\" secondName := \"Doe\" if len ( args ) > 0 { firstName = args [ 0 ] } if len ( args ) > 1 { secondName = args [ 1 ] } return Person { FirstName : firstName , SecondName : secondName } } // struct creation func NewCustomer ( person Person ) Customer { return Customer { Person : person , balance : 0.0 } } // public methods for Customer func ( customer * Customer ) AddToBalance ( sum float64 ) { customer . balance += sum } func ( customer * Customer ) GetBalance () float64 { return customer . balance } package main import ( \"fmt\" \"moda\" ) func main () { p1 := moda . NewPerson ( \"Mark\" ) c1 := moda . NewCustomer ( p1 ) //method c1 . AddToBalance ( 100.0 ) c1 . AddToBalance ( 10.0 ) balance := c1 . GetBalance () //property fmt . Printf ( \"\\nNew %v balance: %v\" , c1 . Person . FirstName , balance ) }","title":"Go"},{"location":"Structure or Class/#nim","text":"# file moda.nim -> module moda type Person * = ref object # asterisk for public firstName : string secondName : string # getter proc firstName * ( person : Person ): string = person . firstName proc newPerson * ( fName : string = \"John\" , sName : string = \"Doe\" ): Person = Person ( firstName : fName , secondName : sName ) type Customer * = ref object person : Person balance : float64 # getter proc person * ( customer : Customer ): Person = customer . person # getter proc balance * ( customer : Customer ): float64 = customer . balance proc newCustomer * ( p : Person , b : float64 = 0.0 ): Customer = Customer ( person : p , balance : b ) # method proc addToBalance * ( c : Customer , sum : float64 ) = c . balance = c . balance + sum import moda import strformat as sf let p1 : Person = moda . newPerson ( \"Mark\" ) #use default for secondName var c1 = moda . newCustomer ( p1 ) #use default for balance # method c1 . addToBalance ( 100.0 ) c1 . addToBalance ( 10.0 ) # property, reading only through getter echo sf . fmt\"New {c1.person.first_name} balance: {c1.balance}\"","title":"Nim"},{"location":"Structure or Class/#python","text":"from dataclasses import dataclass @dataclass class Person : first_name : str = \"John\" second_name : str = \"Doe\" @dataclass class Customer : person : Person # double initial underscore for private __balance : float = 0.0 def add_to_balance ( self , num : float ): self . __balance += num def get_balance ( self ) -> float : return self . __balance p1 = Person ( \"Mark\" ) # use default for second_name c1 = Customer ( p1 ) #use default for balance # method c1 . add_to_balance ( 100.0 ) c1 . add_to_balance ( 10.0 ) new_balance = c1 . get_balance () # property print ( f \" New {c1.person.first_name} balance: {new_balance}\" )","title":"Python"},{"location":"Structure or Class/#rust","text":"//private fields/methods are not visible outside the module mod mod1 { #[derive(Debug)] pub struct Person { pub first_name : String , pub second_name : String , } #[derive(Debug)] pub struct Customer { pub person : Person , balance : f64 , } //default accessible outside only if fields are all public impl Default for Person { fn default () -> Self { Person { first_name : \"John\" . to_string (), second_name : \"Doe\" . to_string (), } } } impl Customer { pub fn new () -> Self { Customer { person : Person {.. Person :: default ()}, balance : 0.0 } } pub fn add_to_balance ( & mut self , sum : f64 ) { self . balance += sum ; } pub fn get_balance ( & self ) -> f64 { self . balance } } } use mod1 :: * ; fn main () { let mut c1 = Customer :: new (); //use person and balance default c1 . person . first_name = \"Mark\" . to_string (); //change first_name println ! ( \"{:?}\" , & c1 ); //Method c1 . add_to_balance ( 100.0 ); c1 . add_to_balance ( 10.0 ); //Property println ! ( \"New {} balance: {} \" , & c1 . person . first_name , c1 . get_balance ()); }","title":"Rust"},{"location":"System command/","text":"System command C# using System ; using System.Diagnostics ; public class Program { public static void Main ( string [] args ) { var psi = new ProcessStartInfo (); var process = new Process (); //(\"cargo\", \"version\"); psi . Arguments = \"--version\" ; psi . FileName = \"dotnet\" ; psi . RedirectStandardOutput = true ; psi . UseShellExecute = false ; process . StartInfo = psi ; process . Start (); while (! process . StandardOutput . EndOfStream ) { var line = process . StandardOutput . ReadLine (); Console . WriteLine ( line ); } } } Dart import \"dart:io\" ; main ( List < String > arguments ) { Process . run ( 'cargo' , [ 'version' ]). then (( ProcessResult result ) { print ( result . stdout ); }); } Go package main import ( \"fmt\" \"os/exec\" ) func main () { out , _ := exec . Command ( \"go\" , \"version\" ). Output () output := string ( out ) fmt . Printf ( \"\\n%s\" , output ) } Python import subprocess outp = subprocess . run ([ \"pip\" , \"--version\" ], capture_output = True , text = True ) print ( outp . stdout ) Rust use std :: process :: Command ; fn main () { let output = Command :: new ( \"cargo\" ) . args ( & [ \"version\" ]) . output () . expect ( \"failed to execute process\" ); println ! ( \"stdout: {}\" , String :: from_utf8_lossy ( & output . stdout )); }","title":"System command"},{"location":"System command/#system-command","text":"","title":"System command"},{"location":"System command/#c35","text":"using System ; using System.Diagnostics ; public class Program { public static void Main ( string [] args ) { var psi = new ProcessStartInfo (); var process = new Process (); //(\"cargo\", \"version\"); psi . Arguments = \"--version\" ; psi . FileName = \"dotnet\" ; psi . RedirectStandardOutput = true ; psi . UseShellExecute = false ; process . StartInfo = psi ; process . Start (); while (! process . StandardOutput . EndOfStream ) { var line = process . StandardOutput . ReadLine (); Console . WriteLine ( line ); } } }","title":"C#"},{"location":"System command/#dart","text":"import \"dart:io\" ; main ( List < String > arguments ) { Process . run ( 'cargo' , [ 'version' ]). then (( ProcessResult result ) { print ( result . stdout ); }); }","title":"Dart"},{"location":"System command/#go","text":"package main import ( \"fmt\" \"os/exec\" ) func main () { out , _ := exec . Command ( \"go\" , \"version\" ). Output () output := string ( out ) fmt . Printf ( \"\\n%s\" , output ) }","title":"Go"},{"location":"System command/#python","text":"import subprocess outp = subprocess . run ([ \"pip\" , \"--version\" ], capture_output = True , text = True ) print ( outp . stdout )","title":"Python"},{"location":"System command/#rust","text":"use std :: process :: Command ; fn main () { let output = Command :: new ( \"cargo\" ) . args ( & [ \"version\" ]) . output () . expect ( \"failed to execute process\" ); println ! ( \"stdout: {}\" , String :: from_utf8_lossy ( & output . stdout )); }","title":"Rust"},{"location":"Write & Read lines/","text":"Write & Read Lines C# using System ; using System.IO ; public class Program { public static void Main ( string [] args ) { var fileName = \"tmp01.txt\" ; using ( var f = File . CreateText ( fileName )) { f . WriteLine ( \"This is\\n\\na text\\nfile\" ); } try { using ( var f = File . OpenText ( fileName )) { string s ; while (( s = f . ReadLine ()) != null ) { Console . WriteLine ( s ); } } } catch { Console . WriteLine ( \"Could not find {0}\" , fileName ); } } } Dart import 'dart:io' ; import 'dart:convert' ; main () async { var fileName = \"tmp01.txt\" ; var f = File ( fileName ); var sink = f . openWrite (); sink . write ( \"This is \\n\\n a text \\n file\" ); await sink . close (); var fRead = File ( fileName ); Stream < List < int >> inputStream = fRead . openRead (); var lines = utf8 . decoder . bind ( inputStream ). transform ( LineSplitter ()); try { await for ( var line in lines ) { print ( ' $ line ' ); } } catch ( e ) { print ( \"Cannot find $ fileName \" ); } } Go package main import ( \"bufio\" \"fmt\" \"os\" ) func main () { fileName := \"tmp01.txt\" file , err := os . Create ( fileName ) if err != nil { fmt . Printf ( \"Can't create %s\\n\" , fileName ) os . Exit ( 0 ) } toWrite := [] byte ( \"This is\\n\\na text\\nfile\" ) file . Write ( toWrite ) file . Close () file , err = os . Open ( fileName ) if err != nil { fmt . Printf ( \"Can't open %s\\n\" , fileName ) os . Exit ( 0 ) } defer file . Close () scanner := bufio . NewScanner ( file ) for scanner . Scan () { fmt . Println ( scanner . Text ()) } if err := scanner . Err (); err != nil { fmt . Println ( \"Reading error: \" , err ) } } Nim import streams let fileName = \"tmp01.txt\" var strm = newFileStream ( fileName , fmWrite ) strm . write ( \"This is \\n\\n a text \\n file\" ) strm . close () let strmRead = newFileStream ( fileName , fmRead ) var line = \"\" if not isNil ( strmRead ): while strmRead . readLine ( line ): echo line strmRead . close () Python import os import sys file_name = \"tmp01.txt\" try : with open ( file_name , \"w\" ) as file : file . write ( \"This is \\n\\n a text \\n file\" ) except : print ( f \"Error writing {file_name}\" ) try : with open ( file_name , \"r\" ) as file : for line in file : print ( line , end = '' ) except : print ( f \"Error reading {file_name}\" ) Rust use std :: fs :: File ; use std :: io :: prelude :: * ; //without this, no write use std :: io :: BufRead ; use std :: io :: BufReader ; fn main () { let file_name = \"tmp01.txt\" ; let mut f = File :: create ( file_name ) . expect ( & format ! ( \"Cannot create {}\" , file_name )); f . write ( \"This is \\n\\n a text \\n file\" . as_bytes ()) . expect ( & format ! ( \"Cannot write to {}\" , file_name )); let f = File :: open ( file_name ) . expect ( & format ! ( \"File {} not found\" , file_name )); let file = BufReader :: new ( & f ); for line in file . lines () { let str1 : String = match line { Ok ( str1 ) => str1 . to_ascii_lowercase (), Err ( _ ) => { String :: new () //return empty string } }; println ! ( \"{}\" , & str1 ); } }","title":"Write & Read Lines"},{"location":"Write & Read lines/#write-read-lines","text":"","title":"Write &amp; Read Lines"},{"location":"Write & Read lines/#c35","text":"using System ; using System.IO ; public class Program { public static void Main ( string [] args ) { var fileName = \"tmp01.txt\" ; using ( var f = File . CreateText ( fileName )) { f . WriteLine ( \"This is\\n\\na text\\nfile\" ); } try { using ( var f = File . OpenText ( fileName )) { string s ; while (( s = f . ReadLine ()) != null ) { Console . WriteLine ( s ); } } } catch { Console . WriteLine ( \"Could not find {0}\" , fileName ); } } }","title":"C#"},{"location":"Write & Read lines/#dart","text":"import 'dart:io' ; import 'dart:convert' ; main () async { var fileName = \"tmp01.txt\" ; var f = File ( fileName ); var sink = f . openWrite (); sink . write ( \"This is \\n\\n a text \\n file\" ); await sink . close (); var fRead = File ( fileName ); Stream < List < int >> inputStream = fRead . openRead (); var lines = utf8 . decoder . bind ( inputStream ). transform ( LineSplitter ()); try { await for ( var line in lines ) { print ( ' $ line ' ); } } catch ( e ) { print ( \"Cannot find $ fileName \" ); } }","title":"Dart"},{"location":"Write & Read lines/#go","text":"package main import ( \"bufio\" \"fmt\" \"os\" ) func main () { fileName := \"tmp01.txt\" file , err := os . Create ( fileName ) if err != nil { fmt . Printf ( \"Can't create %s\\n\" , fileName ) os . Exit ( 0 ) } toWrite := [] byte ( \"This is\\n\\na text\\nfile\" ) file . Write ( toWrite ) file . Close () file , err = os . Open ( fileName ) if err != nil { fmt . Printf ( \"Can't open %s\\n\" , fileName ) os . Exit ( 0 ) } defer file . Close () scanner := bufio . NewScanner ( file ) for scanner . Scan () { fmt . Println ( scanner . Text ()) } if err := scanner . Err (); err != nil { fmt . Println ( \"Reading error: \" , err ) } }","title":"Go"},{"location":"Write & Read lines/#nim","text":"import streams let fileName = \"tmp01.txt\" var strm = newFileStream ( fileName , fmWrite ) strm . write ( \"This is \\n\\n a text \\n file\" ) strm . close () let strmRead = newFileStream ( fileName , fmRead ) var line = \"\" if not isNil ( strmRead ): while strmRead . readLine ( line ): echo line strmRead . close ()","title":"Nim"},{"location":"Write & Read lines/#python","text":"import os import sys file_name = \"tmp01.txt\" try : with open ( file_name , \"w\" ) as file : file . write ( \"This is \\n\\n a text \\n file\" ) except : print ( f \"Error writing {file_name}\" ) try : with open ( file_name , \"r\" ) as file : for line in file : print ( line , end = '' ) except : print ( f \"Error reading {file_name}\" )","title":"Python"},{"location":"Write & Read lines/#rust","text":"use std :: fs :: File ; use std :: io :: prelude :: * ; //without this, no write use std :: io :: BufRead ; use std :: io :: BufReader ; fn main () { let file_name = \"tmp01.txt\" ; let mut f = File :: create ( file_name ) . expect ( & format ! ( \"Cannot create {}\" , file_name )); f . write ( \"This is \\n\\n a text \\n file\" . as_bytes ()) . expect ( & format ! ( \"Cannot write to {}\" , file_name )); let f = File :: open ( file_name ) . expect ( & format ! ( \"File {} not found\" , file_name )); let file = BufReader :: new ( & f ); for line in file . lines () { let str1 : String = match line { Ok ( str1 ) => str1 . to_ascii_lowercase (), Err ( _ ) => { String :: new () //return empty string } }; println ! ( \"{}\" , & str1 ); } }","title":"Rust"}]}