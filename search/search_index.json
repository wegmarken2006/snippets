{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Snippets Tested on 64-bit Windows","title":"Home"},{"location":"#snippets","text":"Tested on 64-bit Windows","title":"Snippets"},{"location":"dictionary/","text":"C# using System ; using System.Collections.Generic ; using System.Linq ; public class Program { public static void Main ( string [] args ) { var wordList = new List < string > { \"glass\" , \"table\" , \"chair\" , \"table\" }; //var words = new Hashtable(); var words = new Dictionary < string , int >(); foreach ( var item in wordList ) { if ( words . ContainsKey ( item )) { words [ item ] = ( int ) words [ item ] + 1 ; } else { words . Add ( item , 1 ); } } Console . WriteLine (); foreach ( var item in words ) { Console . Write ( \"{0}:{1} \" , item . Key , item . Value ); } Console . WriteLine (); var sorted = words . OrderBy ( x => - x . Value ); foreach ( var item in sorted ) { Console . Write ( \"{0}:{1} \" , item . Key , item . Value ); } } } Dart import 'dart:collection' ; main ( List < String > arguments ) { var wordList = [ \"glass\" , \"table\" , \"chair\" , \"table\" ]; var words = Map (); for ( var item in wordList ) { if ( words . containsKey ( item )) { words [ item ] += 1 ; } else { words [ item ] = 1 ; } } print ( ' $ words ' ); //sort values descending order var sorted = sortMap ( words ); print ( ' $ sorted ' ); } LinkedHashMap sortMap ( Map map ) { var mapk = map . keys . toList (); //sort keys according to values descending order mapk . sort (( k1 , k2 ) => map [ k2 ]. compareTo ( map [ k1 ])); var outMap = LinkedHashMap . fromIterable ( mapk , key: ( k ) => k , value: ( k ) => map [ k ]); return ( outMap ); } Go package main import ( \"fmt\" \"sort\" ) func main () { wordList := [] string { \"table\" , \"chair\" , \"table\" , \"glass\" } words := make ( map [ string ] int ) for _ , item := range wordList { words [ item ] ++ } fmt . Printf ( \"\\n%v\" , words ) //sort by descending value fmt . Printf ( \"\\n%v\" , mapSort ( words )) } func mapSort ( mapIn map [ string ] int ) keyValList { //dict to slice mapS := keyValList {} for k , v := range mapIn { mapS = append ( mapS , keyVal { k , v }) } sort . Sort ( sort . Reverse ( mapS )) return mapS } type keyVal struct { key string val int } type keyValList [] keyVal func ( p keyValList ) Len () int { return len ( p ) } func ( p keyValList ) Less ( i , j int ) bool { return p [ i ]. val < p [ j ]. val } func ( p keyValList ) Swap ( i , j int ){ p [ i ], p [ j ] = p [ j ], p [ i ] } Python from typing import Dict , List , Tuple word_list : List [ str ] = [ \"table\" , \"chair\" , \"table\" , \"glass\" ] words : Dict [ str , int ] = {} for item in word_list : try : words [ item ] += 1 except : words [ item ] = 1 print ( words ) # sort by descending value words_l : List [ Tuple [ str , int ]] = list ( words . items ()) words_l . sort ( reverse = True ) print ( words_l ) Rust use std :: collections :: HashMap ; use std :: cmp :: Reverse ; fn main () { //count words let word_list = vec ! [ \"table\" , \"chair\" , \"table\" , \"glass\" ]; let mut words : HashMap < String , usize > = HashMap :: new (); for item in word_list { let count = words . entry (( * item ). to_string ()). or_insert ( 0 ); * count += 1 ; } //get specific key value let value = words . get ( \"chair\" ). expect ( \"no key\" ); println ! ( \"{:?} {:?}\" , & words , value ); //sort by descending value let mut words_v : Vec < _ > = words . iter (). collect (); words_v . sort_by_key ( |& ( word , count ) | ( Reverse ( count ), word )); println ! ( \"{:?}\" , & words_v ); }","title":"Dictionary"},{"location":"dictionary/#c35","text":"using System ; using System.Collections.Generic ; using System.Linq ; public class Program { public static void Main ( string [] args ) { var wordList = new List < string > { \"glass\" , \"table\" , \"chair\" , \"table\" }; //var words = new Hashtable(); var words = new Dictionary < string , int >(); foreach ( var item in wordList ) { if ( words . ContainsKey ( item )) { words [ item ] = ( int ) words [ item ] + 1 ; } else { words . Add ( item , 1 ); } } Console . WriteLine (); foreach ( var item in words ) { Console . Write ( \"{0}:{1} \" , item . Key , item . Value ); } Console . WriteLine (); var sorted = words . OrderBy ( x => - x . Value ); foreach ( var item in sorted ) { Console . Write ( \"{0}:{1} \" , item . Key , item . Value ); } } }","title":"C#"},{"location":"dictionary/#dart","text":"import 'dart:collection' ; main ( List < String > arguments ) { var wordList = [ \"glass\" , \"table\" , \"chair\" , \"table\" ]; var words = Map (); for ( var item in wordList ) { if ( words . containsKey ( item )) { words [ item ] += 1 ; } else { words [ item ] = 1 ; } } print ( ' $ words ' ); //sort values descending order var sorted = sortMap ( words ); print ( ' $ sorted ' ); } LinkedHashMap sortMap ( Map map ) { var mapk = map . keys . toList (); //sort keys according to values descending order mapk . sort (( k1 , k2 ) => map [ k2 ]. compareTo ( map [ k1 ])); var outMap = LinkedHashMap . fromIterable ( mapk , key: ( k ) => k , value: ( k ) => map [ k ]); return ( outMap ); }","title":"Dart"},{"location":"dictionary/#go","text":"package main import ( \"fmt\" \"sort\" ) func main () { wordList := [] string { \"table\" , \"chair\" , \"table\" , \"glass\" } words := make ( map [ string ] int ) for _ , item := range wordList { words [ item ] ++ } fmt . Printf ( \"\\n%v\" , words ) //sort by descending value fmt . Printf ( \"\\n%v\" , mapSort ( words )) } func mapSort ( mapIn map [ string ] int ) keyValList { //dict to slice mapS := keyValList {} for k , v := range mapIn { mapS = append ( mapS , keyVal { k , v }) } sort . Sort ( sort . Reverse ( mapS )) return mapS } type keyVal struct { key string val int } type keyValList [] keyVal func ( p keyValList ) Len () int { return len ( p ) } func ( p keyValList ) Less ( i , j int ) bool { return p [ i ]. val < p [ j ]. val } func ( p keyValList ) Swap ( i , j int ){ p [ i ], p [ j ] = p [ j ], p [ i ] }","title":"Go"},{"location":"dictionary/#python","text":"from typing import Dict , List , Tuple word_list : List [ str ] = [ \"table\" , \"chair\" , \"table\" , \"glass\" ] words : Dict [ str , int ] = {} for item in word_list : try : words [ item ] += 1 except : words [ item ] = 1 print ( words ) # sort by descending value words_l : List [ Tuple [ str , int ]] = list ( words . items ()) words_l . sort ( reverse = True ) print ( words_l )","title":"Python"},{"location":"dictionary/#rust","text":"use std :: collections :: HashMap ; use std :: cmp :: Reverse ; fn main () { //count words let word_list = vec ! [ \"table\" , \"chair\" , \"table\" , \"glass\" ]; let mut words : HashMap < String , usize > = HashMap :: new (); for item in word_list { let count = words . entry (( * item ). to_string ()). or_insert ( 0 ); * count += 1 ; } //get specific key value let value = words . get ( \"chair\" ). expect ( \"no key\" ); println ! ( \"{:?} {:?}\" , & words , value ); //sort by descending value let mut words_v : Vec < _ > = words . iter (). collect (); words_v . sort_by_key ( |& ( word , count ) | ( Reverse ( count ), word )); println ! ( \"{:?}\" , & words_v ); }","title":"Rust"},{"location":"hello/","text":"Rust cargo new hello -- bin cd hello cargo run C# dotnet new console -o hello cd hello dotnet run Dart pub global activate stagehand mkdir hello cd hello stagehand console-full pub get dart bin/main.dart","title":"Hello with CLI"},{"location":"hello/#rust","text":"cargo new hello -- bin cd hello cargo run","title":"Rust"},{"location":"hello/#c35","text":"dotnet new console -o hello cd hello dotnet run","title":"C#"},{"location":"hello/#dart","text":"pub global activate stagehand mkdir hello cd hello stagehand console-full pub get dart bin/main.dart","title":"Dart"},{"location":"lists1/","text":"C# using System ; using System.Collections.Generic ; public class Program { public static void Main ( string [] args ) { List < string > lst1 = new List < string >(); var lst2 = new List < string > { \"str20\" , \"str21\" }; //append element lst1 . Add ( \"str10\" ); //append list lst1 . AddRange ( lst2 ); //add head element lst1 . Insert ( 0 , \"str00\" ); //reverse lst1 . Reverse (); //sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] //list length var lst3 = lst1 . GetRange ( 1 , lst1 . Count - 1 ); Console . WriteLine (); foreach ( var item in lst3 ) { Console . Write ( \"{0} \" , item ); } //map and filter var lst4 = lst1 . Select (( x ) => x . ToUpper ()); var lst5 = lst4 . Where (( x ) => x != \"STR00\" ); Console . WriteLine (); foreach ( var item in lst5 ) { Console . Write ( \"{0} \" , item ); } } } Dart Go package main import ( \"fmt\" \"sort\" \"strings\" ) func main () { lst1 := stringList {} lst2 := stringList { \"str20\" , \"str21\" } //append element lst1 = append ( lst1 , \"str10\" ) //append list lst1 = append ( lst1 , lst2 ... ) //add head element lst1 = append ([] string { \"str00\" }, lst1 ... ) //reverse sort . Sort ( sort . Reverse ( lst1 )) //sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] //list length lst3 := lst1 [ 1 : len ( lst1 )] fmt . Printf ( \"\\n%v\" , lst3 ) //map and filter lst4 := stringList {} for _ , elem := range lst1 { lst4 = append ( lst4 , strings . ToUpper ( elem )) } lst5 := stringList {} for _ , elem := range lst4 { if elem != \"STR00\" { lst5 = append ( lst5 , elem ) } } fmt . Printf ( \"\\n%v\" , lst5 ) } type stringList [] string func ( p stringList ) Len () int { return len ( p ) } func ( p stringList ) Less ( i , j int ) bool { return p [ i ] < p [ j ] } func ( p stringList ) Swap ( i , j int ) { p [ i ], p [ j ] = p [ j ], p [ i ] } Python from typing import List lst1 : List [ str ] = [] lst2 : List [ str ] = [ \"str20\" , \"str21\" ] # append element lst1 = lst1 + [ \"str10\" ] # append list lst1 = lst1 + lst2 # add head element lst1 = [ \"str00\" ] + lst1 # reverse lst1 . reverse () # sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] # list length lst3 : List [ str ] = lst1 [ 1 : len ( lst1 )] print ( lst3 ) # map and filter lst4 : List [ str ] = [ elem for elem in map ( lambda x : x . upper (), lst1 )] lst5 = [ elem for elem in filter ( lambda x : x != \"STR00\" , lst4 )] print ( lst5 ) Rust","title":"Lists"},{"location":"lists1/#c35","text":"using System ; using System.Collections.Generic ; public class Program { public static void Main ( string [] args ) { List < string > lst1 = new List < string >(); var lst2 = new List < string > { \"str20\" , \"str21\" }; //append element lst1 . Add ( \"str10\" ); //append list lst1 . AddRange ( lst2 ); //add head element lst1 . Insert ( 0 , \"str00\" ); //reverse lst1 . Reverse (); //sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] //list length var lst3 = lst1 . GetRange ( 1 , lst1 . Count - 1 ); Console . WriteLine (); foreach ( var item in lst3 ) { Console . Write ( \"{0} \" , item ); } //map and filter var lst4 = lst1 . Select (( x ) => x . ToUpper ()); var lst5 = lst4 . Where (( x ) => x != \"STR00\" ); Console . WriteLine (); foreach ( var item in lst5 ) { Console . Write ( \"{0} \" , item ); } } }","title":"C#"},{"location":"lists1/#dart","text":"","title":"Dart"},{"location":"lists1/#go","text":"package main import ( \"fmt\" \"sort\" \"strings\" ) func main () { lst1 := stringList {} lst2 := stringList { \"str20\" , \"str21\" } //append element lst1 = append ( lst1 , \"str10\" ) //append list lst1 = append ( lst1 , lst2 ... ) //add head element lst1 = append ([] string { \"str00\" }, lst1 ... ) //reverse sort . Sort ( sort . Reverse ( lst1 )) //sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] //list length lst3 := lst1 [ 1 : len ( lst1 )] fmt . Printf ( \"\\n%v\" , lst3 ) //map and filter lst4 := stringList {} for _ , elem := range lst1 { lst4 = append ( lst4 , strings . ToUpper ( elem )) } lst5 := stringList {} for _ , elem := range lst4 { if elem != \"STR00\" { lst5 = append ( lst5 , elem ) } } fmt . Printf ( \"\\n%v\" , lst5 ) } type stringList [] string func ( p stringList ) Len () int { return len ( p ) } func ( p stringList ) Less ( i , j int ) bool { return p [ i ] < p [ j ] } func ( p stringList ) Swap ( i , j int ) { p [ i ], p [ j ] = p [ j ], p [ i ] }","title":"Go"},{"location":"lists1/#python","text":"from typing import List lst1 : List [ str ] = [] lst2 : List [ str ] = [ \"str20\" , \"str21\" ] # append element lst1 = lst1 + [ \"str10\" ] # append list lst1 = lst1 + lst2 # add head element lst1 = [ \"str00\" ] + lst1 # reverse lst1 . reverse () # sublist[\"str21\", \"str20\", \"str10\", \"str00\"]->[\"str20\", \"str10\", \"str00\"] # list length lst3 : List [ str ] = lst1 [ 1 : len ( lst1 )] print ( lst3 ) # map and filter lst4 : List [ str ] = [ elem for elem in map ( lambda x : x . upper (), lst1 )] lst5 = [ elem for elem in filter ( lambda x : x != \"STR00\" , lst4 )] print ( lst5 )","title":"Python"},{"location":"lists1/#rust","text":"","title":"Rust"},{"location":"playglinks/","text":"C# .NET Fiddle Dart DatPad Go Go Playground Python Tio Python3 Rust Rust Playground","title":"Playground Links"},{"location":"playglinks/#c35","text":".NET Fiddle","title":"C#"},{"location":"playglinks/#dart","text":"DatPad","title":"Dart"},{"location":"playglinks/#go","text":"Go Playground","title":"Go"},{"location":"playglinks/#python","text":"Tio Python3","title":"Python"},{"location":"playglinks/#rust","text":"Rust Playground","title":"Rust"},{"location":"syscom/","text":"C# using System ; using System.Diagnostics ; public class Program { public static void Main ( string [] args ) { var psi = new ProcessStartInfo (); var process = new Process (); //(\"cargo\", \"version\"); psi . Arguments = \"version\" ; psi . FileName = \"cargo\" ; psi . RedirectStandardOutput = true ; process . StartInfo = psi ; process . Start (); while (! process . StandardOutput . EndOfStream ) { var line = process . StandardOutput . ReadLine (); Console . WriteLine ( line ); } } } Dart import \"dart:io\" ; main ( List < String > arguments ) { Process . run ( 'cargo' , [ 'version' ]). then (( ProcessResult result ) { print ( result . stdout ); }); } Go package main import ( \"fmt\" \"os/exec\" ) func main () { out , _ := exec . Command ( \"go\" , \"version\" ). Output () output := string ( out ) fmt . Printf ( \"\\n%s\" , output ) } Python import subprocess outp = subprocess . run ([ \"cargo\" , \"version\" ], capture_output = True , text = True ) print ( outp . stdout ) Rust use std :: process :: Command ; fn main () { let output = Command :: new ( \"cargo\" ) . args ( & [ \"version\" ]) . output () . expect ( \"failed to execute process\" ); println ! ( \"stdout: {}\" , String :: from_utf8_lossy ( & output . stdout )); }","title":"System command"},{"location":"syscom/#c35","text":"using System ; using System.Diagnostics ; public class Program { public static void Main ( string [] args ) { var psi = new ProcessStartInfo (); var process = new Process (); //(\"cargo\", \"version\"); psi . Arguments = \"version\" ; psi . FileName = \"cargo\" ; psi . RedirectStandardOutput = true ; process . StartInfo = psi ; process . Start (); while (! process . StandardOutput . EndOfStream ) { var line = process . StandardOutput . ReadLine (); Console . WriteLine ( line ); } } }","title":"C#"},{"location":"syscom/#dart","text":"import \"dart:io\" ; main ( List < String > arguments ) { Process . run ( 'cargo' , [ 'version' ]). then (( ProcessResult result ) { print ( result . stdout ); }); }","title":"Dart"},{"location":"syscom/#go","text":"package main import ( \"fmt\" \"os/exec\" ) func main () { out , _ := exec . Command ( \"go\" , \"version\" ). Output () output := string ( out ) fmt . Printf ( \"\\n%s\" , output ) }","title":"Go"},{"location":"syscom/#python","text":"import subprocess outp = subprocess . run ([ \"cargo\" , \"version\" ], capture_output = True , text = True ) print ( outp . stdout )","title":"Python"},{"location":"syscom/#rust","text":"use std :: process :: Command ; fn main () { let output = Command :: new ( \"cargo\" ) . args ( & [ \"version\" ]) . output () . expect ( \"failed to execute process\" ); println ! ( \"stdout: {}\" , String :: from_utf8_lossy ( & output . stdout )); }","title":"Rust"}]}